<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Chanomic Blog</title>
    <link>https://bombrary.github.io/blog/</link>
    <description>Recent content on Chanomic Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Sun, 26 Jan 2020 14:00:25 +0900</lastBuildDate>
    
	<atom:link href="https://bombrary.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>GraphvizでTeXの数式を表示する</title>
      <link>https://bombrary.github.io/blog/posts/graphviz-tex/</link>
      <pubDate>Sun, 26 Jan 2020 14:00:25 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/graphviz-tex/</guid>
      <description>Graphvizはグラフを描画してくれる素晴らしいソフトなのだが、単体では数式を表示することができない。
dot2tex dot2texを利用すると、グラフのラベルに数式が使えるようになる。
次の手順でグラフを作る。
 dot言語でグラフを書く dot2texでdotファイルをtexファイルに変換 texを使ってpdfなりsvgなりを作る。  pdfならplatex + dvipdfmxまたはptex2pdfを使う。 svgならplatex + dvisvgmを使う。    いやGraphviz使ってないじゃないか、と思うかもしれない。しかしDependensiesにGraphvizが含まれているから、おそらくGraphvizの描画エンジンを利用してノードの位置を決定しているのだと思う。
インストール Python製のソフトウェアみたいで、pip経由でインストールする。
$ pip3 install dot2tex  利用の手順 dot言語でグラフを書く 今回は次のようにする。ファイル名は適当にgraph.dotとする。
digraph { graph [ rankdir=&amp;quot;LR&amp;quot; ] node [ shape=&amp;quot;circle&amp;quot;, fixedsize=true, height=0.6 ] Q0 [texlbl=&amp;quot;$q_0$&amp;quot;]; Q1 [texlbl=&amp;quot;$q_1$&amp;quot;]; Q2 [texlbl=&amp;quot;$q_2$&amp;quot;]; Q3 [texlbl=&amp;quot;$q_3$&amp;quot;]; Q4 [texlbl=&amp;quot;$q_4$&amp;quot;]; Q5 [texlbl=&amp;quot;$q_5$&amp;quot;]; Q6 [texlbl=&amp;quot;$q_6$&amp;quot;]; Q7 [texlbl=&amp;quot;$q_7$&amp;quot;]; Q8 [texlbl=&amp;quot;$q_8$&amp;quot;]; Q9 [texlbl=&amp;quot;$q_9$&amp;quot;]; Q10 [texlbl=&amp;quot;$q_{10}$&amp;quot;]; Q11 [texlbl=&amp;quot;$q_{11}$&amp;quot;]; Q12 [texlbl=&amp;quot;$q_{12}$&amp;quot;]; Q13 [texlbl=&amp;quot;$q_{13}$&amp;quot;]; Q0 -&amp;gt; Q1 [label=&amp;quot; &amp;quot;, texlbl=&amp;quot;$\varepsilon$&amp;quot;]; Q0 -&amp;gt; Q4 [label=&amp;quot; &amp;quot;, texlbl=&amp;quot;$\varepsilon$&amp;quot;]; Q0 -&amp;gt; Q7 [label=&amp;quot; &amp;quot;, texlbl=&amp;quot;$\varepsilon$&amp;quot;]; Q1 -&amp;gt; Q2 [label=&amp;quot; &amp;quot;, texlbl=&amp;quot;$a$&amp;quot;]; Q2 -&amp;gt; Q3 [label=&amp;quot; &amp;quot;, texlbl=&amp;quot;$b$&amp;quot;]; Q3 -&amp;gt; Q7 [label=&amp;quot; &amp;quot;, texlbl=&amp;quot;$\varepsilon$&amp;quot;]; Q4 -&amp;gt; Q5 [label=&amp;quot; &amp;quot;, texlbl=&amp;quot;$b$&amp;quot;]; Q5 -&amp;gt; Q6 [label=&amp;quot; &amp;quot;, texlbl=&amp;quot;$b$&amp;quot;]; Q6 -&amp;gt; Q7 [label=&amp;quot; &amp;quot;, texlbl=&amp;quot;$\varepsilon$&amp;quot;]; Q7 -&amp;gt; Q8 [label=&amp;quot; &amp;quot;, texlbl=&amp;quot;$a$&amp;quot;]; Q7 -&amp;gt; Q0 [label=&amp;quot; &amp;quot;, texlbl=&amp;quot;$\varepsilon$&amp;quot;]; Q8 -&amp;gt; Q9 [label=&amp;quot; &amp;quot;, texlbl=&amp;quot;$\varepsilon$&amp;quot;]; Q8 -&amp;gt; Q11 [label=&amp;quot; &amp;quot;, texlbl=&amp;quot;$\varepsilon$&amp;quot;]; Q9 -&amp;gt; Q10 [label=&amp;quot; &amp;quot;, texlbl=&amp;quot;$b$&amp;quot;]; Q10 -&amp;gt; Q13 [label=&amp;quot; &amp;quot;, texlbl=&amp;quot;$\varepsilon$&amp;quot;]; Q11 -&amp;gt; Q12 [label=&amp;quot; &amp;quot;, texlbl=&amp;quot;$c$&amp;quot;]; Q12 -&amp;gt; Q13 [label=&amp;quot; &amp;quot;, texlbl=&amp;quot;$\varepsilon$&amp;quot;]; } texlblとはdot2texが読むための属性。おそらくtex labelの略で、これがnodeまたはedgeのラベルとして、texファイルに直接展開される。そのため、数式を描きたいなら$で囲む。もしdotファイル上にlabel属性が定義されていたら、texlblの内容に上書きされる。</description>
    </item>
    
    <item>
      <title>Elmメモ - 画像のプレビュー機能を作る</title>
      <link>https://bombrary.github.io/blog/posts/elm-image-preview/</link>
      <pubDate>Mon, 13 Jan 2020 11:00:50 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/elm-image-preview/</guid>
      <description>Elmを利用して、画像を選択してそれを表示するアプリを作る。
ファイル読み込みの方法 Select.file関数を利用する。これはファイル選択用のエクスプローラを開くためのCmd Msgを作成してくれる。選択したファイルはMsgに載せられる。
適切なMIMEタイプを指定すると、エクスプローラ上にてそのタイプのファイルしか選択できなくなる。例えば、text/plainを選択しておけば、拡張子.txtのファイルしか選択できなくなる。
Select.file &amp;#34;MIMEタイプのリスト&amp;#34; &amp;#34;Msg&amp;#34; 画像ファイルへの変換 こうして得られたファイルはFileと呼ばれる型で保持される。
もしファイルを文字列として扱いたいなら、File.toStringを利用する。
もし画像として扱いたいなら、File.toUrlを利用する。これは画像をBase64符号化した文字列を作る。これをimgタグのsrc属性に指定すれば、画像が表示される。
画像を選択し、それを表示するアプリの作成 準備 プロジェクトを作成して、elm/fileをインストール。
$ elm init $ elm install elm/file  src/Main.elmの雛形を作る。
module Main exposing (..) import Browser import Html exposing (..) import Html.Attributes exposing (..) import Html.Events exposing (..) import File exposing (File) import File.Select as Select import Task main = Browser.element { init = init , update = update , view = view , subscriptions = subscriptions } type alias Model = { } init : () -&amp;gt; (Model, Cmd Msg) init _ = ( { } , Cmd.</description>
    </item>
    
    <item>
      <title>Elmメモ - 文字列をIPアドレスに変換(2) Parserを用いる方法</title>
      <link>https://bombrary.github.io/blog/posts/elm-ipaddr-parse/</link>
      <pubDate>Sun, 05 Jan 2020 14:29:15 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/elm-ipaddr-parse/</guid>
      <description>準備 前回のsrc/IPAddr.elmを全て消し、内容を以下の通りにする。
module IPAddr exposing (..) import Parser type IPAddr = IPAddr Int Int Int Int $ elm repl  import Parser exposing (..)  import IPAddr exposing (..)  Parserの基本 以下の2つのステップに分かれる。
 Parserを作る Parserを実行する - Parser.runを用いる  ライブラリでは、標準で用意されているParserと、それらを組み合わせて新たなParserを作るための関数が用意されている。
 run int &#34;123&#34; Ok 123 : Result (List Parser.DeadEnd) Int  run int &#34;123abc&#34; Ok 123 : Result (List Parser.DeadEnd) Int  run int &#34;abc123abc&#34; Err [{ col = 1, problem = ExpectingInt, row = 1 }] : Result (List Parser.</description>
    </item>
    
    <item>
      <title>Elmメモ - 文字列をIPアドレスに変換(1) splitを用いる方法</title>
      <link>https://bombrary.github.io/blog/posts/elm-ipaddr-split/</link>
      <pubDate>Sun, 05 Jan 2020 11:27:01 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/elm-ipaddr-split/</guid>
      <description>IPv4アドレスの文字列&amp;quot;192.168.1.1&amp;quot;をパースする方法を考える。IPAddrの内部表現は次のようにする。
type IPAddr = IPAddr Int Int Int Int 思いつくのは次の2通り。
 ピリオドでsplitして、整数値に変換する。 パーサを利用する。  いずれにしても結構面倒。この記事では前者だけやる。
準備 適当なディレクトリで次のコマンドを実行。
$ elm init $ elm install elm/parser  src/IPAddr.elmを作り、内容を以下の通りにする。
module IPAddr exposing (..) type IPAddr = IPAddr Int Int Int Int $ elm repl  import IPAddr exposing (..)  方針 次の処理を行う関数をfromStringとして定義する。
 文字列を.でsplitする。 Listの要素数が4でなければ失敗。 Listの各要素にString.toIntを適用し、どれか一つでも失敗すれば全体としても失敗。 Listを[a,b,c,d]としたとき、IPAddr a b c dを返す。  traverseの実装 3の処理は、次の関数として抽象化できる: リストの各要素にfを適用し、その結果すべてがJustを返したときだけ、全体の結果を返す。
traverse : (a -&amp;gt; Maybe b) -&amp;gt; List a -&amp;gt; Maybe List b 原始的な実装 なるべくfoldrとかを使わずに書こうとするとこんな感じになる。</description>
    </item>
    
    <item>
      <title>Elmメモ - ランダムな位置に円を描画する</title>
      <link>https://bombrary.github.io/blog/posts/elm-random-circle/</link>
      <pubDate>Wed, 01 Jan 2020 21:03:50 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/elm-random-circle/</guid>
      <description>乱数の練習に。
準備 プロジェクト用のディレクトリを適当に作り、そこで以下のコマンドを実行。
$ elm init  必要なモジュールを入れる。
$ elm install elm/svg $ elm install elm/random  Main.elmを作成し、最低限の文を定義しておく。
module Main exposing (..) import Browser import Svg exposing (..) import Svg.Attributes as SA exposing (..) import Svg.Events as SE exposing (..) import Random 円の描画 こんな感じの円を描画する。
1   SVGでは次のように書く。
&amp;lt;svg width=&amp;#34;100px&amp;#34; height=&amp;#34;100px&amp;#34;&amp;gt; &amp;lt;g transform=&amp;#34;translate(50, 50)&amp;#34;&amp;gt; &amp;lt;circle r=&amp;#34;10&amp;#34; fill=&amp;#34;white&amp;#34; stroke=&amp;#34;black&amp;#34; /&amp;gt; &amp;lt;text text-anchor=&amp;#34;middle&amp;#34; dominant-baseline=&amp;#34;central&amp;#34;&amp;gt;1&amp;lt;/text&amp;gt; &amp;lt;/g&amp;gt; &amp;lt;/svg&amp;gt; 円の情報で必要なのは次の4つ:
 x座標 y座標 半径 text要素の文字列  そこで円は次のように定義する。</description>
    </item>
    
    <item>
      <title>JavaScript/Elm ビット演算のときにはまったこと</title>
      <link>https://bombrary.github.io/blog/posts/js-elm-bitwise-caution/</link>
      <pubDate>Tue, 31 Dec 2019 09:34:25 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/js-elm-bitwise-caution/</guid>
      <description>結論  JavaScriptにおいて、&amp;gt;&amp;gt;&amp;gt;以外のビット演算は32ビット符号付き整数値として扱われる。
→ 例えば&amp;amp;|^~の計算前に、オペランドに型変換が起こる(ソース)。  JSにおいて数字はNumberという型しかないが、ビット演算のときだけ32ビット整数値に変換されるっぽい   JavaScriptにおいて、x &amp;gt;&amp;gt;&amp;gt; 0を使うと符号なし整数になる。 負数を2で割り続けても、コンピュータにおける2進表現にはならない。  これはすごく当たり前だった コンピュータにおける2進数表現にしたいなら，論理シフトを使うこと。   ElmはJavaScriptに変換されるので、上の事実はすべてElmでも当てはまる。  各種ビット演算は、JSの演算をそのまま使っているっぽい(ソース)    検証コード $ elm init  src/MyBitwise.elmを作成し、内容を以下のようにする。
module MyBitwise exposing (..) import Bitwise toBinaryString : Int -&amp;gt; String toBinaryString x = let bit = Bitwise.and x 1 rem = Bitwise.shiftRightZfBy 1 x in if rem &amp;gt; 0 then (toBinaryString rem) ++ (String.fromInt bit) else String.fromInt bit elm replを起動し、試す。まず必要なモジュールをimportする。</description>
    </item>
    
    <item>
      <title>iPhoneアプリ開発メモ - 棒グラフの作成(Chartsの利用)</title>
      <link>https://bombrary.github.io/blog/posts/iphone-barchart-ioscharts/</link>
      <pubDate>Sun, 29 Dec 2019 22:37:26 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/iphone-barchart-ioscharts/</guid>
      <description>今度は外部ライブラリChartsを利用して、棒グラフを作成してみる。
目標  値が最大のデータは色をオレンジにする アニメーションがある 棒グラフの上に値を表示する ページ切り替えができる棒グラフを作る タップしたらイベントを発生させる  1〜3、5は機能としてある。4だけ頑張って作る。思い通りのレイアウトにするためにはプロパティとかドキュメントとかを漁る必要があるが、どこにどのプロパティがあるのかは大体予想できる。
 ChartDataSet.colorsで各棒の色を変更できる。 BarChartView.animate(yAxisDuration:)を利用。 BarChartView.drawValueAboveBarEnabled = trueとする。表示形式を変更するためにはChartDataSet.valueFormatterにフォーマット用のオブジェクトを指定する。 ScrollViewの中ににBarChartViewを複数配置。 ChartViewDelegateを利用。  その他デフォルトの設定だと表示する情報量が多すぎるので、いくつかのプロパティをいじる。
Chartsのインストール まず、CocoaPodsがインストールされていることが前提。
プロジェクトフォルダで以下のコマンドを実行。
$ pod init podfileが作成されるので、それを編集する。use_frameworks!の下に以下の記述を追加。
pod &#39;Charts&#39; プロジェクトフォルダで以下のコマンドを実行。
$ pod install 以降、プロジェクトはプロジェクト名.xcodeprojではなくプロジェクト名.xcworkspaceから開く。
基本 import UIKit import Charts struct BarChartModel { let value: Int let name: String } class ViewController: UIViewController { let barItems = [ (7, &amp;#34;太郎&amp;#34;), (1, &amp;#34;次郎&amp;#34;), (2, &amp;#34;三郎&amp;#34;), (6, &amp;#34;四郎&amp;#34;), (3, &amp;#34;五郎&amp;#34;), (9, &amp;#34;六郎&amp;#34;), (2, &amp;#34;七郎&amp;#34;), (3, &amp;#34;八郎&amp;#34;), (1, &amp;#34;九郎&amp;#34;), (5, &amp;#34;十郎&amp;#34;), (1, &amp;#34;十一郎&amp;#34;), (1, &amp;#34;十二郎&amp;#34;), (6, &amp;#34;十三郎&amp;#34;) ] override func viewDidLoad() { super.</description>
    </item>
    
    <item>
      <title>iPhoneアプリ開発メモ - 棒グラフの作成(UIStackView) (2) アニメーションとタップ処理</title>
      <link>https://bombrary.github.io/blog/posts/iphone-barchart-view02/</link>
      <pubDate>Thu, 26 Dec 2019 10:00:00 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/iphone-barchart-view02/</guid>
      <description>棒グラフをアニメーションさせたり、タップしたら詳細画面に遷移するようにしたい。
(寄り道) StackViewのアニメーション 自分がいままでやったことがあるのは以下のような感じで、frameやlayer.positionをいじるパターン。
UIView.animate(withDuration: 1, animations: { view.position.x += 100 view.frame.size.height += 20 }); ただし、これをAutoLayoutと混ぜて使おうとすると動かなかったり、動いたとしても変な挙動を起こす。そもそも、AutoLayoutは制約を設定して位置やサイズを決定する仕組みで、frameは位置やサイズを手動で決める仕組み。これが競合を起こすのは当たり前な気もする。
StackViewはframeを設定しても何も反応しない。これは内部的にAutoLayoutっぽいことをやっているからなのかもしれない。例えば次のようにしてもStackViewの子要素は変更されない。
subView.frame.size.height = 100 stackView.addArrangedSubview(subView) その代わり、次のようにすると、ちゃんと子要素の高さは100になる。
subView.heightAnchor.constraint(equalToConstant: 100).isActive = true stackView.addArrangedSubview(subView) よって、StackViewでアニメーションするためには、AutoLayoutでのアニメーションの方法を知る必要がある。
AutoLayoutでのアニメーション 例えば、「ボタンを押すと長方形が0から伸びる」アニメーションを実現したい。
まずは次のように、高さ制約を0に設定しておく。ただし、それを何か変数に入れておく。
var constraint: NSLayoutConstraint view.addSubview(view0) constraint = view0.heightAnchor.constraint(equalToConstant: 0) constraint.isActive = true アニメーションをしたいタイミングで、次のように書けば良い。
UIView.animate(withDuration: 1, animations: { constraint.constant = 100 view.layoutIfNeeded() }) constraintにはconstantプロパティがあるので、そこで制約の定数を変更できる。layoutIfNeededは、アプリにレイアウト変更を直ちにさせるメソッド。
画面遷移後、下から長方形が伸びてくる処理は次のように書ける。
class ViewController: UIViewController { var constraint: NSLayoutConstraint! override func viewDidLoad() { super.viewDidLoad() let myView = UIView() myView.</description>
    </item>
    
    <item>
      <title>iPhoneアプリ開発メモ - 棒グラフの作成(UIStackView) (1)</title>
      <link>https://bombrary.github.io/blog/posts/iphone-barchart-view01/</link>
      <pubDate>Tue, 24 Dec 2019 13:07:39 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/iphone-barchart-view01/</guid>
      <description>前に頑張ってCoreGraphicsを使って棒グラフを描いたが、やはりViewを棒に見立てて扱った方が良さそうだ。考えられる利点は次の3つ。
 タップ時に何かアクションを起こせる。例えば、棒グラフをタップしたら、そのデータに関する詳細ページに飛ぶ、などの処理が実装できる。 アニメーションについてのコードを描きやすい。例えば棒グラフの高さを0から伸ばしていくアニメーションが実現できる。 StackViewで棒を管理すれば、棒のサイズや棒同士の間隔を自動で設定してくれる  これはやるしかない。
基本的にはこちらを参考にしながら進めていく。
UIStackViewをコード上で使う基本 とりあえず使い方を確認する。
Main.storyboard こんな感じにする。
  ViewController.swift class ViewController: UIViewController { let colors: [UIColor] = [.systemRed, .systemBlue, .systemPink, .systemGreen, .systemIndigo] let percentages: [CGFloat] = [0.1, 0.2, 0.5, 0.3, 0.9] @IBOutlet weak var graphStackView: UIStackView! override func viewDidLoad() { super.viewDidLoad() //Doanyadditionalsetupafterloadingtheview. graphStackView.distribution = .fillEqually graphStackView.alignment = .bottom graphStackView.spacing = 20 graphStackView.isLayoutMarginsRelativeArrangement = true graphStackView.layoutMargins.left = 20 graphStackView.layoutMargins.right = 20 for (color, percentage) in zip(colors, percentages) { addBar(bgColor: color, percentage: percentage) } } private func addBar(bgColor: UIColor, percentage: CGFloat ) { let view = UIView() let height = graphStackView.</description>
    </item>
    
    <item>
      <title>iPhoneアプリ開発メモ - 棒グラフの作成(UIKit/CoreGraphics) (2)</title>
      <link>https://bombrary.github.io/blog/posts/iphone-barchart-cg02/</link>
      <pubDate>Sun, 22 Dec 2019 15:10:30 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/iphone-barchart-cg02/</guid>
      <description>目標  前回の棒グラフを複数ページにする  今回は、1ページに最大5本の棒が並ぶ、とする。   ページは横スライドで切り替える  プロジェクトは前回のものを引き継がず、新しく作る。
用いるデータ ViewController.swiftが次のようなデータを持っていることを想定する。
var dataSource = [ (7, &amp;#34;太郎&amp;#34;), (1, &amp;#34;次郎&amp;#34;), (2, &amp;#34;三郎&amp;#34;), (6, &amp;#34;四郎&amp;#34;), (3, &amp;#34;五郎&amp;#34;), (9, &amp;#34;六郎&amp;#34;), (2, &amp;#34;七郎&amp;#34;), (3, &amp;#34;八郎&amp;#34;), (1, &amp;#34;九郎&amp;#34;), (5, &amp;#34;十郎&amp;#34;), (1, &amp;#34;十一郎&amp;#34;), (1, &amp;#34;十二郎&amp;#34;), (6, &amp;#34;十三郎&amp;#34;) ] このデータは、後で整形してグラフ描画用のデータに変換する。
UScrollViewの配置 Main.storyboardにUIScrollViewを配置する。サイズ設定はコードで行うので、ここでは単に配置するだけ。
  その後、UIScrollViewのOutlet接続をViewController.swiftに対して行う。
UIScrollVieの設定 「スクロールの対象となるコンテンツを中に入れる」だけで、スクロール可能なViewが作れる。ただし、思い通りの表示にするためには、UIScrollViewやコンテンツのサイズを設定しておく必要がある。
複数ページを持つコンテンツを作りたいので、コンテンツ用Viewの中にページ用のViewが複数存在する状態になる。なのでページの位置やサイズもちゃんと設定する。
ScrollViewのレイアウト こんな感じにする。
  なのでコードはこんな感じにする。
class ViewController: UIViewController { @IBOutlet weak var scrollView: UIScrollView! let marginX: CGFloat = 80 let marginY: CGFloat = 40 override func viewDidLoad() { super.</description>
    </item>
    
    <item>
      <title>iPhoneアプリ開発メモ - 棒グラフの作成(UIKit/CoreGraphics) (1)</title>
      <link>https://bombrary.github.io/blog/posts/iphone-barchart-cg01/</link>
      <pubDate>Sat, 21 Dec 2019 20:10:36 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/iphone-barchart-cg01/</guid>
      <description>iPhoneアプリで棒グラフを描く方法として考えられるのは次の3通り。
 ライブラリを使う - Chartsというライブラリがある。おそらくこれが一般的な選択肢。 Viewを棒グラフに見立てる - UIStackViewをうまく使った例にこんなのがある。 CoreGraphicsを使って手で描画する - 厳密にはUIKit側でこれを扱いやすくしたものがあるみたいで、Drawingとしてまとめられている。  ここではCoreGraphicsの練習を兼ねて、3つ目の方法で棒グラフを書いてみる。
目標  棒グラフを表示する 棒グラフの先端に値を表示する 今回用いるデータは(ラベル, 整数値)とする 整数値を棒グラフの高さとし、棒グラフの頂点にその数字を描く ラベルは棒グラフの下に描く 整数値が最も大きなものの色をオレンジ色にする 画面の大きさに関わらない図を作る  要するに以下のようなものを作る。
  細かいレイアウト 画面の大きさに応じて棒グラフのサイズを変更する必要があるため、レイアウトについてそれなりに決めておく。テキストについては適当なサイズに設定する。
  ビューの幅を$W$、barWidthを$w$、データの個数を$n$とする。するとpadXの個数は$n+1$である。このとから、$w$は次のように計算できる。
$$ \begin{aligned} &amp;amp; wn + \frac{w}{2}(n+1) = W \\ \Leftrightarrow&amp;amp;\ w = \frac{2W}{3n + 1} \end{aligned} $$
この計算結果をbarWidthとして利用する。
準備 Main.storyboardを次のようにしておく。
GraphViewのClassをGraphViewにする。新たにGraphView.swiftを作っておく。
  GraphView.swiftを作る 以下が雛形。
class GraphView: UIView { override func awakeFromNib() { } let data: [(String, CGFloat)] = [(7, &amp;#34;太郎&amp;#34;), (1, &amp;#34;次郎&amp;#34;), (2, &amp;#34;三郎&amp;#34;), (6, &amp;#34;四郎&amp;#34;), (3, &amp;#34;五郎&amp;#34;)] override func draw(_ rect: CGRect) { } } Viewの枠線 layer.</description>
    </item>
    
    <item>
      <title>iPhoneアプリ開発メモ - UIPresentationControllerの利用</title>
      <link>https://bombrary.github.io/blog/posts/iphone-uipresentation/</link>
      <pubDate>Thu, 19 Dec 2019 10:01:42 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/iphone-uipresentation/</guid>
      <description>UIPresentationControllerを利用すると、モーダル表示の方法をカスタマイズできる。これについて備忘録を残す。
そもそもモーダル表示とは そもそもモーダル表示って何？と思ったので調べる。モーダルと検索すると「モーダルウインドウ」の話がよく出てくる。これは「ある操作を終えるまで親ウインドウの操作ができない子ウインドウ」という意味で使われているようだ。これはモーダル表示と似たような意味なのだろうか。判然としないので一次資料を漁る。
AppleのHuman Interface GuidelineにModalityの意味が書いてあって、これを引用すると、
 Modality is a design technique that presents content in a temporary mode that’s separate from the user&#39;s previous current context and requires an explicit action to exit. [意訳] Modalityとは、ユーザの以前の文脈から離れた一時的なモードでコンテンツを表示するデザインの手法。そのモードを終了するためには何か明示的なアクションを必要とする。  ほとんど同じ意味っぽい。
例えば次のようなモーダル表示(Page Sheet)の場合，呼び出し元が下にあってその上に青いビューが載っている。ここでは、「上から下に引っ張る」というアクションを起こすことで、このビューを閉じることができる。
  用意するもの  表示元のViewController 表示先のViewController UIPresentationControllerのサブクラス - これが表示先のViewControllerの表示方法を規定する。  ここでは、表示先のViewControllerのStoryboard IDをdestとする．
準備 まずはボタンをクリックすると表示されるものだけ作る。
Main.storyboard 表示元にはボタンを配置する。表示先はラベルを配置し、適切なConstraintを設定しておく。
  ViewController.swift ボタンのAction接続を作る。ボタンがタップされたら遷移するようにする。
class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() //Doanyadditionalsetupafterloadingtheview. } @IBAction func buttonTapped(_ sender: Any) { let vc = (storyboard?</description>
    </item>
    
    <item>
      <title>Elm/JavaScript ローカルサーバーで通信する際にハマったこと</title>
      <link>https://bombrary.github.io/blog/posts/elm-with-localserver/</link>
      <pubDate>Thu, 19 Dec 2019 09:50:00 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/elm-with-localserver/</guid>
      <description>今回たまたまクライアント側でElmを使ったけど、これはElmに限ったことではない。
結論 Client側での留意点  urlはlocalhost:[port]ではなくhttp://localhost:[port]と指定しなければならない。つまり、URLにはちゃんとスキーム名を指定する。  Server側での留意点  Access-Control-Allow-Originに関連するヘッダーをちゃんと設定する。  成功コード プログラムの内容 サーバーは{ &amp;quot;msg&amp;quot; : &amp;quot;Hello, World!&amp;quot; }という内容のJSONを送ってくるので、クライアントはその値を受け取って&amp;quot;Success: Hello, World!&amp;ldquo;を出力する。それだけ。
Client: Elm module Main exposing (..) import Browser exposing (..) import Json.Decode exposing (..) import Http exposing (..) import Html exposing (..) import Html.Attributes exposing (..) main = Browser.element { init = init , update = update , view = view , subscriptions = subscriptions } type Model = Loading | Failed | Success String init : () -&amp;gt; (Model, Cmd Msg) init _ = ( Loading, getServer ) type Msg = GotData (Result Http.</description>
    </item>
    
    <item>
      <title>D3.js 01信号の可視化</title>
      <link>https://bombrary.github.io/blog/posts/d3js-01signal/</link>
      <pubDate>Tue, 17 Dec 2019 13:56:36 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/d3js-01signal/</guid>
      <description>信号に関する授業を聴いていたらふと思い立ったのでやってみた。
コード index.html 個人的テンプレを書く。
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;ja&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;0-1 Signal&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;0-1 Signale&amp;lt;/h1&amp;gt; &amp;lt;svg&amp;gt; &amp;lt;/svg&amp;gt; &amp;lt;script src=&amp;#34;https://d3js.org/d3.v5.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;script.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; script.js JavaScriptでflatMap使うのはこれが初めてかも。
const format = (data, w) =&amp;gt; { const pairs = d3.pairs(data); const deltas = pairs.flatMap(e =&amp;gt; { let sig = e.toString() if (sig == &amp;#39;0,0&amp;#39;) { return [[1,0]]; } else if (sig == &amp;#39;0,1&amp;#39;) { return [[1,0],[0,-1]]; } else if (sig == &amp;#39;1,0&amp;#39;) { return [[1,0],[0,1]]; } else if (sig == &amp;#39;1,1&amp;#39;) { return [[1,0]]; } else { throw new Error(&amp;#39;invalid element.</description>
    </item>
    
    <item>
      <title>iPhoneアプリ開発メモ - TableViewCellのスワイプ処理</title>
      <link>https://bombrary.github.io/blog/posts/iphone-table-swipe/</link>
      <pubDate>Sun, 15 Dec 2019 10:27:58 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/iphone-table-swipe/</guid>
      <description>目標 スワイプしたら削除されるテーブルを作る。
準備 TableViewに最低限の設定をしておく。
Main.storyboardを次のようにする。
  ViewController.swiftの内容を以下のようにする。
class ViewController: UIViewController { @IBOutlet weak var tableView: UITableView! var items = [&amp;#34;Item1&amp;#34;, &amp;#34;Item2&amp;#34;, &amp;#34;Item3&amp;#34;, &amp;#34;Item4&amp;#34;, &amp;#34;Item5&amp;#34;] override func viewDidLoad() { super.viewDidLoad() //Doanyadditionalsetupafterloadingtheview. tableView.dataSource = self tableView.delegate = self } } extension ViewController: UITableViewDataSource { func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&amp;gt; Int { items.count } func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell { let cell = tableView.dequeueReusableCell(withIdentifier: &amp;#34;testCell&amp;#34;)! cell.</description>
    </item>
    
    <item>
      <title>iPhoneアプリ開発メモ - UIPageViewControllerの利用</title>
      <link>https://bombrary.github.io/blog/posts/iphone-pageview/</link>
      <pubDate>Sat, 14 Dec 2019 22:35:31 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/iphone-pageview/</guid>
      <description>目標 ウォークスルーっぽいものを作る。
 メイン画面でボタンを押すとウォークスルー画面に飛ぶ。 ウォークスルー画面では、左右にスワイプすると画面が移動する。 画面下に、何ページかを教えてくれる白丸(Page Control)を配置する。  登場物  Main.storyboardとViewController.swift Walkthrough.storyboardとPageViewController.swift  準備 上に書いたものをとりあえず全て作る。ただし、PageViewControllerのサブクラスはUIPageViewControllerであることに注意。
Main.storyboard ボタンを一つ作っておく。
Walkthrough.storyboard 配置を次のようにする
   Page View Controllerのidentifierはwalkとする。また、classをPageViewControllerにする。 &amp;ldquo;Page1&amp;quot;と書かれたViewControllerのidentifierはpage1とする。 &amp;ldquo;Page2&amp;quot;と書かれたViewControllerのidentifierはpage2とする。 &amp;ldquo;Page3&amp;quot;と書かれたViewControllerのidentifierはpage3とする。  以下で、Transition Styleを&amp;quot;Scroll&amp;quot;とする。もし&amp;quot;Page Curl&amp;quot;とした場合は、ページをめくるようなアニメーションになる。その代わりにPage Controlが表示されない。
  PageViewController.swift 次のように書く。
class PageViewController: UIPageViewController { var controllers: [UIViewController] = [] override func viewDidLoad() { super.viewDidLoad() //Doanyadditionalsetupafterloadingtheview. view.backgroundColor = .black let stb = storyboard! let page1 = stb.instantiateViewController(withIdentifier: &amp;#34;page1&amp;#34;) let page2 = stb.instantiateViewController(withIdentifier: &amp;#34;page2&amp;#34;) let page3 = stb.</description>
    </item>
    
    <item>
      <title>iPhoneアプリ開発メモ - addTarget/SegmentedControl</title>
      <link>https://bombrary.github.io/blog/posts/iphone-addtarget-segmentctl/</link>
      <pubDate>Sat, 14 Dec 2019 19:44:49 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/iphone-addtarget-segmentctl/</guid>
      <description>目標  降順、昇順の切り替えができるTableViewを作成する。  準備 Main.storyborad 部品を以下のように配置する。
  Segmented Controlのラベルの設定は以下で行える。
  TableViewCellのindentifierはtestCellとする。
ViewController.swift 後々の処理のため、TableViewに表示するデータをitems、その元データをitemsSourceと分けることにする。
class ViewController: UIViewController { let itemsSource = [&amp;#34;items1&amp;#34;, &amp;#34;items2&amp;#34;, &amp;#34;items3&amp;#34;, &amp;#34;items4&amp;#34;, &amp;#34;items5&amp;#34;, &amp;#34;items6&amp;#34;, &amp;#34;items7&amp;#34;, &amp;#34;items8&amp;#34;] var items: [String] = [] @IBOutlet weak var segmentedControl: UISegmentedControl! @IBOutlet weak var tableView: UITableView! override func viewDidLoad() { super.viewDidLoad() //Doanyadditionalsetupafterloadingtheview. tableView.dataSource = self items = itemsSource } } extension ViewController: UITableViewDataSource { func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&amp;gt; Int { return items.</description>
    </item>
    
    <item>
      <title>iPhoneアプリ開発メモ - セミモーダルビューからの遷移</title>
      <link>https://bombrary.github.io/blog/posts/iphone-modal-segue/</link>
      <pubDate>Sat, 14 Dec 2019 11:00:24 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/iphone-modal-segue/</guid>
      <description>目標  セミモーダルビューを作成する セミモーダルビュー上のボタンを押すと、それを閉じた後に別ビューに遷移する。  登場物  Main.storyboardとViewController Menu.storyboardとMenuViewController Dest1.storyboard Dest2.storyboard  前提  今後Viewが増えていく状況を想定して、Storyboardを分割することを考える。Storyboard同士はStoryboard Referenceで結びつける。  セミモーダルビューの作成 検索して良く出てくるのはUIPresentationControllerを利用する方法。ただ今回はなるべくStoryboardで完結させたい。
そこで、以下のページを参考して作ることを考える。
ハンバーガーメニューを作成するには？ - Swift Life
ファイル作成 Menu.storyboard、MenuViewController、 Menu.storyboard、Dest1.storyboard、 Dest2.storyboardの5つをあらかじめ作成しておく。
Menu.storyboard classにはMenuViewControllerを指定する。部品配置は以下のようにする。
全体を包むViewを親View、その中に作ったViewを子Viewと呼ぶことにすると、
 Constraintは適当に設定する。子Viewが画面下に配置されるようにする。 StackViewにはFill Equallyの設定を行っておく。 親Viewの背景色を、黒の半透明に設定する。設定手順は以下の通り。  BackgroundをBlackに設定 BackgroundをCustomに設定し直すと、カラーピッカーが現れる。そこで透明度を50%に設定する。    また、&amp;ldquo;Initial View Controller&amp;quot;にチェックをつける。
親Viewのtagを1に設定しておく。これはタッチイベントを捕捉する際に必要になる。
  Dest1.storyboard、Dest2.storyboard Dest1.storyboardの部品配置は以下のようにする。
&amp;ldquo;Is initial View Controller&amp;quot;にチェックをつける。
  Dest2.storyboardの部品配置は以下のようにする。
&amp;ldquo;Is initial View Controller&amp;quot;にチェックをつける。
  Main.storyboard 部品配置は以下のようにする。
  OpenButtonからStoryboard ReferenceへのSegueのActionは&amp;quot;Present Modally&amp;quot;を選択。Segueの設定は以下のようにする。</description>
    </item>
    
    <item>
      <title>Socket通信勉強(2) - Pythonでの書き方/HTTPサーバーもどき作成</title>
      <link>https://bombrary.github.io/blog/posts/socket02-python/</link>
      <pubDate>Sun, 08 Dec 2019 11:09:35 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/socket02-python/</guid>
      <description>PythonでのSocket通信 やってることはCでやったときと同じである。サーバーとクライアントの通信手順は同じだし、関数名も同じである。しかしCで書いた場合に比べてシンプルに書ける。エラーは例外として投げられるため、自分で書く必要がない。またsockaddr_inなどの構造体が登場することはなく、Pythonでのbind関数とconnect関数の引数に直接アドレス・ポートを指定する。
server.py 前回と同じく、以下の手順で通信を行う。
 listen(待ち受け)用のソケット作成 - socket 「どこからの接続を待つのか」「どのポートにて待ち受けするのか」を決める - bind関数の引数 ソケットにその情報を紐つける - bind 実際に待ち受けする - listen 接続要求が来たら受け入れる - accept 4によって通信用のソケットが得られるので、それを用いてデータのやりとりをする- send/recv  import socket s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind((&amp;#34;&amp;#34;, 8000)) s.listen(5) (sock, addr) = s.accept() print(&amp;#34;Connected by&amp;#34; + str(addr)) sock.send(&amp;#34;Hello, World&amp;#34;.encode(&amp;#39;utf-8&amp;#39;)) sock.close() s.close() 上のコードを見れば各関数がどんな形で引数をとって、どんな値を返すのかがわかると思う。いくつか補足しておく。
bind (受け入れアドレス, ポート)というタプルを引数にとる。受け入れアドレスを空文字列にしておけば、どんなアドレスからの接続も受け入れる。つまりCでやったINADDR_ANYと同じ。
s.bind((&amp;#34;&amp;#34;, 8000)) encode Pythonのstring型をそのまま送ることはできないので、byte型に変換する。これはstring.encodeで行える。
sock.send(&amp;#34;Hello, World&amp;#34;.encode(&amp;#39;utf-8&amp;#39;)) client.py  サーバーとの通信用のソケット作成 - socket サーバが待ち受けている宛先を設定 - connectの引数 2で設定した宛先に対して接続する - connect 1で作ったソケットを用いてデータのやりとりをする。 - send/recv  import socket sock = socket.</description>
    </item>
    
    <item>
      <title>Androidアプリ開発勉強(4) - LiveData/TableLayout/電卓アプリ作成</title>
      <link>https://bombrary.github.io/blog/posts/android04-calc/</link>
      <pubDate>Thu, 28 Nov 2019 14:24:39 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/android04-calc/</guid>
      <description>どんなアプリを作るか 電卓を作る。
市販の電卓とは違い、括弧が使えるようにする。なので、軽い構文解析を書くことになる。しかし今回の記事ではデータの扱い方やViewの組み方に焦点を当てているため、電卓の計算処理についてはかなり軽めに説明する。
プロジェクト作成  プロジェクト名は&amp;quot;Calculator&amp;quot;とする。 DataBindingは有効にする  Fragmentに分ける 今回は1画面のアプリなのでわざわざFragmentに分ける必要もないのだが、「もしかしたら他にもFragmentを追加するかもしれない」というケースを想定して、一応分けてみる。
 CalcFragmentを作成する。xmlファイルはfragment_calc.xmlとする。 activity_main.xmlの内容を以下のようにする。  &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;merge xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34; xmlns:app=&amp;#34;http://schemas.android.com/apk/res-auto&amp;#34; xmlns:tools=&amp;#34;http://schemas.android.com/tools&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;match_parent&amp;#34; tools:context=&amp;#34;.MainActivity&amp;#34;&amp;gt; &amp;lt;fragment android:id=&amp;#34;@+id/calcFragment&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;match_parent&amp;#34; android:name=&amp;#34;com.example.calculator.CalcFragment&amp;#34; /&amp;gt; &amp;lt;/merge&amp;gt; merge Android Kotlin Fundamentals 06.2で存在を初めて知った。こうするとactivity_main.xmlでLayoutを作って、fragmentの中でもまたLayoutを作るといった冗長性を排除できる。
CalcFragmentの設定 string.xml fragment_calc.xmlに設定するための文字列定数を定義する。string.xmlを以下のようにする。
&amp;lt;resources&amp;gt; &amp;lt;string name=&amp;#34;app_name&amp;#34;&amp;gt;Calculator&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_0&amp;#34;&amp;gt;0&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_1&amp;#34;&amp;gt;1&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_2&amp;#34;&amp;gt;2&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_3&amp;#34;&amp;gt;3&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_4&amp;#34;&amp;gt;4&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_5&amp;#34;&amp;gt;5&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_6&amp;#34;&amp;gt;6&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_7&amp;#34;&amp;gt;7&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_8&amp;#34;&amp;gt;8&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_9&amp;#34;&amp;gt;9&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_plus&amp;#34;&amp;gt;+&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_minus&amp;#34;&amp;gt;-&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_mul&amp;#34;&amp;gt;*&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_div&amp;#34;&amp;gt;/&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_ac&amp;#34;&amp;gt;AC&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_eq&amp;#34;&amp;gt;=&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_lp&amp;#34;&amp;gt;(&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_rp&amp;#34;&amp;gt;)&amp;lt;/string&amp;gt; &amp;lt;/resources&amp;gt; fmagment_calc.</description>
    </item>
    
    <item>
      <title>gnuplotの使い方メモ</title>
      <link>https://bombrary.github.io/blog/posts/gnuplot/</link>
      <pubDate>Tue, 26 Nov 2019 10:59:56 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/gnuplot/</guid>
      <description>備忘録に。
インストール Macの場合はbrewでインストールできる。
$ brew install gnuplot gnuplotコマンドで起動。
ファイルをプロットする 例えばdata.txtが以下のようになっているとする。
#x #y1 #y2 0 1 2 1 2 1 2 0 2 3 1 1 これを描画する。
using X:Yで、X番目の列を横軸、Y番目の列を縦軸にする。
w lpとは&amp;quot;with linespoints&amp;quot;の略。つまり線と点を描画する。w lだと&amp;quot;with line&amp;rdquo;、w lp lt 3 lw 2だと&amp;quot;with linepoints linetype 3 linewidth 2&amp;quot;という意味。いろいろある。
$ set xlabel &amp;#34;X axis&amp;#34; $ set ylabel &amp;#34;Y axis&amp;#34; $ plot &amp;#34;data.txt&amp;#34; using 1:2 w pl 軸の範囲指定 例えばx軸を[0,3000]の範囲に制限して描画したいなら、次のコマンドを打つ。
$ set xrange [0:3000] こんな感じで、gnuplotはset 属性名 値で様々な設定をする印象がある。
グラフの重ね書き replotを使う方法 $ plot &amp;#34;data.</description>
    </item>
    
    <item>
      <title>Socket通信の勉強(1) - ディスクリプタ/TCPによる通信</title>
      <link>https://bombrary.github.io/blog/posts/socket01-file-tcp/</link>
      <pubDate>Sun, 24 Nov 2019 17:08:19 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/socket01-file-tcp/</guid>
      <description>Socket通信を勉強する。
前提  プログラムはMac(Mojave)で動かす。 ネットワークに関する知識はほんの少しある。 使うプログラミング言語はC++だが、ここではbetter Cの意味でしか用いない。  (寄り道) ファイル入出力 Socket通信を学んでいると、ファイルディスクリプタが出てきたので、まずはそこから勉強する。
関数定義についてはJM Projectから引用したものを用いる。これはLinuxマニュアルと同じらしいので、恐らくmanコマンドで出力されるものと同じである(ただし英語であるが)。
ファイルディスクリプタとは ファイルディスクリプタとは、ファイルと結びつけられた単なる整数値である。データの読み書きを行う場合は、この整数値を指定してアクセスする。例えばファイルtest.txtのファイルディスクリプタが4だった場合、読み書きをする関数read/writeには引数4を指定する。
個人的には、ファイルとプロセスのやりとりはあるケーブルを介して行なっているイメージがある。例えば番号4の端子にはすでにtest.txtが繋がっているとしよう。このとき、プロセスがtext.txtにアクセスしたいなら、番号4の端子にアクセスすれば良い。
  ファイルの読み込み ファイルディスクリプタを用いてファイルを読み込む例を以下に示す。以下は、test.txtを読み込んで、そのファイルディスクリプタとファイルの内容を出力するプログラムである。
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;fcntl.h&amp;gt; int main() { int fd = open(&amp;#34;test.txt&amp;#34;, O_RDONLY); char buf[64]; read(fd, buf, sizeof(buf)); printf(&amp;#34;fd: %d\n&amp;#34;, fd); printf(&amp;#34;%s\n&amp;#34;, buf); close(fd); return 0; }  test.txtの内容は以下のようにする。
Hello, World 実行すると、以下のように出力される。fdの値は実行環境によって異なる。
fd: 3 Hello, World 以下説明するopen/read/closeは関数ではなく、全てシステムコールである。
openでファイルを開く 開きたいファイルのパスと、読み書きの方法を引数に指定する。成功するとファイルディスクリプタを返す。
#include &amp;lt;fcntl.h&amp;gt; int open(const char *pathname, int flags);  readで読み込む ファイルディスクリプタと、読み取った値を保持しておくためのバッファ、また読み取るデータの長さを指定する。
#include &amp;lt;unistd.</description>
    </item>
    
    <item>
      <title>Androidアプリ開発勉強(3) - データの受け渡し</title>
      <link>https://bombrary.github.io/blog/posts/android03-dataholding/</link>
      <pubDate>Fri, 22 Nov 2019 08:53:21 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/android03-dataholding/</guid>
      <description>次の2つの事項について扱う。
 DataBindingにおけるデータの受け渡し Navigationを用いた、異なるFragment間におけるデータの受け渡し  さらに具体的に言うと、次の機能を持つアプリを作る
 MainFragmentにはEditTextが1つある。 EditTextが入力されると、TextViewが&amp;quot;String: [EditTextの文字列]&amp;ldquo;に変わる。 Buttonが押されると、ReverseFragmentに遷移する ReverseFragmentは、MainFragmentのテキストフィールドの文字列を受け取って、それを逆順にした文字列を表示する。  Android Kotlin Fundamentals Courseでの05辺りを勉強した記録なので、詳しいことはそちらに載っている。
プロジェクト初期設定 &amp;ldquo;Empty Project&amp;quot;として作成して、名前を&amp;quot;DataTest&amp;quot;とする。
build.gradle(module:App)について、dataBindingの設定をしておく。
次のようにMainFragmentとReverseFragmentを作成しておく。作成時、&amp;ldquo;Create layout XML?&amp;ldquo;にのみチェックをつけておく。   MainFragmentの設定 fragment_main.xmlを次のようにする。
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;layout xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34; xmlns:tools=&amp;#34;http://schemas.android.com/tools&amp;#34; tools:context=&amp;#34;.main.MainFragment&amp;#34;&amp;gt; &amp;lt;data&amp;gt; &amp;lt;variable name=&amp;#34;myMsg&amp;#34; type=&amp;#34;com.example.datatest.main.MainFragment.MyMsg&amp;#34; /&amp;gt; &amp;lt;/data&amp;gt; &amp;lt;LinearLayout android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34; android:orientation=&amp;#34;vertical&amp;#34; android:layout_gravity=&amp;#34;center_vertical&amp;#34; &amp;gt; &amp;lt;EditText android:id=&amp;#34;@+id/edit_text&amp;#34; android:layout_width=&amp;#34;wrap_content&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34; android:hint=&amp;#34;@string/hello_blank_fragment&amp;#34; android:layout_gravity=&amp;#34;center_horizontal&amp;#34; android:textAlignment=&amp;#34;center&amp;#34; /&amp;gt; &amp;lt;TextView android:id=&amp;#34;@+id/text_view&amp;#34; android:layout_width=&amp;#34;wrap_content&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34; android:text=&amp;#34;@={myMsg.text}&amp;#34; android:layout_gravity=&amp;#34;center_horizontal&amp;#34; android:textAlignment=&amp;#34;center&amp;#34; /&amp;gt; &amp;lt;Button android:id=&amp;#34;@+id/button&amp;#34; android:layout_width=&amp;#34;wrap_content&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34; android:layout_gravity=&amp;#34;center_horizontal&amp;#34; android:text=&amp;#34;@string/to_reverse_fragment&amp;#34; android:textAllCaps=&amp;#34;false&amp;#34; /&amp;gt; &amp;lt;/LinearLayout&amp;gt; &amp;lt;/layout&amp;gt; 重要なのは以下の部分で、これはMainFragment.</description>
    </item>
    
    <item>
      <title>Androidアプリ開発勉強(2) - Navigationの基本</title>
      <link>https://bombrary.github.io/blog/posts/android02-navigation/</link>
      <pubDate>Wed, 20 Nov 2019 09:03:17 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/android02-navigation/</guid>
      <description>Navigationを用いて画面遷移をやってみる。具体的には以下の処理を行う。
 Fragment01とFragment02を用意する Fragment01でボタンが押されたらFragment02に遷移する  Android Kotlin Fundamentals Courseでの03辺りを勉強した記録なので、詳しいことはそちらに載っている。
Navigationについて 異なるFragment間の遷移を制御する仕組み。遷移の設定を視覚的に行えるらしい。
これ以前はIntentという仕組みを用いていたらしい。これについては必要になりそうならいつか調べる。
プロジェクト作成 Empty Activityを選択し、名前をNavigation Testとする。
build.gradle(Module: app)でDataBindingを有効にしておく。
Fragmentの作成 layouts/にFragmentを作成する。&amp;ldquo;Create layout XML?&amp;ldquo;だけチェックをつけておく。Fragmentは2つ作成し、それぞれ&amp;quot;Fragment01&amp;quot;と&amp;quot;Fragment02&amp;quot;とする。xmlファイルはそれぞれfragment_fragment01.xml、fragment_fragment02.xmlとする。
まずTextViewのtext要素に設定するための定数をstrings.xmlに内容を追加しておく。 &amp;lt;resources&amp;gt; &amp;lt;string name=&amp;#34;app_name&amp;#34;&amp;gt;NavigationTest&amp;lt;/string&amp;gt; &amp;lt;!--TODO: Remove or change this placeholder text --&amp;gt; &amp;lt;string name=&amp;#34;hello_blank_fragment&amp;#34;&amp;gt;Hello blank fragment&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;fragment01&amp;#34;&amp;gt;Fragment01&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;fragment02&amp;#34;&amp;gt;Fragment02&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;click&amp;#34;&amp;gt;Click&amp;lt;/string&amp;gt; &amp;lt;/resources&amp;gt;
fragment_fragment01.xmlの内容は以下の通りにする。Buttonを追加し、textを@string/clickに設定する。TextViewのtextを@string/fragment01に設定する。また全体をConstraintLayoutで包み、DataBindingのためにlayoutでさらに包む。
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;layout xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34; xmlns:app=&amp;#34;http://schemas.android.com/apk/res-auto&amp;#34; xmlns:tools=&amp;#34;http://schemas.android.com/tools&amp;#34; tools:context=&amp;#34;.Fragment01&amp;#34;&amp;gt; &amp;lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;match_parent&amp;#34;&amp;gt; &amp;lt;TextView android:id=&amp;#34;@+id/text_fragment01&amp;#34; android:layout_width=&amp;#34;wrap_content&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34; android:text=&amp;#34;@string/fragment01&amp;#34; app:layout_constraintBottom_toBottomOf=&amp;#34;parent&amp;#34; app:layout_constraintEnd_toEndOf=&amp;#34;parent&amp;#34; app:layout_constraintStart_toStartOf=&amp;#34;parent&amp;#34; app:layout_constraintTop_toTopOf=&amp;#34;parent&amp;#34; /&amp;gt; &amp;lt;Button android:id=&amp;#34;@+id/button&amp;#34; android:layout_width=&amp;#34;wrap_content&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34; android:text=&amp;#34;@string/click&amp;#34; app:layout_constraintBottom_toTopOf=&amp;#34;@+id/text_fragment01&amp;#34; app:layout_constraintEnd_toEndOf=&amp;#34;parent&amp;#34; app:layout_constraintStart_toStartOf=&amp;#34;parent&amp;#34; app:layout_constraintTop_toTopOf=&amp;#34;parent&amp;#34; /&amp;gt; &amp;lt;/androidx.</description>
    </item>
    
    <item>
      <title>Androidアプリ開発勉強(1) - onClick/DataBinding/Fragment</title>
      <link>https://bombrary.github.io/blog/posts/android01-helloworld/</link>
      <pubDate>Tue, 19 Nov 2019 19:54:40 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/android01-helloworld/</guid>
      <description>Android + Kotlinを用いてアプリ開発をするときの勉強メモ。勉強メモなので備忘録程度にしか書いてない。
次のことをやった。
 ボタンを押すとToastを表示 DataBindingを用いる Fragmentを用いる Fragment + DataBinding  Android Kotlin Fundamentals Courseでの01-03辺りを勉強した記録なので、詳しいことはそちらに載っている。
前提  Kotlinは未学習だが雰囲気で読める Android開発は完全未経験  iPhoneアプリ開発は少しだけ経験   Android Studioの環境構築は済んでいる  エミュレータのインストールも完了している Build &amp;amp; Runの方法も知っている    プロジェクト作成 とりあえずプロジェクト名はTestProjectとする。
左側のペインに色々ディレクトリ・ファイルがある。色々漁ってみると、次のようなものがある。
 java/com.example.testapplication/: 基本的にはこの中にKotlinのソースコードを入れるっぽい。ディレクトリ名がjavaなのは歴史的な理由らしい。 res/: resourceの略で、画面や定数の定義がこの中に色々入っている。  res/layout: 画面の定義ファイルが入っている res/values: 定数の定義が入っている  res/values/colors.xml: 色定義 res/values/strings.xml: 文字列定数の定義 res/values/styles.xml: styleの定義。画面の部品のstyleをCSSみたいに設定するためのもの。     build.gradle: Buildの際の様々な設定を記したファイル。  ボタンの配置 res/layouts/activity_main.xmlにメイン画面の定義が書かれている。中央ペイン左下にDesign/Textを切り替えるタブがある。
Designタブ GUIで画面の構造をいじるための画面。直感的に操作できる。色々なペインで分かれている。
 Palette: ドラックアンドドロップできる。 Component Tree: 部品同士の階層構造を表示している。内部構造はXMLなので部品は階層構造になっている。 Attributes: 部品の様々な属性を設定。たくさんあるが、虫眼鏡マークで検索可能。便利。中でもid属性は重要。  id: 部品の識別子。プログラムからアクセスするためにここの設定が必要。    Component Treeにおいて、rootがConstraint Layoutであることに注目。これはConstraint(制約)を用いて部品の配置を設定するためのLayoutである。Constraintについてはやってみた方が早い。</description>
    </item>
    
    <item>
      <title>Djangoの勉強でTodoリストを作る</title>
      <link>https://bombrary.github.io/blog/posts/django-todo-list/</link>
      <pubDate>Fri, 15 Nov 2019 08:26:41 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/django-todo-list/</guid>
      <description>どんなTodoリストを作るか  Todoの登録  情報は短いテキストだけ   Todoをリスト表示 Todoをクリックすると削除  サイトの作成 適当なディレクトリで次のコマンドを実行すると、mysiteというディレクトリが作られる。以降はmysiteディレクトリで作業する。
$ django-admin startproject mysite アプリの作成 mysiteディレクトリにて以下のコマンドを実行すると、todo_listというディレクトリが作られる。ここに実際のアプリの処理を記述していく。:w
$ python3 manage.py startapp todo_list 続いてmysite/settings.pyを開いて、INSTALL_APPSを以下の記述にする。&#39;todo_list.apps.TodoListConfig&#39;を追加しただけ。これはデータベース作成やテンプレート作成のために、djangoがtodo_listのディレクトリを教えているっぽい。Todo_listConfigかと思ったが違うらしい(エラーで「TodoListConfigだよ」と教えてくれた。優しい)。
INSTALLED_APPS = [ &amp;#39;todo_list.apps.TodoListConfig&amp;#39;, &amp;#39;django.contrib.admin&amp;#39;, &amp;#39;django.contrib.auth&amp;#39;, &amp;#39;django.contrib.contenttypes&amp;#39;, &amp;#39;django.contrib.sessions&amp;#39;, &amp;#39;django.contrib.messages&amp;#39;, &amp;#39;django.contrib.staticfiles&amp;#39;, ] viewの作成 mysite/todo_list/views.pyを編集する。とりあえずviewが動くかどうかだけ確認したいので、レスポンスは適当な文字列にする。
from django.shortcuts import render # Create your views here. def index(request): return HttpResponse(&amp;#39;Hello&amp;#39;) urlの設定 まずmysite/mysite/urls.pyの設定をする。urls.pyとは「どんなurlにアクセスされたらどんなviewに処理を任せるか」を記述したものっぽい。ここでは、todo_list/で始まるurlだったらtodo_list/urls.pyに処理を任せるように書いている。
from django.contrib import admin from django.urls import include, path urlpatterns = [ path(&amp;#39;todo_list/&amp;#39;, include(&amp;#39;todo_list.urls&amp;#39;)), path(&amp;#39;admin/&amp;#39;, admin.site.urls), ] ということでmysite/todo_list/urls.pyの設定をする。恐らく存在しないので新しく作成する。todo_list/以降に何も指定されなかったら表示をviews.pyのindex関数に任せるように書いている。</description>
    </item>
    
    <item>
      <title>置換(Permutaion)の勉強メモ(1)</title>
      <link>https://bombrary.github.io/blog/posts/permutation/</link>
      <pubDate>Tue, 12 Nov 2019 10:07:09 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/permutation/</guid>
      <description>置換について、線形代数の教科書に出てきたけど、授業ではあまり触れられなかったので自分で勉強してみる。以下はそのメモ。
置換の定義 定義(置換) $X_n$は$n$個の元を持つ集合とする。このとき、全単射写像 $\sigma: X_n \rightarrow X_n$ を$X_n$上の置換(Permutation)と呼ぶ。  言い換えると、$X_n$を適当に並べたとき、置換 $\sigma$ とはそれを並び替える方法を表したものである。
置換と聞くとReplacementがまず思い浮かぶけど、ここではPermutationなのね。
例 $X_3 = {1,2,3}$ とする。このとき、 $X_n$ の元を並べて $(1,2,3)$ としよう。このとき、 $\sigma(1)=2,\sigma(2)=3,\sigma(3)=1$ とすれば、写像 $\sigma$ は $X_3$ 上の置換となる。このとき、 $(1,2,3)$ という列が $\sigma$ によって $(2,3,1)$ に並び替えられたように見える。  $X_n$の元はなんでも良いが、以後説明のため$X_n = \lbrace 1,2,\ldots,n \rbrace$とする。
置換は以下のように表示することがある：$\sigma(i) = p_i\ (i=1,\ldots,n)$について、
$$ \sigma = \begin{pmatrix} 1 &amp;amp; 2 &amp;amp; \ldots &amp;amp; n \\ p_1 &amp;amp; p_2 &amp;amp; \ldots &amp;amp; p_n \end{pmatrix} $$
先ほど置換とは $X_n$ を適当に並べたとき、置換 $\sigma$ とはそれを並び替えたもの、と表現した。実際、$\sigma$はただの写像なので、並び替えというより対応関係だけが大事である。上の表示方法はあくまで「上の段の元と下の段の元の対応関係」にだけ着目している。従って、上の段が$1,2,\ldots n$という並びになるとは限らない。</description>
    </item>
    
    <item>
      <title>Elmで超簡易Todoリスト</title>
      <link>https://bombrary.github.io/blog/posts/elm-todo-list/</link>
      <pubDate>Sun, 10 Nov 2019 21:08:12 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/elm-todo-list/</guid>
      <description>Todoリストと言っても、フィールドに入力した内容がli要素として追加されるだけ。
Elm習いたてなので、何か無駄があるかも。
個人的になるほどと思った点はList.mapを利用してli要素を生成するところで、これは要素を生成する関数が子要素のリストを引数に取るから実現できる。
import Browser import Html exposing (..) import Html.Attributes exposing (..) import Html.Events exposing (onClick, onInput) main = Browser.sandbox { init = init, update = update, view = view } --Model type alias Todo = { description : String } type alias Model = { todos : List Todo , input : Todo } init : Model init = { todos = [] , input = Todo &amp;#34;&amp;#34; } type Msg = Add | Change String --Update update : Msg -&amp;gt; Model -&amp;gt; Model update msg model = case msg of Add -&amp;gt; { model | todos = model.</description>
    </item>
    
    <item>
      <title>HugoセットアップからGitHubにデプロイするまでの備忘録</title>
      <link>https://bombrary.github.io/blog/posts/hugo-setup/</link>
      <pubDate>Sat, 09 Nov 2019 19:33:37 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/hugo-setup/</guid>
      <description>簡単にセットアップ方法を備忘のために書いておく
前提  MacOS Mojave Homebrew 2.1.16 GitHubのblogリポジトリで公開する この記事でディレクトリを表記する時は、blogローカルリポジトリの最上位を/で表現する  インストール ターミナルにて以下のコマンドを叩く
$ brew install hugo ブログサイトの作成 blogサイトのローカルリポジトリがある前提で進める。blogディレクトリに移動して以下のコマンドを実行する。 forceフラグをつけると、今のディレクトリに何かファイルがあった場合でもサイトを生成してくれる。僕の環境の場合はREADME.mdしかなかったので何も上書きされなかったが、hugoが生成するファイルと名前がかぶる場合は、何かファイルが上書きされる恐れがあるので注意。
$ hugo new site ./ --force すると、何やらたくさんファイルやディレクトリを生成してくれる。
テーマの追加 contrast-hugoが気に入ったのでこれを使う。
/themesに移動して、contrast-hugoのファイルをcloneしてくる
$ git clone https://github.com/niklasbuschmann/contrast-hugo.git 後でテーマをいじるので、一応テーマ名を変更しておく。contrast-hugoをch-modifiedに変更する。
シンタックスハイライトの設定 Chromaというハイライターが入っているらしい。そのテーマはこちらで見られる。今回はgithubというテーマを利用する。
/config.tomlでpygmentsStyle=githubと指定すると、スタイルをhtmlに直接埋め込んでくれる。しかしCSSを後で自分でいじりたいのでこの方法は用いない。その代わり、pygmentsUseClasses=trueとして、CSSを利用することにする。
/themes/ch-modified/static/cssに移動して、以下のコマンドを実行する。
$ hugo gen chromastyles --style=github &amp;gt; syntax.css configの設定 /config.tomlの内容を以下の通りにする。ほとんどの設定項目がデフォルトのもので、正直意味が分かっていないものもある。コメントアウトのところはAboutページのリンクを貼るものだが、Aboutページができたらコメントを外そうと思っている。
baseURL = [ブログのURL] title = [ブログのタイトル] author = [作成者] paginate = 3 languageCode = &amp;#34;ja-jp&amp;#34; DefaultContentLanguage = &amp;#34;ja&amp;#34; enableInlineShortcodes = true footnoteReturnLinkContents = &amp;#34;^&amp;#34; theme = [テーマ] publishDir=&amp;#34;docs&amp;#34; pygmentsUseClasses = true [menu] # 気が向いたら設定する # [[menu.</description>
    </item>
    
    <item>
      <title>Test</title>
      <link>https://bombrary.github.io/blog/posts/my-first-post/</link>
      <pubDate>Sat, 09 Nov 2019 16:00:56 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/my-first-post/</guid>
      <description>このブログではHugoを使っている。
  Syntax highlighting #include &amp;lt;iostream&amp;gt; int main() { std::cout &amp;lt;&amp;lt; &amp;#34;Hello&amp;#34; &amp;lt;&amp;lt; std::endl; return 0; } 
  KaTeX
 inline: $x = 2$ block: $$ x^2 + x + 1 = 0 $$    </description>
    </item>
    
  </channel>
</rss>