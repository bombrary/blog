<!DOCTYPE html>
<html lang="ja-jp">
<head>
  <title>Elmでテトリスを作った話 | Chanomic Blog</title>
  <meta charset="utf-8">
  <meta name="generator" content="Hugo 0.85.0" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://bombrary.github.io/blog/css/index.css">
  <link rel="canonical" href="https://bombrary.github.io/blog/posts/elm-tetris/">
  <link rel="alternate" type="application/rss+xml" href="" title="Chanomic Blog">
  
  <link rel="stylesheet" href="/blog/css/custom.css">

  <link rel="stylesheet" href="/blog/css/syntax.css">



<script async src="https://www.googletagmanager.com/gtag/js?id=UA-152083322-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-152083322-1');
</script>




  
</head>

<body>
<header>
  
    <a href="https://bombrary.github.io/blog/" class="title">Chanomic Blog</a>
  
  
</header>


<article>
  <header>
    <h1><a href="https://bombrary.github.io/blog/posts/elm-tetris/">Elmでテトリスを作った話</a></h1>
    <div class="meta">
      
      <div class="pub-date">
        <time datetime="2021-08-10T17:10:00&#43;09:00">August 10, 2021</time>
      </div>
      
      
      <div class="lastmod-date">
        <div class="lastmod-date__label">(last modified:</div>
        <time datetime="2021-08-10T17:10:00&#43;09:00">August 10, 2021</time>
        <div class="lastmod-date__label">)</div>
      </div>
      
    </div>
    
    <div class="tags-categories">
      <div class="tags">
        <p>tags: </p>
        <ul class="tags_list">
          <li class="tags_item"><a href="https://bombrary.github.io/blog//tags/%e3%83%86%e3%83%88%e3%83%aa%e3%82%b9/">テトリス</a></li>
        </ul>
        
      </div>
      <div class="categories">
        <p>categories: </p>
        
        <ul class="categories_list">
           <li class="tags_item"><a href="https://bombrary.github.io/blog//categories/elm/">Elm</a></li>
        </ul>
        
      </div>
    </div>
  </header>
  
    <aside>
      <h2>目次</h2>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#製作物">製作物</a></li>
    <li><a href="#実装しなければいけない処理">実装しなければいけない処理</a></li>
    <li><a href="#ボードのデータ構造">ボードのデータ構造</a></li>
    <li><a href="#寄り道-ベクトルの定義">寄り道: ベクトルの定義</a></li>
    <li><a href="#テトリミノのデータ構造">テトリミノのデータ構造</a></li>
    <li><a href="#テトリミノ関連の実装">テトリミノ関連の実装</a>
      <ul>
        <li><a href="#テトリミノの位置データ">テトリミノの位置データ</a></li>
        <li><a href="#テトリミノの回転">テトリミノの回転</a></li>
        <li><a href="#テトリミノのボード上への反映">テトリミノのボード上への反映</a></li>
        <li><a href="#テトリミノの衝突判定">テトリミノの衝突判定</a></li>
        <li><a href="#テトリミノの固定">テトリミノの固定</a></li>
      </ul>
    </li>
    <li><a href="#キー状態の管理">キー状態の管理</a></li>
    <li><a href="#乱数の取得">乱数の取得</a></li>
    <li><a href="#super-rotation-system">Super Rotation System</a></li>
    <li><a href="#実装していて気づいたこと">実装していて気づいたこと</a>
      <ul>
        <li><a href="#asパターンマッチ">asパターンマッチ</a></li>
        <li><a href="#内部関数のミス">内部関数のミス</a></li>
        <li><a href="#ゲームの背後で行われる処理をモジュールに分割する">ゲームの背後で行われる処理をモジュールに分割する</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </aside>
    
  <p>Elmでテトリスを作った。この記事では実装にあたって考えたポイントをメモしておく。
コードは説明のために断片的に載せる。</p>
<h2 id="製作物">製作物</h2>
<p><a href="https://bombrary.github.io/tetris-elm/">ここ</a>で遊べる．</p>
<p>Repositryは<a href="https://github.com/bombrary/tetris-elm">こちら</a>。</p>
<h2 id="実装しなければいけない処理">実装しなければいけない処理</h2>
<p>大まかに作らなければいけないのは以下の処理．</p>
<ul>
<li>ボード・テトリミノのデータ構造</li>
<li>テトリミノの出現・回転・落下・固定</li>
<li>テトリミノの衝突判定</li>
<li>ラインがそろった時に消滅する処理</li>
<li>ゲームオーバー処理</li>
<li>キー操作</li>
<li>画面描画</li>
</ul>
<p>この中からいくつかの項目について説明する。</p>
<h2 id="ボードのデータ構造">ボードのデータ構造</h2>
<p>ボードの落とす場は10x20のブロックで構成されている。
壁をボードに含めるかどうか、上部にマージンを設けるかどうかで、実際のボードサイズは変わる。</p>
<p>まず、ボードのブロックをセルと呼ぶことにする。セルを次のように定義する。<code>Color</code>は適当に定義しておく。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="kt">Cell</span>
  <span class="ow">=</span> <span class="kt">Block</span> <span class="kt">Color</span>
  <span class="o">|</span> <span class="kt">Empty</span>
</code></pre></div><p>このセルを使ってボードを定義したいが、悩ましい選択が現れる。</p>
<ul>
<li>セルを要素に持つ<code>List</code>。セルの座標はリストの添字で判断する。</li>
<li>(座標, セル)を要素に持つ<code>List</code>。</li>
<li>キーを座標、値をセルとした<code>Dict</code>。</li>
</ul>
<p><code>List</code>を<code>Array</code>にした実装も考えられる。参考までに、3つは以下のように定義できる。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="n">alias</span> <span class="kt">Board</span> <span class="ow">=</span> <span class="kt">List</span> <span class="kt">Cell</span>

<span class="kr">type</span> <span class="n">alias</span> <span class="kt">Board</span> <span class="ow">=</span> <span class="kt">List</span>
  <span class="p">{</span> <span class="n">pos</span> <span class="kt">:</span> <span class="kt">Vec</span> <span class="kt">Int</span>
  <span class="p">,</span> <span class="n">cell</span> <span class="kt">:</span> <span class="kt">Cell</span>
  <span class="p">}</span>

<span class="kr">type</span> <span class="n">alias</span> <span class="kt">Board</span> <span class="ow">=</span> <span class="kt">Dict</span> <span class="p">(</span><span class="kt">Vec</span> <span class="kt">Int</span><span class="p">)</span> <span class="kt">Cell</span>
</code></pre></div><p>ボードのデータ構造によって諸々の関数の実装方法が大きく変わってくるので、どれを選ぶか慎重になる必要がある。</p>
<p>2つ目と3つ目のデータ構造は<a href="https://github.com/rofrol/elm-games#tetris">elm-gamesのRepository</a>に載っているテトリスのコードから発見した。
それらのコードを見つけた時にはすでに1番目で作ってしまっていたので、現状の自分の実装は1番目のものである。</p>
<p>TEAのView関数としての扱いやすさを考えるなら、2番目の実装が一番良いと思う。例えばセルの描画関数を<code>viewCell</code>として、<code>viewBoard</code>は次のように書ける。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">import</span> <span class="nn">Svg</span>


<span class="nf">viewBoard</span> <span class="kt">:</span> <span class="kt">Board</span> <span class="ow">-&gt;</span> <span class="kt">Svg</span> <span class="kt">Msg</span>
<span class="nf">viewBoard</span> <span class="n">board</span> <span class="ow">=</span>
  <span class="kt">Svg</span><span class="o">.</span><span class="n">g</span> <span class="kt">[]</span>
    <span class="p">(</span><span class="kt">List</span><span class="o">.</span><span class="n">map</span> <span class="n">viewCell</span> <span class="n">board</span><span class="p">)</span>
</code></pre></div><p>他のデータ構造で実装する場合でも、<code>viewBoard</code>に渡す前に一旦<code>{ pos, cell }</code>のデータ構造に変換しておいた方が書きやすい。</p>
<p>座標系については、SVGのものと合わせる。つまり、右向きがx軸正、下向きがy軸正のものとして扱う。</p>
<h2 id="寄り道-ベクトルの定義">寄り道: ベクトルの定義</h2>
<p>回転や平行移動などの計算が現れるため、ベクトルを定義しておくと便利。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="n">alias</span> <span class="kt">Vec</span> <span class="n">a</span> <span class="ow">=</span>
  <span class="p">{</span> <span class="n">x</span> <span class="kt">:</span> <span class="n">a</span>
  <span class="p">,</span> <span class="n">y</span> <span class="kt">:</span> <span class="n">a</span>
  <span class="p">}</span>
</code></pre></div><p>適当に<code>add</code>や<code>sub</code>、<code>mul</code>などのベクトル演算を定義しておく。</p>
<h2 id="テトリミノのデータ構造">テトリミノのデータ構造</h2>
<p>以下のように代数的データ型で定義する。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="kt">Mino</span> <span class="ow">=</span> <span class="kt">I</span> <span class="o">|</span> <span class="kt">O</span> <span class="o">|</span> <span class="kt">L</span> <span class="o">|</span> <span class="kt">J</span> <span class="o">|</span> <span class="kt">S</span> <span class="o">|</span> <span class="kt">Z</span> <span class="o">|</span> <span class="kt">T</span>
</code></pre></div><p><code>Mino</code>の実際の形を定義する必要があるが、考えられるデータ構造は以下の2つ。</p>
<ul>
<li>ブロックそのものの2次元データ</li>
<li>相対的位置(x, y)のリスト</li>
</ul>
<p>前者の場合もそこまで難しくはないと思うが、
後者が個人的にシンプルで良いなと思ったので後者を採用する。</p>
<p>後者の場合は、ブロック毎の回転数の最大値を持っていた方が良い。
例えば、Oテトリミノの場合は回転しても向きが変わらないため、回転数1である。
<a href="https://tetris.wiki/Super_Rotation_System">Super Rotation System</a>を実装する場合は、O以外のテトリミノの回転数は4にする。</p>
<p>また、それ以外にも色の情報があるとよいので、
以下のようなデータ構造を実装することになる。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="n">alias</span> <span class="kt">MinoInfo</span> <span class="ow">=</span>
  <span class="p">{</span> <span class="n">rotMax</span> <span class="kt">:</span> <span class="kt">Int</span> 
  <span class="p">,</span> <span class="n">positions</span> <span class="kt">:</span> <span class="kt">List</span> <span class="p">(</span><span class="kt">Vec</span> <span class="kt">Int</span><span class="p">)</span>
  <span class="p">,</span> <span class="n">color</span> <span class="kt">:</span> <span class="kt">Color</span>
  <span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">info</span> <span class="kt">:</span> <span class="kt">Mino</span> <span class="ow">-&gt;</span> <span class="kt">MinoInfo</span>
<span class="nf">info</span> <span class="n">mino</span> <span class="ow">=</span>
  <span class="kr">case</span> <span class="n">mino</span> <span class="kr">of</span>
    <span class="kt">I</span> <span class="ow">-&gt;</span>
      <span class="kt">MinoInfo</span> <span class="mi">4</span> <span class="p">[</span><span class="kt">Vec</span> <span class="o">-</span><span class="mi">2</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">Vec</span> <span class="o">-</span><span class="mi">1</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">Vec</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">Vec</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">]</span> <span class="kt">Lightblue</span>

    <span class="kt">O</span> <span class="ow">-&gt;</span> <span class="o">...</span>
    <span class="kt">L</span> <span class="ow">-&gt;</span> <span class="o">...</span>
</code></pre></div><h2 id="テトリミノ関連の実装">テトリミノ関連の実装</h2>
<h3 id="テトリミノの位置データ">テトリミノの位置データ</h3>
<p>落下中のテトリミノの種類、位置、回転数を持つデータ構造を作る。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="n">alias</span> <span class="kt">MinoState</span> <span class="ow">=</span>
  <span class="p">{</span> <span class="n">mino</span> <span class="kt">:</span> <span class="kt">Mino</span>
  <span class="p">,</span> <span class="n">pos</span> <span class="kt">:</span> <span class="kt">Vec</span> <span class="kt">Int</span>
  <span class="p">,</span> <span class="n">rot</span> <span class="kt">:</span> <span class="kt">Int</span>
  <span class="p">}</span>
</code></pre></div><h3 id="テトリミノの回転">テトリミノの回転</h3>
<p>テトリミノの各座標を回転させれば良い。
(x, y) の座標変換について考える。半時計周りに90度回転させることを考えると、座標変換後は (y, -x) となる。
これは複素数平面を考えるなり、回転行列を掛けるなりして導出できる。ただし、下向きがy軸正になるため、
よくある上向き座標系とは符号が異なることに注意。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">rotate90</span> <span class="kt">:</span> <span class="kt">Vec</span> <span class="n">number</span> <span class="ow">-&gt;</span> <span class="kt">Vec</span> <span class="n">number</span>
<span class="nf">rotate90</span> <span class="p">({</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="p">}</span> <span class="n">as</span> <span class="n">v</span><span class="p">)</span> <span class="ow">=</span>
  <span class="p">{</span> <span class="n">v</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span> <span class="ow">=</span> <span class="o">-</span><span class="n">x</span> <span class="p">}</span>
</code></pre></div><p>回転を複数回適用するために、<code>applyN</code>関数を定義する。例えば、<code>applyN 3 f</code>を評価すると<code>f &lt;&lt; f &lt;&lt; f</code>が得られる。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">applyN</span> <span class="kt">:</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">applyN</span> <span class="n">n</span> <span class="n">f</span> <span class="ow">=</span> <span class="kt">List</span><span class="o">.</span><span class="n">foldr</span> <span class="p">(</span><span class="o">&lt;&lt;</span><span class="p">)</span> <span class="n">identity</span> <span class="p">(</span><span class="kt">List</span><span class="o">.</span><span class="n">repeat</span> <span class="n">n</span> <span class="n">f</span><span class="p">)</span>
</code></pre></div><h3 id="テトリミノのボード上への反映">テトリミノのボード上への反映</h3>
<p>まず絶対座標を計算する関数を作る。<code>MinoState</code>の情報をもとに、回転と平行移動の変換を行うたけ。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">toAbsolute</span> <span class="kt">:</span> <span class="kt">MinoState</span> <span class="ow">-&gt;</span> <span class="kt">List</span> <span class="p">(</span><span class="kt">Vec</span> <span class="kt">Int</span><span class="p">)</span>
<span class="nf">toAbsolute</span> <span class="p">{</span> <span class="n">mino</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">rot</span> <span class="p">}</span> <span class="ow">=</span>
  <span class="kr">let</span>
    <span class="p">{</span> <span class="n">rotMax</span><span class="p">,</span> <span class="n">positions</span> <span class="p">}</span> <span class="ow">=</span> <span class="n">info</span> <span class="n">mino</span>
    <span class="n">rotMod</span> <span class="ow">=</span> <span class="n">modBy</span> <span class="n">rotMax</span> <span class="n">rot</span>
  <span class="kr">in</span>
    <span class="kt">List</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="n">add</span> <span class="n">pos</span> <span class="o">&lt;&lt;</span> <span class="n">applyN</span> <span class="n">rotMod</span> <span class="n">rotate90</span><span class="p">)</span> <span class="n">positions</span>
</code></pre></div><p>以下の<code>putBlock</code>を定義しておけば、ボードと落下中のテトリミノを統合できる。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">putBlock</span> <span class="kt">:</span> <span class="kt">List</span> <span class="p">(</span><span class="kt">Vec</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Cell</span> <span class="ow">-&gt;</span> <span class="kt">Board</span> <span class="ow">-&gt;</span> <span class="kt">Board</span>
<span class="nf">putBlock</span> <span class="n">positions</span> <span class="n">cell</span> <span class="n">board</span> <span class="ow">=</span>
  <span class="c1">-- 実装はBoardのデータ構造による</span>
</code></pre></div><h3 id="テトリミノの衝突判定">テトリミノの衝突判定</h3>
<p>厳密には衝突というより、壁や他のテトリミノに被っているかどうかの判定を行う。
テトリミノが被るケースとして，以下の3つが考えられる．</p>
<ul>
<li>左右移動: 右/左に移動させてみたら被った</li>
<li>固定: 下に移動させてみたら被った</li>
<li>回転: 回転させてみたら被った</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">overlapped</span> <span class="kt">:</span> <span class="kt">List</span> <span class="p">(</span><span class="kt">Vec</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Board</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">overlapped</span> <span class="n">ps</span> <span class="n">bord</span> <span class="ow">=</span>
  <span class="c1">-- 実装はBoardのデータ構造による</span>
</code></pre></div><h3 id="テトリミノの固定">テトリミノの固定</h3>
<p>1つ下のラインとの衝突判定を行い、判定が真なら固定する。さらに拡張して、次のようにする。</p>
<ul>
<li><code>lifeTime</code>というフィールドを用いることで、着地後少しの時間だけテトリミノを動かせるようにする</li>
<li>回転キーが押されたら<code>lifeTime</code>を初期値に戻す。すると、回転連打している間は固定されないようになる。</li>
</ul>
<h2 id="キー状態の管理">キー状態の管理</h2>
<p>長押ししているときはテトリミノが回転しないように実装する。そのためには、キーが長押しされているかどうかを判定する必要がある。</p>
<p>キーが押されたか、離されたかは<code>onKeyDown</code>、<code>onKeyUp</code>で判定できる。ところが「キーが長押しされているか否か」を判定するのは少し工夫がいる。</p>
<p>判定のために、キーの状態を管理するデータ型を定義する。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="kt">KeyState</span>
  <span class="ow">=</span> <span class="kt">KeyIdle</span>
  <span class="o">|</span> <span class="kt">KeyPressed</span>
  <span class="o">|</span> <span class="kt">KeyPressing</span>
</code></pre></div><p>これを用いて、キーの状態を変更する関数を定義する。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">updateKeyState</span> <span class="kt">:</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">KeyState</span> <span class="ow">-&gt;</span> <span class="kt">KeyState</span>
<span class="nf">updateKeyState</span> <span class="n">keyDowned</span> <span class="n">state</span> <span class="ow">=</span>
  <span class="kr">case</span> <span class="n">state</span> <span class="kr">of</span>
    <span class="kt">KeyIdle</span> <span class="ow">-&gt;</span>
      <span class="kr">if</span> <span class="n">keyDowned</span> <span class="kr">then</span>
        <span class="kt">KeyPressed</span>
      <span class="kr">else</span>
        <span class="kt">KeyIdle</span>

    <span class="kt">KeyPressed</span> <span class="ow">-&gt;</span>
      <span class="kr">if</span> <span class="n">keyDowned</span> <span class="kr">then</span>
        <span class="kt">KeyPressing</span>
      <span class="kr">else</span>
        <span class="kt">KeyIdle</span>

    <span class="kt">KeyPressing</span> <span class="ow">-&gt;</span>
      <span class="kr">if</span> <span class="n">keyDowned</span> <span class="kr">then</span>
        <span class="kt">KeyPressing</span>
      <span class="kr">else</span>
        <span class="kt">KeyIdle</span>
</code></pre></div><p>キーが押されたかどうかのフラグとキーの状態は別々に定義しておく必要がある。
なぜなら、ゲームの1ステップのタイミングと、<code>onKeyUp/onKeyDown</code>に関する<code>Msg</code>が送られてくるタイミングが別だからである。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="n">alias</span> <span class="kt">KeyPressFlag</span> <span class="ow">=</span>
  <span class="p">{</span> <span class="n">left</span> <span class="kt">:</span> <span class="kt">Bool</span>
  <span class="p">,</span> <span class="n">right</span> <span class="kt">:</span> <span class="kt">Bool</span>
  <span class="p">,</span> <span class="n">up</span> <span class="kt">:</span> <span class="kt">Bool</span>
  <span class="p">,</span> <span class="o">...</span>
  <span class="p">}</span>

<span class="kr">type</span> <span class="n">alias</span> <span class="kt">KeyStates</span> <span class="ow">=</span>
  <span class="p">{</span> <span class="n">left</span> <span class="kt">:</span> <span class="kt">KeyState</span>
  <span class="p">,</span> <span class="n">right</span> <span class="kt">:</span> <span class="kt">KeyState</span>
  <span class="p">,</span> <span class="n">up</span> <span class="kt">:</span> <span class="kt">KeyState</span>
  <span class="p">,</span> <span class="o">...</span>
  <span class="p">}</span>
</code></pre></div><p>前者は<code>onKeyDown</code>、<code>onKeyUp</code>のときに更新され、後者はタイマーイベントの時に更新されるように実装する。</p>
<h2 id="乱数の取得">乱数の取得</h2>
<p>テトリミノが固定されるたびに、新しいテトリミノが出現する。次の出現するテトリミノを決めるために、
<a href="https://package.elm-lang.org/packages/elm/random/latest/">elm/random</a>を利用する。</p>
<p><code>Cmd Msg</code>で取得せず、<code>Random.step</code>で実装。ただし、初期のシードは<code>Random.independentSeed</code>で取得する。</p>
<p><code>Random.generate</code>を使わないのは、今回のケースだと実行順序が分かりづらくなるからだ。
<code>Random.generate</code>を使うことで、ランダム値を<code>Msg</code>として受け取ることができる。
今回はテトリミノをランダムに発生させたいが、それが起こるのは以下の太字のとき。</p>
<ol>
<li>テトリミノが固定される。</li>
<li><strong>新しいテトリミノが生成される。</strong></li>
<li>そのテトリミノが画面上部におけるかチェックし、できなければゲームオーバー。</li>
</ol>
<p>もし<code>Random.generate</code>を使いたいなら、<code>Cmd Msg</code>としてTEAのランタイムに依頼することになる。
例えば擬似的に書くと以下のようになるだろうか。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">update</span> <span class="kt">:</span> <span class="kt">Msg</span> <span class="ow">-&gt;</span> <span class="kt">Model</span> <span class="ow">-&gt;</span> <span class="p">(</span> <span class="kt">Model</span><span class="p">,</span> <span class="kt">Cmd</span> <span class="kt">Msg</span> <span class="p">)</span>
<span class="nf">update</span> <span class="n">msg</span> <span class="n">model</span> <span class="ow">=</span>
  <span class="kr">case</span> <span class="n">msg</span> <span class="kr">of</span>
    <span class="o">...</span>

    <span class="kt">NextMino</span> <span class="ow">-&gt;</span>
      <span class="c1">-- 新しいテトリミノをセットする処理</span>


    <span class="kt">Tick</span> <span class="kr">_</span> <span class="ow">-&gt;</span>
      <span class="p">(</span> <span class="n">erapseTime</span> <span class="n">model</span>
          <span class="o">|&gt;</span> <span class="o">...</span>
          <span class="o">...</span>
          <span class="o">|&gt;</span> <span class="n">fixMino</span>
          <span class="o">|&gt;</span> <span class="n">checkGameOver</span>
      <span class="p">,</span> <span class="n">checkNewMino</span> <span class="n">model</span> <span class="c1">-- 新しいテトリミノが必要なら乱数生成を依頼する</span>
      <span class="p">)</span>
</code></pre></div><p>そうなると、コード上で2を書く場所が分断されて読みづらくなる。
それを避けるために、<code>Random.step</code>を使うことにした。すると、以下のように順番を意識して書ける。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">update</span> <span class="kt">:</span> <span class="kt">Msg</span> <span class="ow">-&gt;</span> <span class="kt">Model</span> <span class="ow">-&gt;</span> <span class="p">(</span> <span class="kt">Model</span><span class="p">,</span> <span class="kt">Cmd</span> <span class="kt">Msg</span> <span class="p">)</span>
<span class="nf">update</span> <span class="n">msg</span> <span class="n">model</span> <span class="ow">=</span>
  <span class="kr">case</span> <span class="n">msg</span> <span class="kr">of</span>
    <span class="o">...</span>

    <span class="kt">Tick</span> <span class="kr">_</span> <span class="ow">-&gt;</span>
      <span class="p">(</span><span class="n">model</span>
        <span class="o">|&gt;</span> <span class="o">...</span>
        <span class="o">...</span>
        <span class="o">|&gt;</span> <span class="n">fixMino</span>
        <span class="o">|&gt;</span> <span class="n">nextMino</span> <span class="c1">-- この関数の中で`Random.step`を使う</span>
        <span class="o">|&gt;</span> <span class="n">checkGameOver</span>
      <span class="p">,</span> <span class="kt">Cmd</span><span class="o">.</span><span class="n">none</span>
      <span class="p">)</span>
</code></pre></div><h2 id="super-rotation-system">Super Rotation System</h2>
<p>回転させてみて衝突が起こった場合は、テトリミノを上下左右に動かせないか試してみる。
動かし方はテトリミノの回転した状態によって異なる。しかもO、Iテトリミノとそれ以外で場合分けが生じる。
これらの情報は<a href="https://tetris.wiki/Super_Rotation_System#Wall_Kicks">Tetris WikiのWall Kicks</a>に載っている。</p>
<p>Wikiの&quot;J, L, S, T, Z Tetromino Wall Kick Data&quot;、&ldquo;I Tetromino Wall Kick Data&quot;に注目する。
回転前の状態と回転後の状態に依存していることが分かる。Wiki中の&quot;0, R, L, 2&quot;をそれぞれ次のように表現する。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="kt">Direction</span>
    <span class="ow">=</span> <span class="kt">Zero</span>
    <span class="o">|</span> <span class="kt">RotRight</span>
    <span class="o">|</span> <span class="kt">RotLight</span>
    <span class="o">|</span> <span class="kt">Two</span>
</code></pre></div><p><code>Direction</code>の取得を行う関数を作成しておく。O以外のテトリミノの<code>rotMax</code>は4であることに注意。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">direction</span> <span class="kt">:</span> <span class="kt">Mino</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Direction</span>
<span class="nf">direction</span> <span class="n">mino</span> <span class="n">rot</span> <span class="ow">=</span>
  <span class="kr">let</span>
    <span class="p">{</span> <span class="n">rotMax</span> <span class="p">}</span> <span class="ow">=</span> <span class="n">info</span> <span class="n">mino</span>
  <span class="kr">in</span>
  <span class="kr">case</span> <span class="n">modBy</span> <span class="n">rotMax</span> <span class="n">rot</span> <span class="kr">of</span>
    <span class="mi">0</span> <span class="ow">-&gt;</span>
      <span class="kt">Zero</span>

    <span class="mi">1</span> <span class="ow">-&gt;</span>
      <span class="kt">RotRight</span>

    <span class="mi">2</span> <span class="ow">-&gt;</span>
      <span class="kt">Two</span>

    <span class="kr">_</span> <span class="ow">-&gt;</span>
      <span class="kt">RotLeft</span>
</code></pre></div><p>Wikiのテーブルの行を返す関数を返す。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">kickList</span> <span class="kt">:</span> <span class="kt">Mino</span> <span class="ow">-&gt;</span> <span class="kt">Direction</span> <span class="ow">-&gt;</span> <span class="kt">Direction</span> <span class="ow">-&gt;</span> <span class="kt">List</span> <span class="p">(</span><span class="kt">Vec</span> <span class="kt">Int</span><span class="p">)</span>
<span class="nf">kickList</span> <span class="n">before</span> <span class="n">after</span> <span class="ow">=</span>
  <span class="kr">case</span> <span class="n">mino</span> <span class="kr">of</span>
    <span class="kt">O</span> <span class="ow">-&gt;</span>
      <span class="p">[</span><span class="kt">Vec</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>

    <span class="kt">I</span> <span class="ow">-&gt;</span>
      <span class="n">kickListI</span> <span class="n">before</span> <span class="n">after</span>

    <span class="kr">_</span> <span class="ow">-&gt;</span>
      <span class="n">kickListOthers</span> <span class="n">before</span> <span class="n">after</span>


<span class="nf">kickListI</span> <span class="kt">:</span> <span class="kt">Direction</span> <span class="ow">-&gt;</span> <span class="kt">Direction</span> <span class="ow">-&gt;</span> <span class="kt">List</span> <span class="p">(</span><span class="kt">Vec</span> <span class="kt">Int</span><span class="p">)</span>
<span class="nf">kickListI</span> <span class="n">before</span> <span class="n">after</span> <span class="ow">=</span>
  <span class="kr">case</span> <span class="p">(</span><span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="p">)</span> <span class="kr">of</span>
    <span class="o">...</span>


<span class="nf">kickListOthers</span> <span class="kt">:</span> <span class="kt">Direction</span> <span class="ow">-&gt;</span> <span class="kt">Direction</span> <span class="ow">-&gt;</span> <span class="kt">List</span> <span class="p">(</span><span class="kt">Vec</span> <span class="kt">Int</span><span class="p">)</span>
<span class="nf">kickListOthers</span> <span class="n">before</span> <span class="n">after</span> <span class="ow">=</span>
  <span class="kr">case</span> <span class="p">(</span><span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="p">)</span> <span class="kr">of</span>
    <span class="o">...</span>
</code></pre></div><p>Wikiのtableに書かれていることをコードに手書きするのは面倒。そこでHTMLパーサーをPythonで実装する。</p>
<p>まずWikiの<code>table</code>要素2つを、開発者モードやソースコードからコピーしてきて、適当なHTMLファイルに貼り付ける。ここでは<code>sample.html</code>としておく。</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">table</span> <span class="na">border</span><span class="o">=</span><span class="s">&#34;1&#34;</span> <span class="na">cellspacing</span><span class="o">=</span><span class="s">&#34;0&#34;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">caption</span><span class="p">&gt;&lt;</span><span class="nt">b</span><span class="p">&gt;</span>J, L, S, T, Z Tetromino Wall Kick Data<span class="p">&lt;/</span><span class="nt">b</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">caption</span><span class="p">&gt;</span>
...略
<span class="p">&lt;/</span><span class="nt">table</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="nt">table</span> <span class="na">border</span><span class="o">=</span><span class="s">&#34;1&#34;</span> <span class="na">cellspacing</span><span class="o">=</span><span class="s">&#34;0&#34;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">caption</span><span class="p">&gt;&lt;</span><span class="nt">b</span><span class="p">&gt;</span>I Tetromino Wall Kick Data<span class="p">&lt;/</span><span class="nt">b</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">caption</span><span class="p">&gt;</span>
...略
<span class="p">&lt;/</span><span class="nt">table</span><span class="p">&gt;</span>
</code></pre></div><p>ここではBeautifulSoup4を使ってパースする(余談: 実はBeautifulSoup4を使うのはこれが初めて)。
Wikiの表記では座標系がy軸上向きに取られているため、y座標の符号を反転させる処理を施しておく。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">import</span> <span class="nn">re</span>


<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Vec</span><span class="p">:</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;Vec </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="si">}</span><span class="s1">&#39;</span>


<span class="k">def</span> <span class="nf">parse_rot</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;RotZero&#39;</span>
    <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;R&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;RotRight&#39;</span>
    <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;L&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;RotLeft&#39;</span>
    <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;2&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;RotTwo&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;?&#39;</span>


<span class="k">def</span> <span class="nf">parse_cond</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="p">[</span><span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">parse_rot</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;-&gt;&#39;</span><span class="p">)]</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="n">before</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">after</span><span class="si">}</span><span class="s1">)&#39;</span>


<span class="k">def</span> <span class="nf">parse_tuple</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[() ]&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span> <span class="p">,</span> <span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">Vec</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">y</span><span class="p">)</span>


<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&#34;sample.html&#34;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">table</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">&#39;table&#39;</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;[&#34;</span> <span class="o">+</span> <span class="n">table</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;caption&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">get_text</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&#34;]&#34;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">&#39;tr&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">kick_condition</span> <span class="o">=</span> <span class="n">parse_cond</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;td&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">get_text</span><span class="p">())</span>
            <span class="n">kick_tests</span> <span class="o">=</span> <span class="p">[</span><span class="n">parse_tuple</span><span class="p">(</span><span class="n">tt</span><span class="o">.</span><span class="n">get_text</span><span class="p">())</span> <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">tr</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">&#39;tt&#39;</span><span class="p">)]</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">kick_condition</span><span class="si">}</span><span class="s1"> -&gt; </span><span class="se">\n</span><span class="s1">     </span><span class="si">{</span><span class="n">kick_tests</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
</code></pre></div><p>実行すると以下のコードが出力されるので、これをElmのコードにコピペすればよい。</p>
<pre class="cui">
[J, L, S, T, Z Tetromino Wall Kick Data]
(RotZero, RotRight) ->
     [Vec 0 0, Vec -1 0, Vec -1 -1, Vec 0 2, Vec -1 2]

(RotRight, RotZero) ->
     [Vec 0 0, Vec 1 0, Vec 1 1, Vec 0 -2, Vec 1 -2]

(RotRight, RotTwo) ->
     [Vec 0 0, Vec 1 0, Vec 1 1, Vec 0 -2, Vec 1 -2]

(RotTwo, RotRight) ->
     [Vec 0 0, Vec -1 0, Vec -1 -1, Vec 0 2, Vec -1 2]

(RotTwo, RotLeft) ->
     [Vec 0 0, Vec 1 0, Vec 1 -1, Vec 0 2, Vec 1 2]

(RotLeft, RotTwo) ->
     [Vec 0 0, Vec -1 0, Vec -1 1, Vec 0 -2, Vec -1 -2]

(RotLeft, RotZero) ->
     [Vec 0 0, Vec -1 0, Vec -1 1, Vec 0 -2, Vec -1 -2]

(RotZero, RotLeft) ->
     [Vec 0 0, Vec 1 0, Vec 1 -1, Vec 0 2, Vec 1 2]

[I Tetromino Wall Kick Data]
(RotZero, RotRight) ->
     [Vec 0 0, Vec -2 0, Vec 1 0, Vec -2 1, Vec 1 -2]

(RotRight, RotZero) ->
     [Vec 0 0, Vec 2 0, Vec -1 0, Vec 2 -1, Vec -1 2]

(RotRight, RotTwo) ->
     [Vec 0 0, Vec -1 0, Vec 2 0, Vec -1 -2, Vec 2 1]

(RotTwo, RotRight) ->
     [Vec 0 0, Vec 1 0, Vec -2 0, Vec 1 2, Vec -2 -1]

(RotTwo, RotLeft) ->
     [Vec 0 0, Vec 2 0, Vec -1 0, Vec 2 -1, Vec -1 2]

(RotLeft, RotTwo) ->
     [Vec 0 0, Vec -2 0, Vec 1 0, Vec -2 1, Vec 1 -2]

(RotLeft, RotZero) ->
     [Vec 0 0, Vec 1 0, Vec -2 0, Vec 1 2, Vec -2 -1]

(RotZero, RotLeft) ->
     [Vec 0 0, Vec -1 0, Vec 2 0, Vec -1 -2, Vec 2 1]
</pre>

<h2 id="実装していて気づいたこと">実装していて気づいたこと</h2>
<h3 id="asパターンマッチ">asパターンマッチ</h3>
<p>HaskellやPureScriptの<code>@</code>と同じ機能を、<code>as</code>として提供しているようだ。以下のように使う。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">mult</span> <span class="kt">:</span> <span class="n">number</span> <span class="ow">-&gt;</span> <span class="kt">Vec</span> <span class="n">number</span>
<span class="nf">mult</span> <span class="n">c</span> <span class="p">({</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="p">}</span> <span class="n">as</span> <span class="n">v</span><span class="p">)</span> <span class="ow">=</span>
  <span class="p">{</span> <span class="n">v</span>
    <span class="o">|</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">c</span> <span class="o">*</span> <span class="n">x</span>
    <span class="p">,</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">c</span> <span class="o">*</span> <span class="n">y</span>
  <span class="p">}</span>
</code></pre></div><p>この文法について、<a href="https://elm-lang.org/docs">Elmのドキュメント</a>では見つけられなかったが、<a href="https://faq.elm-community.org/#how-can-i-pattern-match-a-record-and-its-values-at-the-same-time">FAQの方で情報があった</a></p>
<h3 id="内部関数のミス">内部関数のミス</h3>
<p>例えば以下のようなコードを書いたとする。このコード自体は以前に書いたもので、今は存在しない。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">eraseFilledLine</span> <span class="n">field</span> <span class="ow">=</span>
    <span class="kr">let</span>
        <span class="n">go</span> <span class="n">i</span> <span class="n">fld</span> <span class="ow">=</span> <span class="cm">{- ...何か再帰的な処理... -}</span>
    <span class="kr">in</span>
    <span class="n">go</span> <span class="p">(</span><span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="n">field</span>
</code></pre></div><p>実は、<code>fld</code>を<code>field</code>に書き間違えたことによって、無限再帰が発生してしまったことがあった。</p>
<p>このようなミスくらい自分で気づくべきかもしれないが、
ここでは「ミスを起こさないコードを書くためにはどうすればよいのか」について考える。</p>
<p>このミスがコンパイルエラーを引き起こさなかったのは、<code>go</code>関数がより外のスコープである<code>field</code>に参照できたからである。
よって、初めからこのようなミスを起こす余地をなくすためには、以下のように内部関数をやめてしまうのが良い。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">eraseFilledLine</span> <span class="n">field</span> <span class="ow">=</span>
    <span class="n">eraseFilledLineGo</span> <span class="p">(</span><span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="n">field</span>


<span class="nf">eraseFilledLineGo</span> <span class="n">i</span> <span class="n">fld</span> <span class="ow">=</span> <span class="cm">{- ...何か再帰的な処理... -}</span>
</code></pre></div><p>しかし、今度は手軽さが失われてしまう。内部関数なら<code>go</code>みたいに雑な名前でも、グローバル空間を汚さないので問題ないのだが、
普通の関数として定義するとそうはしづらい。<code>go</code>みたいにに命名が雑すぎると、今度はなんのための関数なのか分かりづらくなる。
結局、それぞれ一長一短がある。</p>
<h3 id="ゲームの背後で行われる処理をモジュールに分割する">ゲームの背後で行われる処理をモジュールに分割する</h3>
<p><code>update</code>関数で行われている処理のうち、テトリスのゲームを進める部分はほんの一部である。
具体的には、タイマーイベントの<code>Msg</code>である<code>Tick</code>でしかゲームを進める処理を行っていない。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">update</span> <span class="kt">:</span> <span class="kt">Msg</span> <span class="ow">-&gt;</span> <span class="kt">Model</span> <span class="ow">-&gt;</span> <span class="p">(</span> <span class="kt">Model</span><span class="p">,</span> <span class="kt">Cmd</span> <span class="kt">Msg</span> <span class="p">)</span>
<span class="nf">update</span> <span class="n">msg</span> <span class="n">model</span> <span class="ow">=</span>
    <span class="kr">case</span> <span class="n">msg</span> <span class="kr">of</span>
        <span class="o">...</span>

        <span class="kt">Tick</span> <span class="kr">_</span> <span class="ow">-&gt;</span>
            <span class="p">(</span> <span class="n">elapseTime</span> <span class="n">model</span>
                <span class="o">|&gt;</span> <span class="o">...</span>
                <span class="o">|&gt;</span> <span class="o">...</span>
                <span class="o">|&gt;</span> <span class="o">...</span>
                <span class="o">...</span>
                <span class="o">|&gt;</span> <span class="n">checkGameOver</span>
            <span class="p">,</span> <span class="kt">Cmd</span><span class="o">.</span><span class="n">none</span>
            <span class="p">)</span>

        <span class="o">...</span>
</code></pre></div><p>コードの見通しをよくするためには、以下の2つに処理を分割すべきなのかなと思った。</p>
<ul>
<li>テトリスのゲームを進める処理</li>
<li>乱数のシードの処理・キー操作に関する処理</li>
</ul>
<p>後者を別モジュールに分割して、前者を<code>Main.elm</code>で書けるようにすると良いのではないのかと思った。</p>
<p>例えば以下のように関数が定義できると良い。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="kt">GameState</span> <span class="ow">=</span>
  <span class="p">{</span> <span class="n">time</span> <span class="kt">:</span> <span class="kt">Int</span>
  <span class="p">,</span> <span class="n">keys</span> <span class="kt">:</span> <span class="kt">KeyStates</span>
  <span class="p">,</span> <span class="n">seed</span> <span class="kt">:</span> <span class="kt">Seed</span>
  <span class="p">}</span>

<span class="nf">updateGame</span> <span class="kt">:</span> <span class="kt">GameState</span> <span class="ow">-&gt;</span> <span class="kt">Model</span> <span class="ow">-&gt;</span> <span class="kt">Model</span>
<span class="nf">updateGame</span> <span class="n">gameState</span> <span class="n">model</span> <span class="ow">=</span>
   <span class="n">elapseTime</span> <span class="n">model</span>
      <span class="o">|&gt;</span> <span class="o">...</span>
      <span class="o">|&gt;</span> <span class="o">...</span>
      <span class="o">|&gt;</span> <span class="o">...</span>
      <span class="o">...</span>
      <span class="o">|&gt;</span> <span class="n">checkGameOver</span>
</code></pre></div>
</article>


</body>
</html>
