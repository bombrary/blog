<!DOCTYPE html>
<html lang="ja-jp">
<title>ニューラルネットワーク ノート - 誤差逆伝播の計算 | Chanomic Blog</title>
<meta charset="utf-8">
<meta name="generator" content="Hugo 0.91.2" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="https://bombrary.github.io/blog/css/index.css">
<link rel="canonical" href="https://bombrary.github.io/blog/posts/nn-backprop/">
<link rel="alternate" type="application/rss+xml" href="" title="Chanomic Blog">
<link rel="stylesheet" href="https://bombrary.github.io/blog/katex/katex.min.css">
<script defer src="https://bombrary.github.io/blog/katex/katex.min.js"></script>
<script defer src="https://bombrary.github.io/blog/katex/contrib/auto-render.min.js" onload="renderMathInElement(document.body)"></script>
  <link rel="stylesheet" href="/blog/css/custom.css">

  <link rel="stylesheet" href="/blog/css/syntax.css">



<script async src="https://www.googletagmanager.com/gtag/js?id=UA-152083322-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-152083322-1');
</script>


<link rel="stylesheet" href="https://bombrary.github.io/blog/css/math.css">
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {delimiters: [
      {left: "$$", right: "$$", display: true},
      {left: "$", right: "$", display: false}]
    });

    
    var tex = document.getElementsByClassName("tex");
    Array.prototype.forEach.call(tex, function(el) {
        if (el.classList.contains('displaystyle')) {
            katex.render(el.getAttribute("data-expr"), el, { displayMode: true });
        } else {
          katex.render(el.getAttribute("data-expr"), el);
        }
    });
  });
</script>


<header>
  
    <a href="https://bombrary.github.io/blog/" class="title">Chanomic Blog</a>
  
  
</header>


<article>
  <header>
    <h1><a href="https://bombrary.github.io/blog/posts/nn-backprop/">ニューラルネットワーク ノート - 誤差逆伝播の計算</a></h1>
    <div class="meta">
      
      <div class="pub-date">
        <time datetime="2022-01-15T18:45:40&#43;09:00">January 15, 2022</time>
      </div>
      
      
      <div class="lastmod-date">
        <div class="lastmod-date__label">(last modified:</div>
        <time datetime="2022-01-15T18:45:40&#43;09:00">January 15, 2022</time>
        <div class="lastmod-date__label">)</div>
      </div>
      
    </div>
    
    <div class="tags-categories">
      <div class="tags">
        <p>tags: </p>
        <ul class="tags_list">
          <li class="tags_item"><a href="https://bombrary.github.io/blog//tags/%e8%aa%a4%e5%b7%ae%e9%80%86%e4%bc%9d%e6%92%ad%e6%b3%95/">誤差逆伝播法</a></li>
        </ul>
        
      </div>
      <div class="categories">
        <p>categories: </p>
        
        <ul class="categories_list">
           <li class="categories_item"><a href="https://bombrary.github.io/blog//categories/neural%20network/">Neural Network</a></li>
        </ul>
        
      </div>
    </div>
  </header>
  
    <aside>
      <h2>目次</h2>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#誤差逆伝播の計算-1">誤差逆伝播の計算 (1)</a>
      <ul>
        <li><a href="#問題設定">問題設定</a></li>
        <li><a href="#出力層">出力層</a></li>
        <li><a href="#中間層">中間層</a></li>
        <li><a href="#ここまでのまとめ">ここまでのまとめ</a></li>
        <li><a href="#ベクトル表記にする">ベクトル表記にする</a></li>
        <li><a href="#まとめ">まとめ</a></li>
      </ul>
    </li>
    <li><a href="#誤差逆伝播の計算-2">誤差逆伝播の計算 (2)</a>
      <ul>
        <li><a href="#計算の分離">計算の分離</a></li>
      </ul>
    </li>
    <li><a href="#ミニバッチ学習">ミニバッチ学習</a>
      <ul>
        <li><a href="#誤差逆伝播の計算-1-の場合">誤差逆伝播の計算 (1) の場合</a></li>
        <li><a href="#誤差逆伝播の計算-2-の場合">誤差逆伝播の計算 (2) の場合</a></li>
      </ul>
    </li>
    <li><a href="#まとめと感想">まとめと感想</a></li>
  </ul>
</nav>
    </aside>
    
  <p>誤差逆伝播法の数式の説明なんて世の中にたくさんあると思うが、理解のために自分でもまとめる。
特に添字などのミスがあると思うので、見つけ次第修正する。</p>
<h2 id="誤差逆伝播の計算-1">誤差逆伝播の計算 (1)</h2>
<h3 id="問題設定">問題設定</h3>
<p>入力を第 $0$ 層、出力を第 $L$ 層とする。ニューラルネットワークはよく次のようなグラフで描かれる。
円がノードを表す。ノードに入っていく矢印が入力、出ていく矢印が出力を表す。</p>
<figure><img src="img/nn-graph1.svg" width="600px"/>
</figure>

<p>第 $l$ 層 $j$ 番目のノードの出力を $y_j^l$ とおく (<strong>注意</strong>: この記事では $y_j^{l}$ の $l$ は添字を表すものとする。累乗ではない。これから現れる変数についても同様)。これはある関数 $f_l$ を用いて以下の式で表される。$f_l$ は活性化関数と呼ばれる。
<div class="tex displaystyle" data-expr="y_j^l = f_l\left( u_j^{l} \right)"></div>

ただし、$u_j^{l}$ は前の層の出力を用いて計算される線形和で、以下のように定義される。
<div class="tex displaystyle" data-expr="u_j^l = \sum_{i} w_{ij}^{l} y_{i}^{l-1}"></div>
</p>
<p>このような、線形和を取って $f$ を適用するという流れは次のようなグラフで描かれる。</p>
<figure><img src="img/nn-node-out.svg" width="600px"/>
</figure>

<p>この $\sum | f$ のノードがたくさん集まって第 $l$ 層を形成している。</p>
<p>損失関数 $E$ は、重み$w_{ij}^{l}$ についての関数である。これは出力値 $y_i^{L}$ と教師データ $\tilde{y}_i$ との違いを測る尺度であるから、$y_i^{L}$ の関数でもある。
例えば、以下の二乗誤差は損失関数の一種である。
<div class="tex displaystyle" data-expr="E = \frac{1}{2}\sum_{i}\left(y_i^{L} - \tilde{y}_i\right)^2"></div>
</p>
<p>定義中に $w_{ij}^{l}$ が含まれていないじゃないか、と思うかもしれないが、$y_i^{L}$ の定義中に $w_{ij}^{L}$ が含まれている。さらにその中の $y_i^{L-1}$ 中に $w_{ij}^{L-1}$ が含まれている。以下同様にして $w_{ij}^l$ は $E$ の中に含まれている。</p>
<p>いま、$E$ を最小化するような $w_{ij}^{l}$ を求めたい。これには確率的勾配法が利用できるが、そのために偏微分 $\displaystyle \frac{\partial E}{\partial w_{ij}^{l}}$ を計算する必要がある。以降、これをどう計算するかという話を展開していく。</p>
<h3 id="出力層">出力層</h3>
<p>$l = L$ のときを考える。まず $E$ は $y_1^{L}, y_2^{L}, \ldots, $ についての関数だから、連鎖律より、</p>
<div class="tex displaystyle" data-expr="\begin{align}
  \frac{\partial E}{\partial w_{ij}^{L}}
  &amp;= \sum_{j&#39;} \frac{\partial E}{\partial y_{j&#39;}^{L}}\frac{\partial y_{j&#39;}^{L}}{\partial w_{ij}^L}
\end{align}"></div>

<p>と変形できる。ところが、$y_{j'}^{L} = f_L(u_{j'}^{L})$ は $u_{j'}^{L}$ についての関数より、再び連鎖律から、</p>
<div class="tex displaystyle" data-expr="\begin{align*}
  \frac{\partial y_{j&#39;}^{L}}{\partial w_{ij}^L}
  &amp;= \frac{\partial y_{j&#39;}^{L}}{\partial u_{j&#39;}^{L}} \frac{\partial u_{j&#39;}^{L}}{\partial w_{ij}^L}\\
  &amp;= f_L&#39;(u_{j&#39;}^{L}) \frac{\partial}{\partial w_{ij}^L} \sum_{i&#39;} w_{i&#39;j&#39;} y_{i&#39;}^{L-1}\\
  &amp;= f_L&#39;(u_{j&#39;}^{L}) y_{i}^{L-1} \delta_{j,j&#39;}\\
\end{align*}"></div>

<p>と書ける。ここで、$f_L'$ は $f_L$ の導関数を表し、$\delta_{j,j'}$ はクロネッカーのデルタを表す。
結局、式 $(1)$ の$\sum_{j'}$ の部分が消えて、</p>
<div class="tex displaystyle" data-expr="\begin{align*}
  \frac{\partial E}{\partial w_{ij}^{L}}
  &amp;= \sum_{j&#39;} \frac{\partial E}{\partial y_{j&#39;}^{L}} f_L&#39;(u_{j&#39;}^{L}) y_{i}^{L-1} \delta_{j,j&#39;}\\
  &amp;= \frac{\partial E}{\partial y_{j}^{L}} f_L&#39;(u_{j}^{L}) y_{i}^{L-1}
\end{align*}"></div>

<p>が得られる。このように $j' = j$ の項しか残らないのは、$w_{ij}^{L}$ が $E(y_1^L, y_2^L, \ldots )$ の引数のうち $y_j^{L}$ にしか関わってこないからなのだが、一応このことを丁寧に計算で示した。</p>
<p>今後の計算のために、以下の量を定義する。</p>
<div class="tex displaystyle" data-expr="  \delta_{j}^{l} := \frac{\partial E}{\partial u_{j}^{l}} = \frac{\partial E}{\partial y_{j}^{l}} f_L&#39;(u_{j}^{l})"></div>

<p>これを用いると、</p>
<div class="tex displaystyle" data-expr="  \frac{\partial E}{\partial w_{ij}^{L}} = \delta_{j}^{L} y_{i}^{L-1}"></div>

<p>と表せる。</p>
<h3 id="中間層">中間層</h3>
<p>$l \neq L$ のときを考える。$E$ は $y_1^{L}, y_2^{L}, \ldots $ の関数であるが、その各々 $y_j^{L} = f_L\left( \sum_{i} w_{ij}^{L} y_i^{L-1} \right)$ は $y_1^{L-1}, y_2^{L-1}, \ldots $ の関数である。
従って、$E$ は $y_1^{L-1}, y_2^{L-1}, \ldots $ の関数でもある。以下同様にして、$E$ は $y_1^{l}, y_2^{l}, \ldots $ の関数であることが分かる。よって、連鎖率より、</p>
<div class="tex displaystyle" data-expr="\begin{align*}
  \frac{\partial E}{\partial w_{ij}^{l}}
  &amp;= \sum_{j&#39;} \frac{\partial E}{\partial y_{j&#39;}^{l}}\frac{\partial y_{j&#39;}^{l}}{\partial w_{ij}^l}
\end{align*}"></div>

<p>と書ける。出力層のときとまったく同じ議論により、これは、</p>
<div class="tex displaystyle" data-expr="\begin{align*}
  \frac{\partial E}{\partial w_{ij}^{l}}
  &amp;= \frac{\partial E}{\partial y_{j}^{l}}f_{l}&#39;(u_{j}^{l})y_i^{l-1}\\
  &amp;= \delta_{j}^{l} y_i^{l-1}
\end{align*}"></div>

<p>となる。ここで、$\delta_{j}^{l}$ は</p>
<div class="tex displaystyle" data-expr="\delta_{j}^{l} = \displaystyle \frac{\partial E}{\partial y_{j}^{l}} f_{l}&#39;(u_{j}^{l})"></div>

<p>であるから、これを計算するためには$\displaystyle \frac{\partial E}{\partial y_{j}^{l}}$ を計算する必要がある。 $E$ は $y_1^{l+1}, y_2^{l+2}, \ldots $ の関数でもあるから、連鎖律より、</p>
<div class="tex displaystyle" data-expr="\begin{align*}
\frac{\partial E}{\partial y_{j}^{l}}
&amp;= \sum_{k} \frac{\partial E}{\partial y_{k}^{l&#43;1}} \frac{\partial y_{k}^{l&#43;1}}{\partial y_{j}^{l}}
\end{align*}"></div>

<p>が成り立つ。さらに $y_{k}^{l+1}$ は $u_{k}^{l+1}$ の関数であるから、連鎖律より、</p>
<div class="tex displaystyle" data-expr="\begin{equation}
\frac{\partial E}{\partial y_{j}^{l}}
= \sum_{k} \frac{\partial E}{\partial y_{k}^{l&#43;1}} \frac{\partial y_{k}^{l&#43;1}}{\partial u_{k}^{l&#43;1}} \frac{\partial u_{k}^{l&#43;1}}{\partial y_{j}^{l}}
\end{equation}"></div>

<p>となる。ここで、</p>
<div class="tex displaystyle" data-expr="\begin{align*}
\frac{\partial y_{k}^{l&#43;1}}{\partial u_{k}^{l&#43;1}} &amp;= f_{l&#43;1}&#39;\left( u_{k}^{l&#43;1} \right)\\
\frac{\partial u_{k}^{l&#43;1}}{\partial y_{j}^{l}} &amp;= \frac{\partial}{\partial y_{j}^{l}} \sum_{j&#39;} w_{j&#39;k}^{l&#43;1} y_{j&#39;}^{l}\\
  &amp;= w_{jk}^{l&#43;1}
\end{align*}"></div>

<p>であるから、式$(2)$は、</p>
<div class="tex displaystyle" data-expr="\begin{align*}
\frac{\partial E}{\partial y_{j}^{l}}
&amp;= \sum_{k} \frac{\partial E}{\partial y_{k}^{l&#43;1}} f_{l&#43;1}&#39;\left( u_{k}^{l&#43;1} \right) w_{jk}^{l&#43;1}\\
&amp;= \sum_{k} \delta_k^{l&#43;1}w_{jk}^{l&#43;1}
\end{align*}"></div>

<p>となる。以上より求めたかった $\delta_j^{l}$ は、</p>
<div class="tex displaystyle" data-expr="\begin{align*}
\delta_{j}^{l}
&amp;= \frac{\partial E}{\partial y_{j}^{l}}f_{l}&#39;(u_{j}^{l})\\
&amp;= \sum_{k} \delta_{k}^{l&#43;1} w_{jk}^{l&#43;1} f_{l}&#39;(u_{j}^{l})
\end{align*}"></div>

<p>と書ける。すなわち、$\delta_{j}^{l}$ を計算するためには $\delta_{k}^{l+1}$ を計算しておけば良い。</p>
<h3 id="ここまでのまとめ">ここまでのまとめ</h3>
<p>さて、いままでの計算をまとめると、$1 \le l \le L$ について、</p>
<div class="tex displaystyle" data-expr="\begin{align*}
  \frac{\partial E}{\partial w_{ij}^{l}}
  &amp;= \delta_{j}^{l} y_{i}^{l-1}
\end{align*}"></div>

<p>と表せる。ただし $\delta_{j}^{l}$ は、</p>
<div class="tex displaystyle" data-expr="  \delta_{j}^{l} =
  \begin{cases}
    \displaystyle
    \frac{\partial E}{\partial y_{j}^{L}} f_L&#39;(u_{j}^{L}) &amp; (l = L) \\
    \displaystyle
    \sum_{k} \delta_{k}^{l&#43;1} w_{jk}^{l&#43;1} f_{l}&#39;(u_{j}^{l}) &amp; (l \neq L)
  \end{cases}"></div>

<p>で表される。</p>
<h3 id="ベクトル表記にする">ベクトル表記にする</h3>
<p>第 $l$ 層についての $\delta_j^{l}$ を並べたベクトルを $\bm{\delta^{l}}$ で表す。同様に、ベクトル $\bm{y}^{l}, \bm{u}^{l}$ を定義する。</p>
<p>前提として、$\bm{u}^{l}$、$\bm{y}^{l}$ は次のように計算できる。これはいわゆる順伝播である。</p>
<div class="tex displaystyle" data-expr="\begin{align*}
\bm{u}^{l} &amp;= W^{l}\bm{y}^{l-1}\\
\bm{y}^{l} &amp;= f(\bm{u}^{l})
\end{align*}"></div>

<p>ただし、関数 $f$ とベクトル $\bm{x}$ に対し、 $f(\bm{x})$ は $\bm{x}$ の各成分に $f$ を適用したベクトルを表す。</p>
<p>最初に、$\bm{\delta}^{l}$ の計算式を導く。$l = L$ のとき、</p>
<div class="tex displaystyle" data-expr="\begin{align*}
\bm{\delta}^{L}
&amp;= \begin{pmatrix}
  \delta_1^{L} &amp; \delta_2^{L} &amp; \cdots &amp;
\end{pmatrix}\\
&amp;= \begin{pmatrix}
  \frac{\partial E}{\partial y_{1}^{L}} f_L&#39;(u_{1}^{L}) &amp;
  \frac{\partial E}{\partial y_{2}^{L}} f_L&#39;(u_{2}^{L}) &amp;
  \cdots &amp;
\end{pmatrix}\\
&amp;= \frac{\partial E}{\partial \bm{y}^{L}} \ast f_L&#39;(\bm{u}^{L})
\end{align*}"></div>

<p>とすればよい。
ただし、任意のベクトル$\bm{x}, \bm{y}$ について、$\bm{x} \ast \bm{y}$ は成分ごとの積をとったベクトルを表す。</p>
<p>$l \neq L$ のとき、$W^{l+1} = (w_{ij}^{l+1})_{ij}$ を $P \times Q$ 行列とする(<strong>注意</strong>: この記事では $W^{l}$ の $l$ は累乗ではなく添字を表すものとする)。
このとき、</p>
<div class="tex displaystyle" data-expr="\begin{align*}
\bm{\delta}^{l}
&amp;= \begin{pmatrix}
  \sum_{k}^{Q} \delta_{k}^{l&#43;1} w_{1k}^{l&#43;1} f_{l}&#39;(u_{1}^{l})\\
  \sum_{k}^{Q} \delta_{k}^{l&#43;1} w_{2k}^{l&#43;1} f_{l}&#39;(u_{2}^{l})\\
  \vdots\\
  \sum_{k}^{Q} \delta_{k}^{l&#43;1} w_{Pk}^{l&#43;1} f_{l}&#39;(u_{P}^{l})
\end{pmatrix}\\
&amp;= \begin{pmatrix}
  w_{11}^{l&#43;1} &amp; \cdots &amp; w_{1Q}^{l&#43;1}\\
  w_{21}^{l&#43;1} &amp; \cdots &amp; w_{2Q}^{l&#43;1}\\
  \vdots &amp; \ddots &amp; \vdots\\
  w_{P1}^{l&#43;1} &amp; \cdots &amp; w_{PQ}^{l&#43;1}
\end{pmatrix}
\begin{pmatrix}
  \delta_1^{l&#43;1} f_{l}&#39;(u_{1}^{l})\\
  \delta_2^{l&#43;1} f_{l}&#39;(u_{2}^{l})\\
  \vdots\\
  \delta_P^{l&#43;1} f_{l}&#39;(u_{P}^{l})
\end{pmatrix}\\
&amp;= W^{l&#43;1} \bm{\delta}^{l&#43;1} \ast f_{l}&#39;(\bm{u}^{l})
\end{align*}"></div>

<p>$\frac{\partial E}{\partial w_{ij}^{l}}$ については、</p>
<div class="tex displaystyle" data-expr="  \frac{\partial E}{\partial w_{ij}^{l}} = \bm{y}^{l-1} \left(\bm{\delta}^{l}\right)^{\top}"></div>

<p>と表せる。</p>
<h3 id="まとめ">まとめ</h3>
<p>前提として、以下の順伝播の式で $\bm{y}^{l}$、$\bm{u}^{l}$ が計算できているものとする。</p>
<div class="tex displaystyle" data-expr="\begin{align*}
\bm{u}^{l} &amp;= W^{l}\bm{y}^{l-1}\\
\bm{y}^{l} &amp;= f(\bm{u}^{l})
\end{align*}"></div>

<p>誤差逆伝播の式は次のように書ける。</p>
<div class="tex displaystyle" data-expr="  \frac{\partial E}{\partial W^{l}} = \bm{y}^{l-1} \left(\bm{\delta}^{l}\right)^{\top}"></div>

<div class="tex displaystyle" data-expr="\bm{\delta}^{l}
= \begin{cases}
\frac{\partial E}{\partial \bm{y}^{L}} \ast f_L&#39;(\bm{u}^{L}) &amp; (l = L)\\
W^{l&#43;1} \bm{\delta}^{l&#43;1} \ast f_{l}&#39;(\bm{u}^{l}) &amp; (l \neq L)
\end{cases}"></div>

<h2 id="誤差逆伝播の計算-2">誤差逆伝播の計算 (2)</h2>
<p>前節では「$\delta_j^{l+1}$ を使って $\delta_j^{l}$ を求める」という流れを導出したが、
式変形を睨むと、「$\frac{\partial E}{\partial y_j^{l+1}}$ を使って $\frac{\partial E}{\partial y_j^{l}}$ を求める」という流れでも良いことが分かる。</p>
<p>それを確かめるために、$\delta_j^{l+1}$ という表記をやめ、式を見直してみる。</p>
<p>まず、$1 \le l \le L$ について、前節の議論により、</p>
<div class="tex displaystyle" data-expr="\begin{equation}
  \frac{\partial E}{\partial w_{ij}^{l}}
  = \frac{\partial E}{\partial y_{j}^{l}} f_l&#39;(u_{j}^{l}) y_{i}^{l-1}
\end{equation}"></div>

<p>が成り立つ。$\frac{\partial E}{\partial y_j^{l}}$ をどう求めるかを考える。</p>
<p>$l = L$ の場合は、単に損失関数 $E$ の定義に従って計算すれば良い (どんな損失関数を選ぶかで形が違ってくる)。$l \neq L$ の場合、前節の中間層の計算を追ってみると、</p>
<div class="tex displaystyle" data-expr="\begin{equation}
\frac{\partial E}{\partial y_{j}^{l}}
= \sum_{k} \frac{\partial E}{\partial y_{k}^{l&#43;1}} f_{l&#43;1}&#39;\left( u_{k}^{l&#43;1} \right) w_{jk}^{l&#43;1}\\
\end{equation}"></div>

<p>と計算できる。すなわち、$y_k^{l+1}$ による偏微分を使って第 $y_{k}^{l}$ による偏微分が計算できることが分かる。式 $(4)$ には第 $l+1$ 層に関連する量しか含まれていないから、この計算は $l+1$ 層にて事前に行っておけばよい。もちろん、第 $l$ 層の立場からすれば、第 $l-1$ 層についての以下の事前計算を行うことになる。</p>
<div class="tex displaystyle" data-expr="\begin{equation}
\frac{\partial E}{\partial y_{j}^{l-1}}
= \sum_{k} \frac{\partial E}{\partial y_{k}^{l}} f_{l}&#39;\left( u_{k}^{l} \right) w_{jk}^{l}\\
\end{equation}"></div>

<p>まとめると、第 $l$ 層で行う処理は次の2つである。</p>
<ol>
<li>式 $(3)$に従って $\frac{\partial E}{\partial w_{ij}^{l}}$ を計算する。</li>
<li>1つ前の層の計算のために、式 $(5)$ を使って  $E$ の $y_{i}^{l-1}$ による偏微分を計算しておく。</li>
</ol>
<p>最初からこちらの手法で解説している文献もある。</p>
<h3 id="計算の分離">計算の分離</h3>
<p>重み付き線形和を求めるだけの層、活性化関数を求めるだけの層に分ける。</p>
<figure><img src="img/nn-graph2.svg" width="600px"/>
</figure>

<p>前者は全結合層と呼ばれている。Affine Layer 、Dense Layer とも言われる。後者は活性化関数に応じて層の名前が付く。例えばシグモイド関数なら Sigmoid Layer と呼ばれ、ReLU関数なら ReLU Layer と呼ばれる。</p>
<p>kerasやChainer、PyToachなどのニューラルネットワークのライブラリでは、このように層を分けている。その理由はおそらく使いやすさ・分かり易さの観点からだと思われる。
後々計算すると分かるが、分けることによって式が綺麗にまとまる。また活性化関数の層を分けておけば、全結合層以外の層とも組み合わせられる。</p>
<p>以下では、それぞれの層について $\frac{\partial E}{\partial w_{ij}^{l}},\ \frac{\partial E}{\partial y_{j}^{l-1}}$ の計算方法を記す。</p>
<h4 id="活性化関数を求める層">活性化関数を求める層</h4>
<p>$y_i^{l-1}$ を入力、$y_i^{l} = f(y_i^{l-1}) \ (i = 1, 2, \ldots)$ を出力とする層を考える。</p>
<p>まず、$\frac{\partial E}{\partial w_{ij}^{l}}$ を計算する必要はない。なぜなら、重み $w_{ij}^{l}$ が存在しないからである。よって、$y_{i}^{l-1}$ による微分のみ計算する。</p>
<p>連鎖律より、</p>
<div class="tex displaystyle" data-expr="\begin{equation*}
\frac{\partial E}{\partial y_{j}^{l-1}}
= \sum_{k} \frac{\partial E}{\partial y_{k}^{l}} \frac{\partial y_{k}^{l}}{\partial y_{j}^{l-1}}
\end{equation*}"></div>

<p>$y_i^{l}$ は $y_i^{l-1}$ のみの関数であることに注意して、</p>
<div class="tex displaystyle" data-expr="\begin{align*}
\frac{\partial E}{\partial y_{j}^{l-1}}
&amp;= \sum_{k} \frac{\partial E}{\partial y_{k}^{l}} f_l&#39;(y_j^{l-1}) \delta_{k, j}\\
&amp;= \frac{\partial E}{\partial y_{j}^{l}} f_l&#39;(y_j^{l-1})
\end{align*}"></div>

<p>と計算される。</p>
<p>ベクトルで表記すると、</p>
<div class="tex displaystyle" data-expr="\frac{\partial E}{\partial \bm{y}^{l-1}}
= \frac{\partial E}{\partial \bm{y}^{l}} \ast f_l&#39;(\bm{y}^{l-1})"></div>

<h4 id="全結合層">全結合層</h4>
<p>$y_i^{l-1}$ を入力、$y_i^{l} = \sum_{j}w_{ij} y_j^{l-1} \ (i = 1, 2, \ldots)$ を出力とする層を考える。</p>
<p>面倒なので計算を端折る。要するにこの線形和は、以前の議論で導いた2つの式 $(3)$、$(5)$</p>
<div class="tex displaystyle" data-expr="\begin{align*}
\frac{\partial E}{\partial w_{ij}^{l}}
&amp;= \frac{\partial E}{\partial y_{j}^{l}} f_l&#39;(u_{j}^{l}) y_{i}^{l-1}\\
\frac{\partial E}{\partial y_{j}^{l-1}}
&amp;= \sum_{k} \frac{\partial E}{\partial y_{k}^{l}} f_{l}&#39;\left( u_{k}^{l} \right) w_{jk}^{l}
\end{align*}"></div>

<p>において、活性化関数が恒等関数 $f(x) = x$ となるものである。よって、</p>
<div class="tex displaystyle" data-expr="\begin{align*}
\frac{\partial E}{\partial w_{ij}^{l}}
&amp;= \frac{\partial E}{\partial y_{j}^{l}} y_{i}^{l-1}\\
\frac{\partial E}{\partial y_{j}^{l-1}}
&amp;= \sum_{k} \frac{\partial E}{\partial y_{k}^{l}} w_{jk}^{l}
\end{align*}"></div>

<p>が得られる。</p>
<p>ベクトルで表記すると、</p>
<div class="tex displaystyle" data-expr="\begin{align*}
\frac{\partial E}{\partial W^{l}}
&amp;=  \bm{y}^{l-1}\left(\frac{\partial E}{\partial \bm{y}^{l}}\right)^{\top}\\
\frac{\partial E}{\partial \bm{y}^{l-1}}
&amp;= W^{l} \frac{\partial E}{\partial \bm{y}^{l}}
\end{align*}"></div>

<h2 id="ミニバッチ学習">ミニバッチ学習</h2>
<p>いままで確率的勾配法で話を進めてきたが、ミニバッチ勾配法の場合はどのようになるのだろうか。</p>
<p>計算のためには、今までの表記を少し改め、損失関数をミニバッチ用に変える必要がある。
今まで出力値を $y_i^{l}$ と表していたが、これを $n$ 番目の入力データに対する出力値 $y_{ni}^{l}$ に書き直す。</p>
<p>まず、ミニバッチとする訓練データの個数を $N$ とする。その入力を $\bm{y}_1^{0}, \bm{y}_2^{0}, \ldots, \bm{y}_N^{0}$ とする。
各ノードに対する出力値は $\bm{y}_1^{l}, \bm{y}_2^{l}, \ldots, \bm{y}_N^{l}$ と書ける。
ここで、第 $l$ 層のノードの個数を $D_l$ とし、<span class="tex" data-expr="\bm{y}_n^{l} = \left(y_{n1}^{l}, y_{n2}^{l}, \ldots, y_{nD_l}^{l} \right)^{\top}"></span>
 とした。
また、
<div class="tex displaystyle" data-expr="Y^{l} = \begin{pmatrix}
  \bm{y}_1^{l} &amp; \bm{y}_2^{l} &amp; \cdots &amp; \bm{y}_N^{l}
\end{pmatrix}"></div>

と書くことにする。</p>
<p>$n$ 番目の入力データに対する損失関数を$E_n$とする。例えば二乗誤差なら、
<div class="tex displaystyle" data-expr="E_n = \frac{1}{2}\sum_{i}\left(y_{ni}^{L} - \tilde{y}_{ni}\right)^2"></div>

となる。</p>
<p>$N$ 個の訓練データに対する損失関数を、各々のデータの損失関数の平均で表す。</p>
<div class="tex displaystyle" data-expr="E = \frac{1}{N} \sum_{n=1}^{N} E_n"></div>

<p>さて $w_{ij}^{l}$ についての偏微分をどう計算するかだが、これは偏微分の線形性から、</p>
<div class="tex displaystyle" data-expr="\begin{equation}
\frac{\partial E}{\partial w_{ij}^{l}} = \frac{1}{N} \sum_{n=1}^{N} \frac{\partial E_n}{\partial w_{ij}^{l}}
\end{equation}"></div>

<p>が成り立つことに注目すれば良い。$E_n$ の計算は今までの議論と何ら変わりない。
あとはそれぞれの層について、順伝播・逆伝播がどう表現できるのかについて考える。</p>
<h3 id="誤差逆伝播の計算-1-の場合">誤差逆伝播の計算 (1) の場合</h3>
<p>$n$ 番目のデータに対する第 $l$ 層の線形和を $\bm{u}_n^{l}$ とおく。$Y^{l}$ の定義とほぼ同様にして、
<div class="tex displaystyle" data-expr="U^{l} = \begin{pmatrix}
\bm{u}_1^{l} &amp; \bm{u}_2^{l} &amp; \cdots &amp; \bm{u}_N^{l}
\end{pmatrix}"></div>

を定義する。同様に、
<div class="tex displaystyle" data-expr="\Delta^{l} = \begin{pmatrix}
\bm{\delta}_1^{l} &amp; \bm{\delta}_2^{l} &amp; \cdots &amp; \bm{\delta}_N^{l}
\end{pmatrix}"></div>

を定義する。</p>
<h4 id="順伝播">順伝播</h4>
<div class="tex displaystyle" data-expr="\begin{align*}
U^{l}
&amp;= \begin{pmatrix}
\bm{u}_1^{l} &amp; \bm{u}_2^{l} &amp; \cdots &amp; \bm{u}_N^{l}
\end{pmatrix}\\
&amp;= \begin{pmatrix}
W^{l}\bm{y}_1^{l-1} &amp; W^{l}\bm{y}_2^{l-1} &amp; \cdots &amp; W^{l}\bm{y}_N^{l-1}
\end{pmatrix}\\
&amp;= W^{l}U^{l}
\end{align*}"></div>

<div class="tex displaystyle" data-expr="\begin{align*}
Y^{l}
&amp;= \begin{pmatrix}
f(\bm{u}_1^{l}) &amp; f(\bm{u}_2^{l}) &amp; \cdots &amp; f(\bm{u}_N^{l})
\end{pmatrix}\\
&amp;= f(U^{l})
\end{align*}"></div>

<p>ただし、関数 $f$ と行列 $A$ に対し、 $f(A)$ は $A$ の各成分に $f$ を適用した行列を表す。</p>
<h4 id="逆伝播">逆伝播</h4>
<p>式 $(6)$ が $W^{l} = (w_{ij}^{l})_{ij}$ の各成分について成り立つから、</p>
<div class="tex displaystyle" data-expr="\frac{\partial E}{\partial W^{l}} = \frac{1}{N} \sum_{n=1}^{N} \frac{\partial E_n}{\partial W^{l}}"></div>

<p>と変形できる。これより、</p>
<div class="tex displaystyle" data-expr="\begin{align*}
\frac{\partial E}{\partial W^{l}}
&amp;= \frac{1}{N} \sum_{n=1}^{N} \frac{\partial E_n}{\partial W^{l}}\\
&amp;= \frac{1}{N} \sum_{n=1}^{N} \bm{y}_n^{l-1} \left(\bm{\delta}_n^{l}\right)^{\top}\\
&amp;= \frac{1}{N} 
\begin{pmatrix}
  \bm{y}_1^{l-1} &amp; \bm{y}_2^{l-1} &amp; \cdots \bm{y}_N^{l-1}
\end{pmatrix}
\begin{pmatrix}
  \left(\bm{\delta}_1^{l-1}\right)^{\top} \\
  \left(\bm{\delta}_2^{l-1}\right)^{\top} \\
  \vdots\\
  \left(\bm{\delta}_N^{l-1}\right)^{\top} \\
\end{pmatrix}\\
&amp;= \frac{1}{N} Y^{l-1} \left(\Delta^{l}\right)^{\top}\\
\end{align*}"></div>

<p>$\Delta^{l}$ の計算については、$l = L$ のとき、</p>
<div class="tex displaystyle" data-expr="\begin{align*}
\Delta^{L}
&amp;= \begin{pmatrix}
\bm{\delta}_1^{L} &amp; \bm{\delta}_2^{L} &amp; \cdots &amp; \bm{\delta}_N^{L}
\end{pmatrix}\\
&amp;= \begin{pmatrix}
\frac{\partial E}{\partial \bm{y}_1^{L}} \ast f_L&#39;(\bm{u}_1^{L}) &amp;
\frac{\partial E}{\partial \bm{y}_2^{L}} \ast f_L&#39;(\bm{u}_2^{L}) &amp;
\cdots &amp;
\frac{\partial E}{\partial \bm{y}_N^{L}} \ast f_L&#39;(\bm{u}_N^{L}) &amp;
\end{pmatrix}\\
&amp;= \frac{\partial E}{\partial Y^{L}} \ast f_L&#39;(U^{L})
\end{align*}"></div>

<p>ただし、任意の行列$A, B$ について、$A \ast B$ は成分ごとの積をとった行列を表す。</p>
<p>$l \neq L$ のとき、</p>
<div class="tex displaystyle" data-expr="\begin{align*}
\Delta^{l}
&amp;= \begin{pmatrix}
\bm{\delta}_1^{l} &amp; \bm{\delta}_2^{l} &amp; \cdots &amp; \bm{\delta}_N^{l}
\end{pmatrix}\\
&amp;= \begin{pmatrix}
W^{l&#43;1}\bm{\delta}_1^{l&#43;1} \ast f_l&#39;(\bm{u}_1^{l}) &amp;
W^{l&#43;1}\bm{\delta}_2^{l&#43;1} \ast f_l&#39;(\bm{u}_2^{l}) &amp;
\cdots &amp;
W^{l&#43;1}\bm{\delta}_N^{l&#43;1} \ast f_l&#39;(\bm{u}_N^{l})
\end{pmatrix}\\
&amp;= W^{l&#43;1} \Delta^{l&#43;1} \ast f_L&#39;(U^{l})
\end{align*}"></div>

<p>と計算できる。このように、ベクトルだった部分がそのまま行列になったかのような形となる。実際、$N = 1$ としたらベクトルの表現に戻ることが分かるだろう。</p>
<h3 id="誤差逆伝播の計算-2-の場合">誤差逆伝播の計算 (2) の場合</h3>
<h4 id="活性化関数の層">活性化関数の層</h4>
<p>順伝播については、
<div class="tex displaystyle" data-expr="\begin{align*}
Y^{l&#43;1}
&amp;= \begin{pmatrix} \bm{y}_1^{l&#43;1} &amp; \bm{y}_2^{l&#43;1} &amp; \cdots &amp; \bm{y}_N^{l&#43;1} \end{pmatrix}\\
&amp;= \begin{pmatrix} f(\bm{y}_1^{l}) &amp; f(\bm{y}_2^{l}) &amp; \cdots &amp; f(\bm{y}_N^{l}) \end{pmatrix}\\
&amp;= f(Y^{l})
\end{align*}"></div>
</p>
<p>で計算すれば良い。</p>
<p>逆伝播については次のように式が変形できる。
<div class="tex displaystyle" data-expr="\begin{align*}
\frac{\partial E}{\partial Y^{l-1}}
&amp;= \begin{pmatrix}
  \frac{\partial E}{\partial \bm{y}_1^{l}} &amp;
  \frac{\partial E}{\partial \bm{y}_2^{l}} &amp;
  \cdots &amp;
  \frac{\partial E}{\partial \bm{y}_N^{}l}
  \end{pmatrix}\\
&amp;= \begin{pmatrix}
  \frac{\partial E}{\partial \bm{y}_1^{l}} \ast f_l&#39;(\bm{y}_1^{l-1}) &amp;
  \frac{\partial E}{\partial \bm{y}_2^{l}} \ast f_l&#39;(\bm{y}_2^{l-1}) &amp;
  \cdots &amp;
  \frac{\partial E}{\partial \bm{y}_N^{l}} \ast f_l&#39;(\bm{y}_N^{l-1})
\end{pmatrix}\\
&amp;= \frac{\partial E}{\partial Y^{l}} \ast f_l&#39;(Y^{l})
\end{align*}"></div>
</p>
<p>ベクトルが行列にすり替わっただけで、式の形はほとんど変わらない。</p>
<h4 id="全結合層-1">全結合層</h4>
<p>順伝播については、
<div class="tex displaystyle" data-expr="\begin{align*}
Y^{l&#43;1}
&amp;= \begin{pmatrix} \bm{y}_1^{l&#43;1} &amp; \bm{y}_2^{l&#43;1} &amp; \cdots &amp; \bm{y}_N^{l&#43;1} \end{pmatrix}\\
&amp;= \begin{pmatrix} W^{l}\bm{y}_1^{l} &amp; W^{l}\bm{y}_2^{l} &amp; \cdots &amp; W^{l}\bm{y}_N^{l} \end{pmatrix}\\
&amp;= W^{l}Y^{l}
\end{align*}"></div>
</p>
<p>で計算できる。</p>
<p>逆伝播の式を導出する。$W^{l}$ については、</p>
<div class="tex displaystyle" data-expr="\begin{align*}
\frac{\partial E}{\partial W^{l}} 
&amp;= \frac{1}{N} \sum_{n=1}^{N} \frac{\partial E_n}{\partial W^{l}}\\
&amp;= \frac{1}{N} \sum_{n=1}^{N} \bm{y}_{n}^{l-1} \left( \frac{\partial E}{\partial \bm{y}_n^{l}} \right)^{\top}\\
&amp;= \frac{1}{N} Y^{l} \left( \frac{\partial E}{\partial Y^{l}} \right)^{\top}
\end{align*}"></div>

<p>となる。$Y^{l-1}$ については、</p>
<div class="tex displaystyle" data-expr="\begin{align*}
\frac{\partial E}{\partial Y^{l-1}} 
&amp;= \begin{pmatrix}
  \frac{\partial E}{\partial \bm{y}_1^{l-1}} &amp;
  \frac{\partial E}{\partial \bm{y}_2^{l-1}} &amp;
  \cdots &amp;
  \frac{\partial E}{\partial \bm{y}_N^{l-1}}
\end{pmatrix}\\
&amp;= \begin{pmatrix}
 W^{l} \frac{\partial E}{\partial \bm{y}_1^{l}} &amp;
 W^{l} \frac{\partial E}{\partial \bm{y}_2^{l}} &amp;
 \cdots &amp;
 W^{l} \frac{\partial E}{\partial \bm{y}_N^{l}}
\end{pmatrix}\\
&amp;= W^{l} \frac{\partial E}{\partial Y^{l}} 
\end{align*}"></div>

<p>どちらも、ベクトルで表現した場合とあまり変わらないことが分かる。</p>
<h2 id="まとめと感想">まとめと感想</h2>
<p>自分でまとめてみると、難しい計算はしていないことが実感できた。
出てくる文字の数が多かったり、添字がややこしかったり、どの変数について連鎖律を使うのかという点がやや技巧的だったりはした。
ここまで式をまとめられれば、プログラムの実装ができそう。それは別の記事でまとめたい。</p>
<p>誤差逆伝播法の導出を通して、ニューラルネットワークが少し身近に感じられるようになった。
ただし、誤差逆伝播法は必要だが、これ自体がニューラルネットワークの本質であると勘違いしないようにしなければならないだろう (あくまで計算テクニックの1つ、という認識を持っている)。
本当に考えなければならないのは、どんなネットワークを作るか、どんな入力形式にするか、だと思う。
とはいえ自分はまだ入門者なので、確かなことは言えないが…。</p>

</article>



</html>
