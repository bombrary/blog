<!DOCTYPE html>
<html lang="ja-jp">
<title>PureScriptで作るBrainfuckインタプリタ 1/4 基礎部分の作成 | Chanomic Blog</title>
<meta charset="utf-8">
<meta name="generator" content="Hugo 0.113.0">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="https://bombrary.github.io/blog/css/index.css">
<link rel="canonical" href="https://bombrary.github.io/blog/posts/purescript-brainfuck01/">
<link rel="alternate" type="application/rss+xml" href="" title="Chanomic Blog">
  <link rel="stylesheet" href="/blog/css/custom.css">

  <link rel="stylesheet" href="/blog/css/syntax.css">



<script async src="https://www.googletagmanager.com/gtag/js?id=UA-152083322-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-152083322-1');
</script>



<meta property="og:title" content="PureScriptで作るBrainfuckインタプリタ 1/4 基礎部分の作成" />
<meta property="og:description" content="Brainfuckの記事ではあるが、実はモナド変換子を使ってみたかっただけだったりする。
以下の3部の記事で構成されている。
インタプリタと基本的な命令の実装 (この記事) CUIでの入出力処理の実装 CUIでのインタプリタ可視化 Halogenを用いた入出力処理の実装 この記事でインタプリタの基本的な部分を実装し、 残りの3記事はインタプリタとはあまり関係ない話となる (とはいえ出力ができないと Hello, World すら書けないので、必要な記事ではある)。
Brainfuckインタプリタの構造 Brainfuckインタプリタは以下の情報を内部に持っているものとする。
program: 命令の列。 iptr: インストラクションポインタ。実行する命令の位置を示す。プログラムカウンタみたいなもの。 dptr: データポインタ。メモリ上のある位置を示す。 memory: メモリ。 インタプリタは以下の手順を踏む。
iptr番目の命令をprogramから読み取る。 読み取れなかったらプログラムを終了する。 命令に応じてmemory、dptrの書き換えだったり、入出力を行う。 iptrを1進め、手順1に戻る。 どんな命令があるのかについてはWikipedia参照。
準備 適当なディレクトリを作って、プロジェクトの初期化を行う。
% spago init 命令列の作成 src/Brainfuck/Command.pursを作成する。
Commandを定義。Showクラスのインスタンスにして、Charからの変換をする関数を作る。
module Brainfuck.Command where import Prelude data Command = IncPtr -- &#34;&#43;&#34; | DecPtr -- &#34;-&#34; | IncDat -- &#34;&gt;&#34; | DecDat -- &#34;&lt;&#34; | LBrace -- &#34;[&#34; | RBrace -- &#34;]&#34; | Output -- &#34;." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bombrary.github.io/blog/posts/purescript-brainfuck01/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-04T11:40:00+09:00" />
<meta property="article:modified_time" content="2021-07-06T17:10:18+09:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="PureScriptで作るBrainfuckインタプリタ 1/4 基礎部分の作成"/>
<meta name="twitter:description" content="Brainfuckの記事ではあるが、実はモナド変換子を使ってみたかっただけだったりする。
以下の3部の記事で構成されている。
インタプリタと基本的な命令の実装 (この記事) CUIでの入出力処理の実装 CUIでのインタプリタ可視化 Halogenを用いた入出力処理の実装 この記事でインタプリタの基本的な部分を実装し、 残りの3記事はインタプリタとはあまり関係ない話となる (とはいえ出力ができないと Hello, World すら書けないので、必要な記事ではある)。
Brainfuckインタプリタの構造 Brainfuckインタプリタは以下の情報を内部に持っているものとする。
program: 命令の列。 iptr: インストラクションポインタ。実行する命令の位置を示す。プログラムカウンタみたいなもの。 dptr: データポインタ。メモリ上のある位置を示す。 memory: メモリ。 インタプリタは以下の手順を踏む。
iptr番目の命令をprogramから読み取る。 読み取れなかったらプログラムを終了する。 命令に応じてmemory、dptrの書き換えだったり、入出力を行う。 iptrを1進め、手順1に戻る。 どんな命令があるのかについてはWikipedia参照。
準備 適当なディレクトリを作って、プロジェクトの初期化を行う。
% spago init 命令列の作成 src/Brainfuck/Command.pursを作成する。
Commandを定義。Showクラスのインスタンスにして、Charからの変換をする関数を作る。
module Brainfuck.Command where import Prelude data Command = IncPtr -- &#34;&#43;&#34; | DecPtr -- &#34;-&#34; | IncDat -- &#34;&gt;&#34; | DecDat -- &#34;&lt;&#34; | LBrace -- &#34;[&#34; | RBrace -- &#34;]&#34; | Output -- &#34;."/>


<header>
  
    <a href="https://bombrary.github.io/blog/" class="title">Chanomic Blog</a>
  
  
</header>


<article>
  <header>
    <h1><a href="https://bombrary.github.io/blog/posts/purescript-brainfuck01/">PureScriptで作るBrainfuckインタプリタ 1/4 基礎部分の作成</a></h1>
    <div class="meta">
      
      <div class="pub-date">
        <time datetime="2021-07-04T11:40:00&#43;09:00">July 04, 2021</time>
      </div>
      
      
      <div class="lastmod-date">
        <div class="lastmod-date__label">(last modified:</div>
        <time datetime="2021-07-04T11:40:00&#43;09:00">July 06, 2021</time>
        <div class="lastmod-date__label">)</div>
      </div>
      
    </div>
    
    <div class="tags-categories">
      <div class="tags">
        <p>tags: </p>
        <ul class="tags_list">
          <li class="tags_item"><a href="https://bombrary.github.io/blog//tags/%e3%83%a2%e3%83%8a%e3%83%89%e5%a4%89%e6%8f%9b%e5%ad%90/">モナド変換子</a></li>
        </ul>
        
      </div>
      <div class="categories">
        <p>categories: </p>
        
        <ul class="categories_list">
           <li class="categories_item"><a href="https://bombrary.github.io/blog//categories/purescript/">PureScript</a></li> <li class="categories_item"><a href="https://bombrary.github.io/blog//categories/brainfuck/">Brainfuck</a></li>
        </ul>
        
      </div>
    </div>
  </header>
  
    <aside>
      <h2>目次</h2>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#brainfuckインタプリタの構造">Brainfuckインタプリタの構造</a></li>
    <li><a href="#準備">準備</a></li>
    <li><a href="#命令列の作成">命令列の作成</a></li>
    <li><a href="#interpモナド">Interpモナド</a>
      <ul>
        <li><a href="#要件">要件</a></li>
        <li><a href="#envの作成">Envの作成</a></li>
        <li><a href="#stateの作成">Stateの作成</a></li>
        <li><a href="#errorの作成">Errorの作成</a></li>
        <li><a href="#interpの作成">Interpの作成</a></li>
      </ul>
    </li>
    <li><a href="#interpのインスタンス化---derive-newtype">Interpのインスタンス化 - derive newtype</a></li>
    <li><a href="#状態変更に関連する関数の作成">状態変更に関連する関数の作成</a></li>
    <li><a href="#ユーティリティの作成">ユーティリティの作成</a></li>
    <li><a href="#プログラム実行の処理の雛形">プログラム実行の処理の雛形</a></li>
    <li><a href="#各々のコマンドの実装">各々のコマンドの実装</a>
      <ul>
        <li><a href="#gt-と-lt">&lsquo;&gt;&rsquo; と &lsquo;&lt;&rsquo;</a></li>
        <li><a href="#-と--">&lsquo;+&rsquo; と &lsquo;-&rsquo;</a></li>
        <li><a href="#-と-">&lsquo;[&rsquo; と &lsquo;]&rsquo;</a></li>
      </ul>
    </li>
    <li><a href="#次回">次回</a></li>
  </ul>
</nav>
    </aside>
    
  <p>Brainfuckの記事ではあるが、実はモナド変換子を使ってみたかっただけだったりする。</p>
<p>以下の3部の記事で構成されている。</p>
<ol>
<li>インタプリタと基本的な命令の実装 (<strong>この記事</strong>)</li>
<li>CUIでの入出力処理の実装</li>
<li>CUIでのインタプリタ可視化</li>
<li>Halogenを用いた入出力処理の実装</li>
</ol>
<p>この記事でインタプリタの基本的な部分を実装し、
残りの3記事はインタプリタとはあまり関係ない話となる
(とはいえ出力ができないと Hello, World すら書けないので、必要な記事ではある)。</p>
<h2 id="brainfuckインタプリタの構造">Brainfuckインタプリタの構造</h2>
<p>Brainfuckインタプリタは以下の情報を内部に持っているものとする。</p>
<ul>
<li><code>program</code>: 命令の列。</li>
<li><code>iptr</code>: インストラクションポインタ。実行する命令の位置を示す。プログラムカウンタみたいなもの。</li>
<li><code>dptr</code>: データポインタ。メモリ上のある位置を示す。</li>
<li><code>memory</code>: メモリ。</li>
</ul>
<p>インタプリタは以下の手順を踏む。</p>
<ol>
<li><code>iptr</code>番目の命令を<code>program</code>から読み取る。
読み取れなかったらプログラムを終了する。</li>
<li>命令に応じて<code>memory</code>、<code>dptr</code>の書き換えだったり、入出力を行う。</li>
<li><code>iptr</code>を1進め、手順1に戻る。</li>
</ol>
<p>どんな命令があるのかについては<a href="https://ja.wikipedia.org/wiki/Brainfuck">Wikipedia</a>参照。</p>
<h2 id="準備">準備</h2>
<p>適当なディレクトリを作って、プロジェクトの初期化を行う。</p>
<pre class="cui">
% spago init
</pre>

<h2 id="命令列の作成">命令列の作成</h2>
<p><code>src/Brainfuck/Command.purs</code>を作成する。</p>
<p><code>Command</code>を定義。<code>Show</code>クラスのインスタンスにして、<code>Char</code>からの変換をする関数を作る。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">module</span> <span class="nn">Brainfuck.Command</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Prelude</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">data</span> <span class="kt">Command</span>
</span></span><span class="line"><span class="cl">  <span class="ow">=</span> <span class="kt">IncPtr</span> <span class="c1">-- &#34;+&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">DecPtr</span> <span class="c1">-- &#34;-&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">IncDat</span> <span class="c1">-- &#34;&gt;&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">DecDat</span> <span class="c1">-- &#34;&lt;&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">LBrace</span> <span class="c1">-- &#34;[&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">RBrace</span> <span class="c1">-- &#34;]&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Output</span> <span class="c1">-- &#34;.&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Input</span> <span class="c1">-- &#34;,&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Nop</span> <span class="c1">-- otherwise</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">Command</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="n">show</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">    <span class="kr">case</span> <span class="kr">_</span> <span class="kr">of</span>
</span></span><span class="line"><span class="cl">      <span class="kt">IncPtr</span> <span class="ow">-&gt;</span> <span class="s">&#34;&gt;&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">DecPtr</span> <span class="ow">-&gt;</span> <span class="s">&#34;&lt;&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">IncDat</span> <span class="ow">-&gt;</span> <span class="s">&#34;+&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">DecDat</span> <span class="ow">-&gt;</span> <span class="s">&#34;-&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">LBrace</span> <span class="ow">-&gt;</span> <span class="s">&#34;[&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">RBrace</span> <span class="ow">-&gt;</span> <span class="s">&#34;]&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">Output</span> <span class="ow">-&gt;</span> <span class="s">&#34;.&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">Input</span> <span class="ow">-&gt;</span> <span class="s">&#34;,&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">Nop</span> <span class="ow">-&gt;</span> <span class="s">&#34;nop&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">fromChar</span> <span class="ow">::</span> <span class="kt">Char</span> <span class="ow">-&gt;</span> <span class="kt">Command</span>
</span></span><span class="line"><span class="cl"><span class="nf">fromChar</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">  <span class="kr">case</span> <span class="kr">_</span> <span class="kr">of</span>
</span></span><span class="line"><span class="cl">    <span class="sc">&#39;&gt;&#39;</span> <span class="ow">-&gt;</span> <span class="kt">IncPtr</span>
</span></span><span class="line"><span class="cl">    <span class="sc">&#39;&lt;&#39;</span> <span class="ow">-&gt;</span> <span class="kt">DecPtr</span>
</span></span><span class="line"><span class="cl">    <span class="sc">&#39;+&#39;</span> <span class="ow">-&gt;</span> <span class="kt">IncDat</span>
</span></span><span class="line"><span class="cl">    <span class="sc">&#39;-&#39;</span> <span class="ow">-&gt;</span> <span class="kt">DecDat</span>
</span></span><span class="line"><span class="cl">    <span class="sc">&#39;[&#39;</span> <span class="ow">-&gt;</span> <span class="kt">LBrace</span>
</span></span><span class="line"><span class="cl">    <span class="sc">&#39;]&#39;</span> <span class="ow">-&gt;</span> <span class="kt">RBrace</span>
</span></span><span class="line"><span class="cl">    <span class="sc">&#39;.&#39;</span> <span class="ow">-&gt;</span> <span class="kt">Output</span>
</span></span><span class="line"><span class="cl">    <span class="sc">&#39;,&#39;</span> <span class="ow">-&gt;</span> <span class="kt">Input</span>
</span></span><span class="line"><span class="cl">    <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nop</span>
</span></span></code></pre></div><p>続いて、<code>src/Brainfuck/Program.purs</code>を作成。この後使う関数をまとめて読み込んでおく。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">module</span> <span class="nn">Brainfuck.Program</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Prelude</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Brainfuck.Command</span> <span class="p">(</span><span class="kt">Command</span><span class="p">,</span> <span class="nf">fromChar</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Data.Array</span> <span class="p">((</span><span class="o">!!</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Data.Array</span> <span class="p">(</span><span class="nf">intercalate</span><span class="p">)</span> <span class="n">as</span> <span class="kt">Array</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Data.Maybe</span> <span class="p">(</span><span class="kt">Maybe</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Data.String.CodeUnits</span> <span class="p">(</span><span class="nf">toCharArray</span><span class="p">)</span> <span class="n">as</span> <span class="kt">CodeUnits</span>
</span></span></code></pre></div><p><code>Program</code>を定義する。<code>String</code>から変換する関数、<code>Program</code>から命令を1つ読み取る関数を作る。</p>
<p>(<strong>補足</strong>) <a href="https://github.com/purescript/purescript/releases/tag/v0.14.2">PureScript v0.14.2</a>からinstance nameが省略可能になったので、
<code>instance showProgram Show Program</code>みたいには書かず<code>instance Show Program</code>と書いている。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">newtype</span> <span class="kt">Program</span> <span class="ow">=</span> <span class="kt">Program</span> <span class="p">(</span><span class="kt">Array</span> <span class="kt">Command</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">Program</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="n">show</span> <span class="p">(</span><span class="kt">Program</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;</span><span class="se">\&#34;</span><span class="s">&#34;</span> <span class="o">&lt;&gt;</span> <span class="p">(</span><span class="kt">Array</span><span class="o">.</span><span class="n">intercalate</span> <span class="s">&#34; &#34;</span> <span class="o">$</span> <span class="n">map</span> <span class="n">show</span> <span class="n">p</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="s">&#34;</span><span class="se">\&#34;</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">fromString</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Program</span>
</span></span><span class="line"><span class="cl"><span class="nf">fromString</span> <span class="n">str</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">  <span class="kt">Program</span> <span class="o">$</span> <span class="n">map</span> <span class="n">fromChar</span> <span class="o">$</span> <span class="kt">CodeUnits</span><span class="o">.</span><span class="n">toCharArray</span> <span class="n">str</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">readAt</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Program</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Command</span>
</span></span><span class="line"><span class="cl"><span class="nf">readAt</span> <span class="n">i</span> <span class="p">(</span><span class="kt">Program</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">xs</span> <span class="o">!!</span> <span class="n">i</span>
</span></span></code></pre></div><p>関連パッケージをインストールする。</p>
<pre class="cui">
spago install arrays maybe strings
</pre>

<p>REPLで動作確認してみる。</p>
<pre class="cui">
> import Brainfuck.Program
> fromString "+++[>+++<-]++>,<.hoge"
"> > > [ + > > > - < ] > > + , - . nop nop nop nop"
</pre>

<h2 id="interpモナド">Interpモナド</h2>
<h3 id="要件">要件</h3>
<p>インタプリタは以下の機能を持つものとする。</p>
<ul>
<li><code>iptr</code>、<code>dptr</code>、<code>memory</code>の3つはインタプリタの状態を表し、これらは計算中に変わる。これを<code>State</code>モナドで扱う。</li>
<li><code>program</code>は読み取るだけ。これを<code>Reader</code>モナドで扱う。</li>
<li><code>dpt</code>がメモリ外の範囲を参照してしまったり、<code>iptr</code>がプログラム外の範囲を参照してしまう可能性がある。
そのような例外を扱うために、<code>Except</code>モナドを使う。</li>
<li>標準入力や標準出力を行うために、<code>Effect</code>モナドを使う。</li>
</ul>
<p>これらを組み合わせるためには、<a href="https://pursuit.purescript.org/packages/purescript-transformers/5.1.0">transformers</a>のモナド変換子が必要になる。
よって、<code>State, Reader, Except</code>はそれぞれ<code>StateT, ReaderT, ExceptT</code>となる。</p>
<p>以下のように組み合わせる。<code>Env</code>、<code>Error</code>、<code>State</code>はこれから作る型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">type</span> <span class="kt">Interp</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">ReaderT</span> <span class="kt">Env</span> <span class="p">(</span><span class="kt">ExceptT</span> <span class="kt">Error</span> <span class="p">(</span><span class="kt">StateT</span> <span class="kt">State</span> <span class="kt">Effect</span><span class="p">))</span> <span class="n">a</span>
</span></span></code></pre></div><p>なにやらごちゃごちゃしてしまっている。ためしに<code>runReaderT, runExceptT, runStateT</code>を使って、手動でモナドを引き剥がしてみる
(以下はプログラムのコードではなく、モナド変換子の型の遷移をみるためのメモ)。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">x</span> <span class="ow">::</span> <span class="kt">ReaderT</span> <span class="kt">Env</span> <span class="p">(</span><span class="kt">ExceptT</span> <span class="kt">Error</span> <span class="p">(</span><span class="kt">StateT</span> <span class="kt">State</span> <span class="kt">Effect</span><span class="p">))</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl"><span class="nf">x1</span> <span class="ow">=</span> <span class="n">runReaderT</span> <span class="n">program</span> <span class="n">x</span> <span class="ow">::</span> <span class="kt">ExceptT</span> <span class="kt">Error</span> <span class="p">(</span><span class="kt">StateT</span> <span class="kt">State</span> <span class="kt">Effect</span><span class="p">)</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl"><span class="nf">x2</span> <span class="ow">=</span> <span class="n">runExceptT</span> <span class="n">x1</span> <span class="ow">::</span> <span class="kt">StateT</span> <span class="kt">State</span> <span class="kt">Effect</span> <span class="p">(</span><span class="kt">Either</span> <span class="kt">Error</span> <span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">x3</span> <span class="ow">=</span> <span class="n">runStateT</span> <span class="n">x2</span> <span class="ow">::</span> <span class="kt">Effect</span> <span class="p">(</span><span class="kt">Tuple</span> <span class="p">(</span><span class="kt">Either</span> <span class="kt">Error</span> <span class="n">a</span><span class="p">)</span> <span class="kt">State</span><span class="p">)</span>
</span></span></code></pre></div><p>どうやら、<code>(エラー付きの値, 最終状態)</code> というタプルを返すようだ。ただし、<code>Effect</code>に包まれた状態で返ってくる。</p>
<p><code>type</code>で<code>Interp</code>を宣言すると、コンパイルエラーで<code>ReaderT Env (ExceptT Error (StateT State Effect)) a</code>
が表示されてしまい見づらい。よって、<code>newtype</code>で包んで使用する。</p>
<h3 id="envの作成">Envの作成</h3>
<p><code>Interp</code>の外部状態である<code>State</code>を作成する。<code>src/Brainfuck/Env.purs</code>を作成。</p>
<p><code>Env</code>は<code>Program</code>のみが入っているレコードとする。
<code>Env</code>から<code>Program</code>取り出す関数と、<code>Env</code>を作る関数を定義。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">module</span> <span class="nn">Brainfuck.Env</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Prelude</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Brainfuck.Program</span> <span class="p">(</span><span class="kt">Program</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">newtype</span> <span class="kt">Env</span> <span class="ow">=</span> <span class="kt">Env</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span> <span class="n">program</span> <span class="ow">::</span> <span class="kt">Program</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">Env</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="n">show</span> <span class="p">(</span><span class="kt">Env</span> <span class="p">{</span> <span class="n">program</span> <span class="p">})</span> <span class="ow">=</span> <span class="n">show</span> <span class="n">program</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">getProgram</span> <span class="ow">::</span> <span class="kt">Env</span> <span class="ow">-&gt;</span> <span class="kt">Program</span>
</span></span><span class="line"><span class="cl"><span class="nf">getProgram</span> <span class="p">(</span><span class="kt">Env</span> <span class="p">{</span> <span class="n">program</span> <span class="p">}</span> <span class="p">)</span> <span class="ow">=</span> <span class="n">program</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">makeEnv</span> <span class="ow">::</span> <span class="kt">Program</span> <span class="ow">-&gt;</span> <span class="kt">Env</span>
</span></span><span class="line"><span class="cl"><span class="nf">makeEnv</span> <span class="n">program</span> <span class="ow">=</span> <span class="kt">Env</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span> <span class="n">program</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></div><h3 id="stateの作成">Stateの作成</h3>
<p><code>Interp</code>の内部状態である<code>State</code>を作成する。まず<code>src/Brainfuck/State.purs</code>を作成。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">module</span> <span class="nn">Brainfuck.State</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">newtype</span> <span class="kt">State</span> <span class="ow">=</span> <span class="kt">State</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span> <span class="n">dptr</span> <span class="ow">::</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl">  <span class="p">,</span> <span class="n">iptr</span> <span class="ow">::</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl">  <span class="p">,</span> <span class="n">memory</span> <span class="ow">::</span> <span class="kt">Array</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></div><h3 id="errorの作成">Errorの作成</h3>
<p><code>Interp</code>の例外の型である<code>Error</code>を作成する。<code>src/Brainfuck/Error.purs</code>を作成。</p>
<p>考えられる例外は以下の通り。</p>
<ul>
<li><code>IPtrOutOfRange</code>: 命令列の配列外参照</li>
<li><code>DPtrOutOfRange</code>: メモリの配列外参照</li>
<li><code>CharDecodeError</code>: <code>.</code>命令によってメモリ上の整数を文字に変換して出力するが、その変換に失敗した場合(整数がUnicodeでなかった場合に起こる)。</li>
<li><code>CharInputFailed</code>: 文字の入力に失敗した場合に起こる</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">module</span> <span class="nn">Brainfuck.Error</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Prelude</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">data</span> <span class="kt">Error</span>
</span></span><span class="line"><span class="cl">  <span class="ow">=</span> <span class="kt">IPtrOutOfRange</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">DPtrOutOfRange</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">CharDecodeFailed</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">CharInputFailed</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">Error</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="n">show</span> <span class="n">err</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">    <span class="kr">case</span> <span class="n">err</span> <span class="kr">of</span>
</span></span><span class="line"><span class="cl">      <span class="kt">IPtrOutOfRange</span> <span class="ow">-&gt;</span> <span class="s">&#34;Error: Instruction pointer out of range&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">DPtrOutOfRange</span> <span class="ow">-&gt;</span> <span class="s">&#34;Error: Data oointer out of range&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">CharDecodeFailed</span> <span class="ow">-&gt;</span> <span class="s">&#34;Error: Failed to decode integer to char&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">CharInputFailed</span> <span class="ow">-&gt;</span> <span class="s">&#34;Error: Failed to input char&#34;</span>
</span></span></code></pre></div><h3 id="interpの作成">Interpの作成</h3>
<p><code>src/Brainfuck/Interp.purs</code>を作成。
この後使うパッケージを読み込んでおく。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">module</span> <span class="nn">Brainfuck.Interp</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Prelude</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Brainfuck.Env</span> <span class="p">(</span><span class="kt">Env</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Brainfuck.Error</span> <span class="p">(</span><span class="kt">Error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Brainfuck.State</span> <span class="p">(</span><span class="kt">State</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Control.Monad.Except.Trans</span> <span class="p">(</span><span class="nf">class</span> <span class="kt">MonadThrow</span><span class="p">,</span> <span class="kt">ExceptT</span><span class="p">,</span> <span class="nf">runExceptT</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Control.Monad.Reader.Trans</span> <span class="p">(</span><span class="nf">class</span> <span class="kt">MonadAsk</span><span class="p">,</span> <span class="kt">ReaderT</span><span class="p">,</span> <span class="nf">runReaderT</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Control.Monad.State.Trans</span> <span class="p">(</span><span class="nf">class</span> <span class="kt">MonadState</span><span class="p">,</span> <span class="kt">StateT</span><span class="p">,</span> <span class="nf">runStateT</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Data.Either</span> <span class="p">(</span><span class="kt">Either</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Data.Tuple</span> <span class="p">(</span><span class="kt">Tuple</span><span class="p">(</span><span class="o">..</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Effect.Class</span> <span class="p">(</span><span class="nf">class</span> <span class="kt">MonadEffect</span><span class="p">)</span>
</span></span></code></pre></div><p>まず型を作成。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">newtype</span> <span class="kt">Interp</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Interp</span> <span class="p">(</span><span class="kt">ReaderT</span> <span class="kt">Env</span> <span class="p">(</span><span class="kt">ExceptT</span> <span class="kt">Error</span> <span class="p">(</span><span class="kt">StateT</span> <span class="kt">State</span> <span class="kt">Effect</span><span class="p">))</span> <span class="n">a</span><span class="p">)</span>
</span></span></code></pre></div><p><code>Interp</code>の計算を実行して結果を返す関数を返す。単に<code>run***</code>を実行してモナドを引き剥がすだけ。
計算結果が<code>Effect</code>で包まれて返ってくることに注意。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">runInterp</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">Interp</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Env</span> <span class="ow">-&gt;</span> <span class="kt">State</span> <span class="ow">-&gt;</span> <span class="kt">Effect</span> <span class="p">(</span><span class="kt">InterpResult</span> <span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">runInterp</span> <span class="p">(</span><span class="kt">Interp</span> <span class="n">ip</span><span class="p">)</span> <span class="n">env</span> <span class="n">s</span> <span class="ow">=</span> <span class="kr">do</span>
</span></span><span class="line"><span class="cl">  <span class="kt">Tuple</span> <span class="n">result</span> <span class="n">state</span> <span class="ow">&lt;-</span> <span class="n">runStateT</span> <span class="p">(</span><span class="n">runExceptT</span> <span class="p">(</span><span class="n">runReaderT</span> <span class="n">ip</span> <span class="n">env</span><span class="p">))</span> <span class="n">s</span>
</span></span><span class="line"><span class="cl">  <span class="n">pure</span> <span class="p">{</span> <span class="n">result</span><span class="p">,</span> <span class="n">state</span> <span class="p">}</span>
</span></span></code></pre></div><p><code>InterpResult a</code>は次のように定義しておく。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">type</span> <span class="kt">InterpResult</span> <span class="n">a</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span> <span class="n">result</span> <span class="ow">::</span> <span class="kt">Either</span> <span class="kt">Error</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl">  <span class="p">,</span> <span class="n">state</span> <span class="ow">::</span> <span class="kt">State</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></div><p>関連パッケージをインストールしておく。</p>
<pre class="cui">
spago install transformers either tuples
</pre>

<h2 id="interpのインスタンス化---derive-newtype">Interpのインスタンス化 - derive newtype</h2>
<p><code>Interp</code>を<code>newtype</code>に包んでしまったせいで、<code>Interp</code>自身は<code>Monad</code>インスタンスではない。
よって現状は<code>do</code>記法を使うことができない。それだけでなく、せっかく<code>StateT</code>や<code>ReaderT</code>、<code>ExceptT</code>
を使ったのに<code>modify</code>、<code>ask</code>、<code>throwError</code>などの関数が利用できない。もちろん<code>Effect</code>関連の関数も利用できない。</p>
<p>そこで、以下のように手動でインスタンス宣言してみるが、<code>Interp</code>を引き剥がしたり包んだりして混乱するし、面倒である。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Interp</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="n">map</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Interp</span> <span class="n">ip</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Interp</span> <span class="p">(</span><span class="n">map</span> <span class="n">f</span> <span class="n">ip</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Apply</span> <span class="kt">Interp</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="n">apply</span> <span class="p">(</span><span class="kt">Interp</span> <span class="n">f</span><span class="p">)</span> <span class="p">(</span><span class="kt">Interp</span> <span class="n">ip</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Interp</span> <span class="p">(</span><span class="n">apply</span> <span class="n">f</span> <span class="n">ip</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">Interp</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="n">pure</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Interp</span> <span class="p">(</span><span class="n">pure</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Bind</span> <span class="kt">Interp</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="n">bind</span> <span class="p">(</span><span class="kt">Interp</span> <span class="n">ip</span><span class="p">)</span> <span class="n">f</span> <span class="ow">=</span> <span class="kt">Interp</span> <span class="p">(</span><span class="n">bind</span> <span class="n">ip</span> <span class="n">g</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="kr">where</span>
</span></span><span class="line"><span class="cl">      <span class="n">g</span> <span class="n">x</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">        <span class="kr">let</span> <span class="p">(</span><span class="kt">Interp</span> <span class="n">y</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">        <span class="kr">in</span>
</span></span><span class="line"><span class="cl">          <span class="n">y</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Interp</span>
</span></span></code></pre></div><p>幸いにも、<code>newtype</code>の場合には<a href="https://github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving.md#derive-from-newtype">derive newtype</a>という機能がある
(詳しくは<a href="https://github.com/paf31/24-days-of-purescript-2016/blob/master/4.markdown">Newtype Deriving</a>も参照)。
<code>newtype</code>で包まれたデータは、吐き出されたJavaScriptコードでは中身そのものして扱われる(<a href="https://github.com/purescript/documentation/blob/master/language/Types.md#newtypes">参考</a>)。
<code>derive newtype</code>を使うと、包んだ中身の型のインスタンスをそのまま使うことができる。</p>
<p>例えば、以下の例では<code>Num</code>を<code>Show</code>クラスのインスタンスにしている。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">newtype</span> <span class="kt">Num</span> <span class="ow">=</span> <span class="kt">Num</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">derive</span> <span class="kr">newtype</span> <span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">Num</span>
</span></span></code></pre></div><p>あくまで包んだ中身の<code>Int</code>の<code>show</code>を使うだけなので、以下では<code>Num 123</code>とかではなく<code>123</code>と出力される。</p>
<pre class="cui">
> Num 123
123
</pre>

<p>以上の話を元に、<code>src/Brainfuck/Interp.purs</code>に追記する。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">derive</span> <span class="kr">newtype</span> <span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Interp</span>
</span></span><span class="line"><span class="cl"><span class="nf">derive</span> <span class="kr">newtype</span> <span class="kr">instance</span> <span class="kt">Apply</span> <span class="kt">Interp</span>
</span></span><span class="line"><span class="cl"><span class="nf">derive</span> <span class="kr">newtype</span> <span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">Interp</span>
</span></span><span class="line"><span class="cl"><span class="nf">derive</span> <span class="kr">newtype</span> <span class="kr">instance</span> <span class="kt">Bind</span> <span class="kt">Interp</span>
</span></span><span class="line"><span class="cl"><span class="nf">derive</span> <span class="kr">newtype</span> <span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Interp</span>
</span></span><span class="line"><span class="cl"><span class="nf">derive</span> <span class="kr">newtype</span> <span class="kr">instance</span> <span class="kt">MonadState</span> <span class="kt">State</span> <span class="kt">Interp</span>
</span></span><span class="line"><span class="cl"><span class="nf">derive</span> <span class="kr">newtype</span> <span class="kr">instance</span> <span class="kt">MonadAsk</span> <span class="kt">Env</span> <span class="kt">Interp</span>
</span></span><span class="line"><span class="cl"><span class="nf">derive</span> <span class="kr">newtype</span> <span class="kr">instance</span> <span class="kt">MonadThrow</span> <span class="kt">Error</span> <span class="kt">Interp</span>
</span></span><span class="line"><span class="cl"><span class="nf">derive</span> <span class="kr">newtype</span> <span class="kr">instance</span> <span class="kt">MonadEffect</span> <span class="kt">Interp</span>
</span></span></code></pre></div><p>ついでに<code>State</code>についても<code>Show</code>インスタンスにしておく。
以下の内容を<code>src/Brainfuck/State.purs</code>に追記。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">derive</span> <span class="kr">newtype</span> <span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">State</span>
</span></span></code></pre></div><h2 id="状態変更に関連する関数の作成">状態変更に関連する関数の作成</h2>
<p><code>src/Brainfuck/State.purs</code>に追記する。</p>
<p>まずimport文を追記。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Prelude</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Brainfuck.Command</span> <span class="p">(</span><span class="kt">Command</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Brainfuck.Program</span> <span class="p">(</span><span class="kt">Program</span><span class="p">,</span> <span class="nf">readAt</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Data.Array</span> <span class="p">(</span><span class="nf">modifyAt</span><span class="p">,</span> <span class="p">(</span><span class="o">!!</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Data.Maybe</span> <span class="p">(</span><span class="kt">Maybe</span><span class="p">)</span>
</span></span></code></pre></div><p>メモリや命令列、それらのポインタの操作を行う関数を作成。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">modifyDataPtr</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">State</span> <span class="ow">-&gt;</span> <span class="kt">State</span>
</span></span><span class="line"><span class="cl"><span class="nf">modifyDataPtr</span> <span class="n">f</span> <span class="p">(</span><span class="kt">State</span> <span class="n">s</span><span class="o">@</span><span class="p">{</span> <span class="n">dptr</span> <span class="p">})</span> <span class="ow">=</span> <span class="kt">State</span> <span class="n">s</span> <span class="p">{</span> <span class="n">dptr</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">dptr</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">readData</span> <span class="ow">::</span> <span class="kt">State</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">readData</span> <span class="p">(</span><span class="kt">State</span> <span class="p">{</span> <span class="n">memory</span><span class="p">,</span> <span class="n">dptr</span> <span class="p">})</span> <span class="ow">=</span> <span class="n">memory</span> <span class="o">!!</span> <span class="n">dptr</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">modifyData</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">State</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">State</span>
</span></span><span class="line"><span class="cl"><span class="nf">modifyData</span> <span class="n">f</span> <span class="p">(</span><span class="kt">State</span> <span class="n">s</span><span class="o">@</span><span class="p">{</span> <span class="n">memory</span><span class="p">,</span> <span class="n">dptr</span> <span class="p">})</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">map</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="nf">\</span><span class="n">newMem</span> <span class="ow">-&gt;</span> <span class="kt">State</span> <span class="n">s</span> <span class="p">{</span> <span class="n">memory</span> <span class="ow">=</span> <span class="n">newMem</span> <span class="p">})</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="n">modifyAt</span> <span class="n">dptr</span> <span class="n">f</span> <span class="n">memory</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">modifyInstPtr</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">State</span> <span class="ow">-&gt;</span> <span class="kt">State</span>
</span></span><span class="line"><span class="cl"><span class="nf">modifyInstPtr</span> <span class="n">f</span> <span class="p">(</span><span class="kt">State</span> <span class="n">s</span><span class="o">@</span><span class="p">{</span> <span class="n">iptr</span> <span class="p">})</span> <span class="ow">=</span> <span class="kt">State</span> <span class="n">s</span> <span class="p">{</span> <span class="n">iptr</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">iptr</span> <span class="p">}</span>
</span></span></code></pre></div><p>プログラムから命令を読み取る関数も作っておく。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">readCommand</span> <span class="ow">::</span> <span class="kt">Program</span> <span class="ow">-&gt;</span> <span class="kt">State</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Command</span>
</span></span><span class="line"><span class="cl"><span class="nf">readCommand</span> <span class="n">p</span> <span class="p">(</span><span class="kt">State</span> <span class="p">{</span> <span class="n">iptr</span> <span class="p">})</span> <span class="ow">=</span> <span class="n">readAt</span> <span class="n">iptr</span> <span class="n">p</span>
</span></span></code></pre></div><h2 id="ユーティリティの作成">ユーティリティの作成</h2>
<p><code>src/Brainfuck/Interp/Util.purs</code>を作成。ここに<code>Interp</code>に関するいくつかのユーティリティを定義しておく。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">module</span> <span class="nn">Brainfuck.Interp.Util</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Prelude</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Brainfuck.Command</span> <span class="p">(</span><span class="kt">Command</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Brainfuck.Env</span> <span class="p">(</span><span class="nf">getProgram</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Brainfuck.Error</span> <span class="p">(</span><span class="kt">Error</span><span class="p">(</span><span class="o">..</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Brainfuck.Interp</span> <span class="p">(</span><span class="kt">Interp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Brainfuck.State</span> <span class="p">(</span><span class="nf">modifyData</span><span class="p">,</span> <span class="nf">modifyInstPtr</span><span class="p">,</span> <span class="nf">readCommand</span><span class="p">,</span> <span class="nf">readData</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Control.Monad.Except.Trans</span> <span class="p">(</span><span class="nf">throwError</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Control.Monad.Reader.Trans</span> <span class="p">(</span><span class="nf">ask</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Control.Monad.State.Trans</span> <span class="p">(</span><span class="nf">get</span><span class="p">,</span> <span class="nf">gets</span><span class="p">,</span> <span class="nf">modify_</span><span class="p">,</span> <span class="nf">put</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Data.Char</span> <span class="p">(</span><span class="nf">fromCharCode</span><span class="p">)</span> <span class="n">as</span> <span class="kt">Char</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Data.Maybe</span> <span class="p">(</span><span class="kt">Maybe</span><span class="p">(</span><span class="o">..</span><span class="p">))</span>
</span></span></code></pre></div><p><code>+</code>、<code>-</code>、<code>.</code>、<code>,</code>でメモリからデータにアクセスする必要があるので、関連の関数を定義する。
失敗したら例外を投げるようにする。また<code>.</code>では整数値を文字に変換する必要があるため、その関数を定義しておく。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">modifyDataOrFail</span> <span class="ow">::</span>  <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Interp</span> <span class="kt">Unit</span>
</span></span><span class="line"><span class="cl"><span class="nf">modifyDataOrFail</span> <span class="n">f</span> <span class="ow">=</span> <span class="kr">do</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span> <span class="ow">&lt;-</span> <span class="n">get</span>
</span></span><span class="line"><span class="cl">  <span class="kr">case</span> <span class="n">modifyData</span> <span class="n">f</span> <span class="n">state</span> <span class="kr">of</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Just</span> <span class="n">newState</span> <span class="ow">-&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">put</span> <span class="n">newState</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">Nothing</span> <span class="ow">-&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">throwError</span> <span class="kt">DPtrOutOfRange</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">readDataOrFail</span> <span class="ow">::</span>  <span class="kt">Interp</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">readDataOrFail</span> <span class="ow">=</span> <span class="kr">do</span>
</span></span><span class="line"><span class="cl">  <span class="n">gets</span> <span class="n">readData</span> <span class="o">&gt;&gt;=</span>
</span></span><span class="line"><span class="cl">    <span class="kr">case</span> <span class="kr">_</span> <span class="kr">of</span>
</span></span><span class="line"><span class="cl">      <span class="kt">Just</span> <span class="n">x</span> <span class="ow">-&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="n">pure</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="kt">Nothing</span> <span class="ow">-&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="n">throwError</span> <span class="kt">DPtrOutOfRange</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">readCharOrFail</span> <span class="ow">::</span> <span class="kt">Interp</span> <span class="kt">Char</span>
</span></span><span class="line"><span class="cl"><span class="nf">readCharOrFail</span> <span class="ow">=</span> <span class="kr">do</span>
</span></span><span class="line"><span class="cl">  <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">readDataOrFail</span>
</span></span><span class="line"><span class="cl">  <span class="kr">case</span> <span class="kt">Char</span><span class="o">.</span><span class="n">fromCharCode</span> <span class="n">x</span> <span class="kr">of</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Just</span> <span class="n">c</span> <span class="ow">-&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">pure</span> <span class="n">c</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">Nothing</span> <span class="ow">-&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">throwError</span> <span class="kt">CharDecodeFailed</span>
</span></span></code></pre></div><p>命令列を読み取る関数、インストラクションポインタを操作する関数を定義する。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">readCommandOrFail</span> <span class="ow">::</span> <span class="kt">Interp</span> <span class="kt">Command</span>
</span></span><span class="line"><span class="cl"><span class="nf">readCommandOrFail</span> <span class="ow">=</span> <span class="kr">do</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span> <span class="ow">&lt;-</span> <span class="n">get</span>
</span></span><span class="line"><span class="cl">  <span class="n">program</span> <span class="ow">&lt;-</span> <span class="n">getProgram</span> <span class="o">&lt;$&gt;</span> <span class="n">ask</span>
</span></span><span class="line"><span class="cl">  <span class="kr">case</span> <span class="n">readCommand</span> <span class="n">program</span> <span class="n">state</span> <span class="kr">of</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Just</span> <span class="n">cmd</span> <span class="ow">-&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">pure</span> <span class="n">cmd</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">Nothing</span> <span class="ow">-&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">throwError</span> <span class="kt">IPtrOutOfRange</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">incInstPtr</span> <span class="ow">::</span>  <span class="kt">Interp</span> <span class="kt">Unit</span>
</span></span><span class="line"><span class="cl"><span class="nf">incInstPtr</span> <span class="ow">=</span> <span class="n">modify_</span> <span class="o">$</span> <span class="n">modifyInstPtr</span> <span class="p">(</span><span class="kr">_</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">decInstPtr</span> <span class="ow">::</span>  <span class="kt">Interp</span> <span class="kt">Unit</span>
</span></span><span class="line"><span class="cl"><span class="nf">decInstPtr</span> <span class="ow">=</span> <span class="n">modify_</span> <span class="o">$</span> <span class="n">modifyInstPtr</span> <span class="p">(</span><span class="kr">_</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span></code></pre></div><h2 id="プログラム実行の処理の雛形">プログラム実行の処理の雛形</h2>
<p><code>src/Brainfuck/State.purs</code>に追記する。</p>
<p>以下のimport文を追加。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Data.Array</span> <span class="p">(</span><span class="nf">replicate</span><span class="p">)</span> <span class="n">as</span> <span class="kt">Array</span>
</span></span></code></pre></div><p><code>defaultState</code>を作成。今回は出力の見やすさのために、<code>memory</code>を要素数10の配列にしている
(Brainfuckの仕様では、本当は30000要素以上を持っていないといけない)。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">defaultState</span> <span class="ow">::</span> <span class="kt">State</span>
</span></span><span class="line"><span class="cl"><span class="nf">defaultState</span> <span class="ow">=</span> <span class="kt">State</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span> <span class="n">iptr</span><span class="kt">:</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">  <span class="p">,</span> <span class="n">dptr</span><span class="kt">:</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">  <span class="p">,</span> <span class="n">memory</span><span class="kt">:</span> <span class="kt">Array</span><span class="o">.</span><span class="n">replicate</span> <span class="mi">10</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></div><p><code>src/Brainfuck.purs</code>を作成する。この後使う関数をまとめて読み込んでおく。
<code>Brainfuck.Interp.Command</code>はこの後作る。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">module</span> <span class="nn">Brainfuck</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Prelude</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Brainfuck.Env</span> <span class="p">(</span><span class="nf">getProgram</span><span class="p">,</span> <span class="nf">makeEnv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Brainfuck.Interp</span> <span class="p">(</span><span class="kt">Interp</span><span class="p">,</span> <span class="kt">InterpResult</span><span class="p">,</span> <span class="nf">runInterp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Brainfuck.Interp.Command</span> <span class="p">(</span><span class="nf">interpCommand</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Brainfuck.Interp.Util</span> <span class="p">(</span><span class="nf">incInstPtr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Brainfuck.Program</span> <span class="p">(</span><span class="kt">Program</span><span class="p">(</span><span class="o">..</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Brainfuck.State</span> <span class="p">(</span><span class="nf">defaultState</span><span class="p">,</span> <span class="nf">readCommand</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Control.Monad.Reader.Class</span> <span class="p">(</span><span class="nf">ask</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Control.Monad.State.Class</span> <span class="p">(</span><span class="nf">get</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Data.Maybe</span> <span class="p">(</span><span class="kt">Maybe</span><span class="p">(</span><span class="o">..</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Effect</span> <span class="p">(</span><span class="kt">Effect</span><span class="p">)</span>
</span></span></code></pre></div><p>まずプログラムを受け取って実行する関数を定義する。細かい処理は<code>interpProgram</code>に任せる。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">runDefault</span> <span class="ow">::</span> <span class="kt">Program</span> <span class="ow">-&gt;</span> <span class="kt">Effect</span> <span class="p">(</span><span class="kt">InterpResult</span> <span class="kt">Unit</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">runDefault</span> <span class="n">program</span> <span class="ow">=</span> <span class="n">runInterp</span> <span class="n">interpProgram</span> <span class="p">(</span><span class="n">makeEnv</span> <span class="n">program</span><span class="p">)</span> <span class="n">defaultState</span>
</span></span></code></pre></div><p>プログラムを解釈する関数<code>interpProgram</code>を作成。
ここでは命令を取得し、インストラクションポインタを1進めるという処理を行っている。
命令の解釈は<code>interpCommand</code>に任せる。
<code>interpProgram</code>を再帰的に呼び出し、コマンドが取得できなかった場合は終了する。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">interpProgram</span> <span class="ow">::</span> <span class="kt">Interp</span> <span class="kt">Unit</span>
</span></span><span class="line"><span class="cl"><span class="nf">interpProgram</span> <span class="ow">=</span> <span class="kr">do</span>
</span></span><span class="line"><span class="cl">  <span class="n">program</span> <span class="ow">&lt;-</span> <span class="n">getProgram</span> <span class="o">&lt;$&gt;</span> <span class="n">ask</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span> <span class="ow">&lt;-</span> <span class="n">get</span>
</span></span><span class="line"><span class="cl">  <span class="kr">case</span> <span class="n">readCommand</span> <span class="n">program</span> <span class="n">state</span> <span class="kr">of</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Just</span> <span class="n">cmd</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
</span></span><span class="line"><span class="cl">      <span class="n">interpCommand</span> <span class="n">cmd</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">incInstPtr</span>
</span></span><span class="line"><span class="cl">      <span class="n">interpProgram</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">Nothing</span> <span class="ow">-&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">pure</span> <span class="n">unit</span>
</span></span></code></pre></div><p>続いて、<code>src/Brainfuck/Interp/Command.purs</code>を作成。コマンドの処理はここに書くことにする。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">module</span> <span class="nn">Brainfuck.Interp.Command</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Prelude</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Brainfuck.Command</span> <span class="p">(</span><span class="kt">Command</span><span class="p">(</span><span class="o">..</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Brainfuck.Interp</span> <span class="p">(</span><span class="kt">Interp</span><span class="p">)</span>
</span></span></code></pre></div><p>コマンドを読み取り実行する関数の雛形を作る。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">interpCommand</span> <span class="ow">::</span> <span class="kt">Command</span> <span class="ow">-&gt;</span> <span class="kt">Interp</span> <span class="kt">Unit</span>
</span></span><span class="line"><span class="cl"><span class="nf">interpCommand</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">  <span class="kr">case</span> <span class="kr">_</span> <span class="kr">of</span>
</span></span><span class="line"><span class="cl">     <span class="kt">IncPtr</span> <span class="ow">-&gt;</span>
</span></span><span class="line"><span class="cl">       <span class="n">pure</span> <span class="n">unit</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="kt">DecPtr</span> <span class="ow">-&gt;</span>
</span></span><span class="line"><span class="cl">       <span class="n">pure</span> <span class="n">unit</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="kt">IncDat</span> <span class="ow">-&gt;</span>
</span></span><span class="line"><span class="cl">       <span class="n">pure</span> <span class="n">unit</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="kt">DecDat</span> <span class="ow">-&gt;</span>
</span></span><span class="line"><span class="cl">       <span class="n">pure</span> <span class="n">unit</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="kt">LBrace</span> <span class="ow">-&gt;</span>
</span></span><span class="line"><span class="cl">       <span class="n">pure</span> <span class="n">unit</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="kt">RBrace</span> <span class="ow">-&gt;</span>
</span></span><span class="line"><span class="cl">       <span class="n">pure</span> <span class="n">unit</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="kt">Output</span> <span class="ow">-&gt;</span>
</span></span><span class="line"><span class="cl">       <span class="n">pure</span> <span class="n">unit</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="kt">Input</span> <span class="ow">-&gt;</span>
</span></span><span class="line"><span class="cl">       <span class="n">pure</span> <span class="n">unit</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="kt">Nop</span> <span class="ow">-&gt;</span>
</span></span><span class="line"><span class="cl">       <span class="n">pure</span> <span class="n">unit</span>
</span></span></code></pre></div><p>この時点で<code>spago repl</code>してみて、正常に動くか確認する。とはいえ命令はまだ何も実装していないため、
ただ<code>iptr</code>が動くだけのプログラムとなっている。</p>
<pre class="cui">
> import Brainfuck
> import Brainfuck.Program
> runDefault (fromString "++-->><<")
{ result: (Right unit), state: { dptr: 0, iptr: 8, memory: [0,0,0,0,0,0,0,0,0,0] } }
</pre>

<h2 id="各々のコマンドの実装">各々のコマンドの実装</h2>
<p><code>src/Brainfuck/Interp/Command.purs</code>にて、以下のimport文を追記。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Brainfuck.Interp.Util</span> <span class="p">(</span><span class="nf">incInstPtr</span><span class="p">,</span> <span class="nf">decInstPtr</span><span class="p">,</span> <span class="nf">readCommandOrFail</span><span class="p">,</span> <span class="nf">readDataOrFail</span><span class="p">,</span> <span class="nf">modifyDataOrFail</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Brainfuck.State</span> <span class="p">(</span><span class="nf">modifyDataPtr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Control.Monad.State.Class</span> <span class="p">(</span><span class="nf">modify_</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="gt-と-lt">&lsquo;&gt;&rsquo; と &lsquo;&lt;&rsquo;</h3>
<p>まず<code>incDataPtr</code>と<code>decDataPtr</code>を作成。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">incDataPtr</span> <span class="ow">::</span> <span class="kt">Interp</span> <span class="kt">Unit</span>
</span></span><span class="line"><span class="cl"><span class="nf">incDataPtr</span> <span class="ow">=</span> <span class="n">modify_</span> <span class="o">$</span> <span class="n">modifyDataPtr</span> <span class="p">(</span><span class="kr">_</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">decDataPtr</span> <span class="ow">::</span> <span class="kt">Interp</span> <span class="kt">Unit</span>
</span></span><span class="line"><span class="cl"><span class="nf">decDataPtr</span> <span class="ow">=</span> <span class="n">modify_</span> <span class="o">$</span> <span class="n">modifyDataPtr</span> <span class="p">(</span><span class="kr">_</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span></code></pre></div><p><code>interpCommand</code>に追加。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">interpCommand</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">  <span class="kr">case</span> <span class="kr">_</span> <span class="kr">of</span>
</span></span><span class="line"><span class="cl">    <span class="kt">IncPtr</span> <span class="ow">-&gt;</span> 
</span></span><span class="line"><span class="cl">      <span class="n">incDataPtr</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">DecPtr</span> <span class="ow">-&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">decDataPtr</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">-- 略</span>
</span></span></code></pre></div><p>REPLで動かしてみる。 <code>dptr</code>の値がちゃんと2になってくれている。</p>
<pre class="cui">
> runDefault $ fromString ">>>>><<<"
{ result: (Right unit), state: { dptr: 2, iptr: 8, memory: [0,0,0,0,0,0,0,0,0,0] } }
</pre>

<h3 id="-と--">&lsquo;+&rsquo; と &lsquo;-&rsquo;</h3>
<p><code>incData</code>、<code>decData</code>を作成。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">incData</span> <span class="ow">::</span> <span class="kt">Interp</span> <span class="kt">Unit</span>
</span></span><span class="line"><span class="cl"><span class="nf">incData</span> <span class="ow">=</span> <span class="n">modifyDataOrFail</span> <span class="p">(</span><span class="kr">_</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">decData</span> <span class="ow">::</span> <span class="kt">Interp</span> <span class="kt">Unit</span>
</span></span><span class="line"><span class="cl"><span class="nf">decData</span> <span class="ow">=</span> <span class="n">modifyDataOrFail</span> <span class="p">(</span><span class="kr">_</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span></code></pre></div><p><code>interpCommand</code>に追加。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">interpCommand</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">  <span class="kr">case</span> <span class="kr">_</span> <span class="kr">of</span>
</span></span><span class="line"><span class="cl">    <span class="c1">-- 略 </span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">IncDat</span> <span class="ow">-&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">incData</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">DecDat</span> <span class="ow">-&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">decData</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">-- 略 </span>
</span></span></code></pre></div><p>REPLで動作確認。</p>
<pre class="cui">
> runDefault $ fromString "+>++>+++<->>++++"
{ result: (Right unit), state: { dptr: 3, iptr: 16, memory: [1,1,3,4,0,0,0,0,0,0] } }
</pre>

<h3 id="-と-">&lsquo;[&rsquo; と &lsquo;]&rsquo;</h3>
<p><code>[</code>命令、<code>]</code>命令の処理を実装。
<code>goToLBrace</code>と<code>goToRBrace</code>というのが、対応する括弧に移動する関数となる。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">interpCommand</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">  <span class="kr">case</span> <span class="kr">_</span> <span class="kr">of</span>
</span></span><span class="line"><span class="cl">    <span class="c1">-- 略</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">LBrace</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
</span></span><span class="line"><span class="cl">      <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">readDataOrFail</span>
</span></span><span class="line"><span class="cl">      <span class="n">when</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">goToRBrace</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">RBrace</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
</span></span><span class="line"><span class="cl">      <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">readDataOrFail</span>
</span></span><span class="line"><span class="cl">      <span class="n">when</span> <span class="p">(</span><span class="n">x</span> <span class="o">/=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">goToLBrace</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">-- 略</span>
</span></span></code></pre></div><p><code>goToLBrace</code>と<code>goToRBrace</code>は前に進めるか前に進めるかの違いしかないので、共通の関数<code>goToMate</code>に任せる。
進め方を<code>goToMate</code>の第1引数に指定。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">goToRBrace</span> <span class="ow">::</span> <span class="kt">Interp</span> <span class="kt">Unit</span>
</span></span><span class="line"><span class="cl"><span class="nf">goToRBrace</span> <span class="ow">=</span> <span class="n">goToMate</span> <span class="n">incInstPtr</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">goToLBrace</span> <span class="ow">::</span> <span class="kt">Interp</span> <span class="kt">Unit</span>
</span></span><span class="line"><span class="cl"><span class="nf">goToLBrace</span> <span class="ow">=</span> <span class="n">goToMate</span> <span class="n">decInstPtr</span>
</span></span></code></pre></div><p><code>goToMate</code>を作成。ここは設計とは別種の、アルゴリズム的な難しさが(多少)ある。
通り過ぎた括弧の数を<code>cnt</code>でカウントする。<code>[</code>が来た時は<code>cnt + 1</code>、<code>]</code>が来た時は<code>cnt - 1</code>する。
<code>cnt</code>が0になった地点が、対応する括弧となる。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">goToMate</span> <span class="ow">::</span> <span class="kt">Interp</span> <span class="kt">Unit</span> <span class="ow">-&gt;</span> <span class="kt">Interp</span> <span class="kt">Unit</span>
</span></span><span class="line"><span class="cl"><span class="nf">goToMate</span> <span class="n">move</span> <span class="ow">=</span> <span class="n">go</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">  <span class="kr">where</span>
</span></span><span class="line"><span class="cl">    <span class="n">go</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Interp</span> <span class="kt">Unit</span>
</span></span><span class="line"><span class="cl">    <span class="n">go</span> <span class="n">cnt</span> <span class="ow">=</span> <span class="kr">do</span>
</span></span><span class="line"><span class="cl">      <span class="n">cmd</span> <span class="ow">&lt;-</span> <span class="n">readCommandOrFail</span>
</span></span><span class="line"><span class="cl">      <span class="kr">let</span> <span class="n">newCnt</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">            <span class="kr">case</span> <span class="n">cmd</span> <span class="kr">of</span>
</span></span><span class="line"><span class="cl">              <span class="kt">LBrace</span> <span class="ow">-&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">              <span class="kt">RBrace</span> <span class="ow">-&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="n">cnt</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">              <span class="kr">_</span> <span class="ow">-&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="n">cnt</span>
</span></span><span class="line"><span class="cl">      <span class="kr">if</span> <span class="n">newCnt</span> <span class="o">==</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="kr">then</span>
</span></span><span class="line"><span class="cl">          <span class="n">pure</span> <span class="n">unit</span>
</span></span><span class="line"><span class="cl">        <span class="kr">else</span> <span class="kr">do</span>
</span></span><span class="line"><span class="cl">          <span class="n">move</span>
</span></span><span class="line"><span class="cl">          <span class="n">go</span> <span class="n">newCnt</span>
</span></span></code></pre></div><p>REPLで動作確認。</p>
<pre class="cui">
> runDefault $ fromString "++++[>+++++<-]"
{ result: (Right unit), state: { dptr: 0, iptr: 14, memory: [0,20,0,0,0,0,0,0,0,0] } }
> runDefault $ fromString "+++>[foofoo]---"
{ result: (Right unit), state: { dptr: 1, iptr: 15, memory: [3,-3,0,0,0,0,0,0,0,0] } }
</pre>

<h2 id="次回">次回</h2>
<p>まだHello, Worldすら出力できないBrainfuckだが、
入出力の扱いは長くなるので次の記事に回す。</p>

</article>



</html>
