<!DOCTYPE html>
<html lang="ja-jp">
<title>PureScriptメモ - Generics | Chanomic Blog</title>
<meta charset="utf-8">
<meta name="generator" content="Hugo 0.80.0" />


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-152083322-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-152083322-1');
</script>



<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="canonical" href="https://bombrary.github.io/blog/posts/purescript-note-generics/">
<link rel="alternate" type="application/rss+xml" href="" title="Chanomic Blog">
<link rel="stylesheet" href="https://bombrary.github.io/blog/css/theme.css">
<link rel="stylesheet" href="https://bombrary.github.io/blog/css/classes.css">
<link rel="stylesheet" href="https://bombrary.github.io/blog/css/syntax.css">


<header class="dark">
  <h2><a href="https://bombrary.github.io/blog/">Chanomic Blog</a></h2>
  <nav>
    
  </nav>
</header>


<article>
  <header>
    <h1><a href="https://bombrary.github.io/blog/posts/purescript-note-generics/">PureScriptメモ - Generics</a></h1>
    <div class="meta">
      
      <div class="pub-date">
        <time datetime="2020-11-03T13:17:39&#43;09:00">November 03, 2020</time>
      </div>
      
      
      <div class="lastmod-date">
        <div class="lastmod-date__label">(last modified:</div>
        <time datetime="2020-11-03T13:17:39&#43;09:00">November 06, 2020</time>
        <div class="lastmod-date__label">)</div>
      </div>
      
    </div>
    
    <div class="tags-categories">
      <div class="tags">
        <p>tags: </p>
        <ul class="tags_list">
          <li class="tags_item"><a href="https://bombrary.github.io/blog//tags/%e3%82%b8%e3%82%a7%e3%83%8d%e3%83%aa%e3%83%83%e3%82%af%e3%83%97%e3%83%ad%e3%82%b0%e3%83%a9%e3%83%9f%e3%83%b3%e3%82%b0/">ジェネリックプログラミング</a></li><li class="tags_item"><a href="https://bombrary.github.io/blog//tags/generics/">Generics</a></li>
        </ul>
        
      </div>
      <div class="categories">
        <p>categories: </p>
        
        <ul class="categories_list">
           <li class="tags_item"><a href="https://bombrary.github.io/blog//categories/purescript/">PureScript</a></li>
        </ul>
        
      </div>
    </div>
  </header>
  
    <aside>
      <h2>目次</h2>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#準備">準備</a></li>
    <li><a href="#serializer">Serializer</a></li>
    <li><a href="#tree型をserializer型クラスのインスタンスにする素朴な方法">Tree型をSerializer型クラスのインスタンスにする(素朴な方法)</a></li>
    <li><a href="#一般化">一般化</a></li>
    <li><a href="#datagenericrep">Data.Generic.Rep</a>
      <ul>
        <li><a href="#generic型クラス">Generic型クラス</a></li>
        <li><a href="#表現の構成要素">表現の構成要素</a></li>
        <li><a href="#応用例showクラスのインスタンスにする">応用例：Showクラスのインスタンスにする</a></li>
        <li><a href="#補足showクラスのインスタンス化に関する注意点">補足：Showクラスのインスタンス化に関する注意点</a></li>
      </ul>
    </li>
    <li><a href="#本題tree型をserializer型クラスのインスタンスにする表現を利用する方法">本題：Tree型をSerializer型クラスのインスタンスにする(表現を利用する方法)</a>
      <ul>
        <li><a href="#補足tree以外の型をserializer型クラスのインスタンスにする">補足：Tree以外の型をSerializer型クラスのインスタンスにする</a></li>
      </ul>
    </li>
    <li><a href="#参考文献">参考文献</a>
      <ul>
        <li><a href="#haskell方面">Haskell方面</a></li>
        <li><a href="#purescript方面">PureScript方面</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </aside>
    
  <p>purescript-generics-repパッケージを使ってGenericな<code>Serializer</code>型クラスを作った。以下はそのメモ。</p>
<h2 id="準備">準備</h2>
<p>プロジェクトを作成。</p>
<pre class="cui">
$ spago init
</pre>

<p>Arrayを使うので、パッケージをインストールして<code>src/Main.purs</code>にimport文を書き込んでいく。
本記事の本命であるgenerics-rep入れる。
<pre class="cui">
$ spago install arrays
$ spago install generics-rep
</pre>
</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">import</span> <span class="nn">Data.Array</span> <span class="p">((</span><span class="o">:</span><span class="p">))</span>
</code></pre></div><p>REPLで色々実験するので、あらかじめ起動しておく。
<pre class="cui">
$ spago repl
> import Main
</pre>
</p>
<p>以降は<code>src/Main.purs</code>に色々書き足していく。REPLで<code>:r</code>(もしくは<code>:reload</code>)とコマンドを打てばモジュールが再読み込みされるので、<code>src/Main.purs</code>を書き換える度にこのコマンドを打つと良い。</p>
<h2 id="serializer">Serializer</h2>
<p>そもそもSerializerとは何か。ここでは単に「データをビット列に変換するもの」程度の意味で捉えれば良い。
厳密にはJSONなどの階層を持つデータを，文字列などの平坦なデータに変換するという意味合いとしてシリアライズ(直列化)という言葉を使う。実際、本記事では最終的に木構造をシリアライズする。</p>
<p>まずビットは次のように定義する。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">Bit</span> <span class="ow">=</span> <span class="kt">O</span> <span class="o">|</span> <span class="kt">I</span>

<span class="kr">instance</span> <span class="n">showBit</span> <span class="ow">::</span> <span class="kt">Show</span> <span class="kt">Bit</span> <span class="kr">where</span>
  <span class="n">show</span> <span class="kt">O</span> <span class="ow">=</span> <span class="s">&#34;O&#34;</span>
  <span class="n">show</span> <span class="kt">I</span> <span class="ow">=</span> <span class="s">&#34;I&#34;</span>
</code></pre></div><p><code>Serializer</code>型クラスを以下のように定義する。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">class</span> <span class="kt">Serializer</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">serialize</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="kt">Bit</span>
</code></pre></div><p>試しに適当な型をつくり、それを<code>Serializer</code>型クラスのインスタンスにしてみる。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">Person</span> <span class="ow">=</span> <span class="kt">Alice</span> <span class="o">|</span> <span class="kt">Bob</span> <span class="o">|</span> <span class="kt">Carol</span>

<span class="kr">instance</span> <span class="n">serializerUser</span> <span class="ow">::</span> <span class="kt">Serializer</span> <span class="kt">Person</span> <span class="kr">where</span>
  <span class="n">serialize</span> <span class="kt">Alice</span> <span class="ow">=</span> <span class="p">[</span> <span class="kt">I</span> <span class="p">]</span>
  <span class="n">serialize</span> <span class="kt">Bob</span>   <span class="ow">=</span> <span class="p">[</span> <span class="kt">O</span><span class="p">,</span> <span class="kt">I</span> <span class="p">]</span>
  <span class="n">serialize</span> <span class="kt">Carol</span> <span class="ow">=</span> <span class="p">[</span> <span class="kt">O</span><span class="p">,</span> <span class="kt">O</span><span class="p">,</span> <span class="kt">I</span> <span class="p">]</span>
</code></pre></div><p>余談。今回はデシリアライザは実装しないので、シリアライズしたデータを同じ形に戻せるかは考えない。このあたりは情報理論の授業で「一意復号化可能性」などをやった気がするけど、忘れてしまった。</p>
<p>REPLで実験してみる。</p>
<pre class="cui">
> serialize Alice
[I]

> serialize Bob
[O,I]

> serialize Carol
[O,O,I]
</pre>

<h2 id="tree型をserializer型クラスのインスタンスにする素朴な方法">Tree型をSerializer型クラスのインスタンスにする(素朴な方法)</h2>
<p>2分木のデータ構造である<code>Tree</code>型を作る。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="o">|</span> <span class="kt">Leaf</span> <span class="n">a</span>

<span class="kr">instance</span> <span class="n">serializerTree</span> <span class="ow">::</span> <span class="kt">Serializer</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Serializer</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">serialize</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">l</span> <span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">I</span> <span class="kt">:</span> <span class="p">(</span><span class="n">serialize</span> <span class="n">l</span> <span class="o">&lt;&gt;</span> <span class="n">serialize</span> <span class="n">r</span><span class="p">)</span>
  <span class="n">serialize</span> <span class="p">(</span><span class="kt">Leaf</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">O</span> <span class="kt">:</span> <span class="n">serialize</span> <span class="n">x</span>
</code></pre></div><p>テスト用のデータを作ってREPLでシリアライズしてみる。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">tree</span> <span class="ow">::</span> <span class="kt">Tree</span> <span class="kt">Person</span>
<span class="nf">tree</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="p">(</span><span class="kt">Node</span> <span class="p">(</span><span class="kt">Leaf</span> <span class="kt">Alice</span><span class="p">)</span> <span class="p">(</span><span class="kt">Leaf</span> <span class="kt">Bob</span><span class="p">))</span> <span class="p">(</span><span class="kt">Leaf</span> <span class="kt">Carol</span><span class="p">)</span>
</code></pre></div><pre class="cui">
> serialize tree
[I,I,O,I,O,O,I,O,O,O,I]
</pre>

<h2 id="一般化">一般化</h2>
<p>さて、3分木なら例えば次のように<code>Serializer</code>型クラスのインスタンスにできる。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="o">|</span> <span class="kt">Leaf</span> <span class="n">a</span>

<span class="kr">instance</span> <span class="n">serializerTree</span> <span class="ow">::</span> <span class="kt">Serializer</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Serializer</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">serialize</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">n1</span> <span class="n">n2</span> <span class="n">n3</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">I</span> <span class="kt">:</span> <span class="p">(</span><span class="n">serialize</span> <span class="n">n1</span> <span class="o">&lt;&gt;</span> <span class="n">serialize</span> <span class="n">n2</span> <span class="o">&lt;&gt;</span> <span class="n">serialize</span> <span class="n">n3</span><span class="p">)</span>
  <span class="n">serialize</span> <span class="p">(</span><span class="kt">Leaf</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">O</span> <span class="kt">:</span> <span class="n">serialize</span> <span class="n">x</span>
</code></pre></div><p>木に限らず、有名な型については例えば次のようにインスタンスにできるだろう。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">instance</span> <span class="n">serializerMaybe</span> <span class="ow">::</span> <span class="kt">Serializer</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Serializer</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">serialize</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">I</span> <span class="kt">:</span> <span class="n">serialize</span> <span class="n">x</span>
  <span class="n">serialize</span> <span class="kt">Nothing</span>  <span class="ow">=</span> <span class="kt">[]</span>

<span class="kr">instance</span> <span class="n">serializerEither</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Serializer</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Serializer</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Serializer</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">serialize</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">x</span><span class="p">)</span>  <span class="ow">=</span> <span class="kt">I</span> <span class="kt">:</span> <span class="n">serialize</span> <span class="n">x</span>
  <span class="n">serialize</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">y</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">O</span> <span class="kt">:</span> <span class="n">serialize</span> <span class="n">y</span>

<span class="kr">instance</span> <span class="n">serializerList</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Serializer</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Serializer</span> <span class="p">(</span><span class="kt">List</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">serialize</span> <span class="p">(</span><span class="kt">Cons</span> <span class="n">x</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">I</span> <span class="kt">:</span> <span class="n">serialize</span> <span class="n">x</span> <span class="o">&lt;&gt;</span> <span class="n">serialize</span> <span class="n">xs</span>
  <span class="n">serialize</span> <span class="kt">Nil</span>  <span class="ow">=</span> <span class="kt">[]</span>
</code></pre></div><p>3つの値を持つデータ型なら例えば次のようにできる。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">T0</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">=</span> <span class="kt">One</span> <span class="n">a</span> <span class="n">b</span> <span class="o">|</span> <span class="kt">Two</span> <span class="n">b</span> <span class="o">|</span> <span class="kt">Three</span> <span class="n">c</span> <span class="n">b</span> <span class="n">a</span>

<span class="kr">instance</span> <span class="n">serializerT0</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Serializer</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Serializer</span> <span class="n">b</span><span class="p">,</span> <span class="kt">Serializer</span> <span class="n">c</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Serializer</span> <span class="p">(</span><span class="kt">T0</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">serialize</span> <span class="p">(</span><span class="kt">One</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">I</span> <span class="kt">:</span> <span class="p">(</span><span class="n">serialize</span> <span class="n">x</span> <span class="o">&lt;&gt;</span> <span class="n">serialize</span> <span class="n">y</span><span class="p">)</span>
  <span class="n">serialize</span> <span class="p">(</span><span class="kt">Two</span> <span class="n">x</span><span class="p">)</span>   <span class="ow">=</span> <span class="kt">O</span> <span class="kt">:</span> <span class="kt">I</span> <span class="kt">:</span> <span class="n">serialize</span> <span class="n">x</span>
  <span class="n">serialize</span> <span class="p">(</span><span class="kt">Three</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">O</span> <span class="kt">:</span> <span class="kt">O</span> <span class="kt">:</span> <span class="kt">I</span> <span class="kt">:</span> <span class="p">(</span><span class="n">serialize</span> <span class="n">x</span> <span class="o">&lt;&gt;</span> <span class="n">serialize</span> <span class="n">y</span> <span class="o">&lt;&gt;</span> <span class="n">serialize</span> <span class="n">z</span><span class="p">)</span>
</code></pre></div><p>上の例はアドホックなものであり、実装そのものに共通点はない。ただし、実装する上での気持ち「<strong>データの値ではなくデータの表現に注目する</strong>」では共通している。
ここでいう表現というのは、たとえば3つ目の例でいうと、</p>
<p><code>One</code>と<code>Two</code>と<code>Three</code>という値を持ち，</p>
<ul>
<li><code>One</code>は<code>a</code>型の値と<code>b</code>型の値を引数に持つ。</li>
<li><code>Two</code>は<code>b</code>型の値を引数を持つ。</li>
<li><code>Three</code>は<code>c</code>型の値，<code>b</code>型の値，<code>a</code>型の値を引数に持つ。</li>
</ul>
<p>が<code>T0</code>の持つ表現である。</p>
<p>そのような、データの表現に応じてシリアライズの仕方を実装することができれば、いちいち<code>Maybe</code>や<code>Either</code>や<code>T0</code>など個別に<code>Serializer</code>型クラスのインスタンス宣言を書かずに済む。
それを可能にするのが、purescript-generics-repパッケージである。これは、データ型の持つ表現そのものを型にする手段を提供する。</p>
<h2 id="datagenericrep">Data.Generic.Rep</h2>
<p>モジュールをインポートする。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">import</span> <span class="nn">Data.Generic.Rep</span>
</code></pre></div><h3 id="generic型クラス">Generic型クラス</h3>
<p><code>Generic</code>型クラスのインスタンスを導出させることで、<code>Tree</code>の表現が生成される。アンダーバーはコンパイラが自動で埋めてくれる。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">derive</span> <span class="kr">instance</span> <span class="n">genericTree</span> <span class="ow">::</span> <span class="kt">Generic</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="kr">_</span>
</code></pre></div><p><a href="https://pursuit.purescript.org/packages/purescript-generics-rep/6.1.1/docs/Data.Generic.Rep">ドキュメント</a>によると、<code>Generic</code>型クラスは次のように定義されている。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">class</span> <span class="kt">Generic</span> <span class="n">a</span> <span class="n">rep</span> <span class="o">|</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">rep</span> <span class="kr">where</span>
  <span class="n">to</span> <span class="ow">::</span> <span class="n">rep</span> <span class="ow">-&gt;</span> <span class="n">a</span>
  <span class="n">from</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">rep</span>
</code></pre></div><p><code>rep</code>が、型<code>a</code>の表現を表す(<code>rep</code>というのは、恐らく<em>representation</em>(表現)の略)。<code>from</code>を使えば、<code>a</code>の表現が得られる。REPLで<code>Tree</code>の表現の型を確認してみる。
<pre class="cui">
> import Data.Generic.Rep
> :t from tree
Sum (Constructor "Node" (Product (Argument (Tree Person)) (Argument (Tree Person)))) (Constructor "Leaf" (Argument Person))
</pre>
</p>
<p>なので実際には、アンダーバーのところを埋めると次のようになるようだ(ただし、必ずアンダーバーでなければならないようで、これはコンパイルエラーになる)。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">derive</span> <span class="kr">instance</span> <span class="n">genericTree</span>
  <span class="ow">::</span> <span class="kt">Generic</span>
       <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span>
       <span class="p">(</span><span class="kt">Sum</span> <span class="p">(</span><span class="kt">Constructor</span> <span class="s">&#34;Node&#34;</span> <span class="p">(</span><span class="kt">Product</span> <span class="p">(</span><span class="kt">Argument</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">))</span>
                                         <span class="p">(</span><span class="kt">Argument</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">))))</span>
            <span class="p">(</span><span class="kt">Constructor</span> <span class="s">&#34;Leaf&#34;</span> <span class="p">(</span><span class="kt">Argument</span> <span class="n">a</span><span class="p">)))</span>
</code></pre></div><h3 id="表現の構成要素">表現の構成要素</h3>
<p>表現が構成する型は次の4つ。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">Sum</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Inl</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Inr</span> <span class="n">b</span>
<span class="kr">data</span> <span class="kt">Constructor</span> <span class="p">(</span><span class="n">name</span> <span class="ow">::</span> <span class="kt">Symbol</span><span class="p">)</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Constructor</span> <span class="n">a</span>
<span class="kr">data</span> <span class="kt">Product</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Product</span> <span class="n">a</span> <span class="n">b</span>
<span class="kr">data</span> <span class="kt">Argument</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Argument</span> <span class="n">a</span>
<span class="kr">data</span> <span class="kt">NoConstructors</span>
<span class="kr">data</span> <span class="kt">NoArguments</span> <span class="ow">=</span> <span class="kt">NoArguments</span>
</code></pre></div><ul>
<li><code>Sum</code>は直和型を表現する型。</li>
<li><code>Product</code>は直積型を表現する型。</li>
<li><code>Constructor name a</code>は値コンストラクタを表現する型。</li>
<li><code>Argument</code>は値コンストラクタの引数を表現する型。</li>
<li><code>NoConstructors</code>はコンストラクタが存在しないことを表現する型。</li>
<li><code>NoArguments</code>は値コンストラクタの引数が存在しないことを表現する型。</li>
</ul>
<p>であることを踏まえると、</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="p">(</span><span class="kt">Sum</span> <span class="p">(</span><span class="kt">Constructor</span> <span class="s">&#34;Node&#34;</span> <span class="p">(</span><span class="kt">Product</span> <span class="p">(</span><span class="kt">Argument</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">))</span>
                                  <span class="p">(</span><span class="kt">Argument</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">))))</span>
     <span class="p">(</span><span class="kt">Constructor</span> <span class="s">&#34;Leaf&#34;</span> <span class="p">(</span><span class="kt">Argument</span> <span class="n">a</span><span class="p">)))</span>
</code></pre></div><p>は、次のように読める：この型は2つのコンストラクタがあることを表現している。1つ目の値コンストラクタ名は<code>Node</code>で、その引数として<code>Tree a</code>型の値を2つ持つ。
2つめの値コンストラクタ名は<code>Leaf</code>で、その引数として<code>a</code>型の値を1つ持つ。</p>
<p>ちなみに<code>derive</code>を使わないで<code>Tree</code>についてのインスタンス宣言をすると次のようになる。勿論<code>derive</code>を使えばいい話なので、普通こんなことはやらない。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">instance</span> <span class="n">genericTree</span>
  <span class="ow">::</span> <span class="kt">Generic</span>
       <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span>
       <span class="p">(</span><span class="kt">Sum</span> <span class="p">(</span><span class="kt">Constructor</span> <span class="s">&#34;Node&#34;</span> <span class="p">(</span><span class="kt">Product</span> <span class="p">(</span><span class="kt">Argument</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">))</span>
                                         <span class="p">(</span><span class="kt">Argument</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">))))</span>
            <span class="p">(</span><span class="kt">Constructor</span> <span class="s">&#34;Leaf&#34;</span> <span class="p">(</span><span class="kt">Argument</span> <span class="n">a</span><span class="p">)))</span>
  <span class="kr">where</span>
    <span class="n">to</span> <span class="p">(</span><span class="kt">Inl</span> <span class="p">(</span><span class="kt">Constructor</span> <span class="p">(</span><span class="kt">Product</span> <span class="p">(</span><span class="kt">Argument</span> <span class="n">l</span><span class="p">)</span> <span class="p">(</span><span class="kt">Argument</span> <span class="n">r</span><span class="p">))))</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="n">l</span> <span class="n">r</span>
    <span class="n">to</span> <span class="p">(</span><span class="kt">Inr</span> <span class="p">(</span><span class="kt">Constructor</span> <span class="p">(</span><span class="kt">Argument</span> <span class="n">x</span><span class="p">)))</span> <span class="ow">=</span> <span class="kt">Leaf</span> <span class="n">x</span>
    <span class="n">from</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">l</span> <span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Inl</span> <span class="p">(</span><span class="kt">Constructor</span> <span class="p">(</span><span class="kt">Product</span> <span class="p">(</span><span class="kt">Argument</span> <span class="n">l</span><span class="p">)</span> <span class="p">(</span><span class="kt">Argument</span> <span class="n">r</span><span class="p">)))</span>
    <span class="n">from</span> <span class="p">(</span><span class="kt">Leaf</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Inr</span> <span class="p">(</span><span class="kt">Constructor</span> <span class="p">(</span><span class="kt">Argument</span> <span class="n">x</span><span class="p">))</span>
</code></pre></div><h3 id="応用例showクラスのインスタンスにする">応用例：Showクラスのインスタンスにする</h3>
<p>PureScriptでは、Haskellと違って、<code>Show</code>型クラスのインスタンス導出ができない(<a href="https://github.com/purescript/documentation/blob/master/language/Type-Classes.md#type-class-deriving">参考</a>)。しかし代わりに、<code>Generic</code>型クラスを利用すれば、導出と同じようなことができる。</p>
<p>まずは、関連モジュールをインポートする。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">import</span> <span class="nn">Data.Generic.Rep.Show</span>
</code></pre></div><p>試しに、<code>Person</code>型を<code>Show</code>型クラスのインスタンスにしてみる。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">derive</span> <span class="kr">instance</span> <span class="n">genericPerson</span> <span class="ow">::</span> <span class="kt">Generic</span> <span class="kt">Person</span> <span class="kr">_</span>
<span class="kr">instance</span> <span class="n">showPerson</span> <span class="ow">::</span> <span class="kt">Show</span> <span class="kt">Person</span> <span class="kr">where</span>
  <span class="n">show</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">genericShow</span> <span class="n">x</span>
</code></pre></div><p><code>genericShow</code>は、<code>Person</code>の表現をもとに値を文字列に変換する関数。単に<code>Person</code>を<code>Generic</code>型クラスのインスタンスにするだけで利用できる。</p>
<pre class="cui">
> Alice
Alice

> Bob
Bob

> Carol
Carol
</pre>

<p><code>Tree</code>も同様に<code>Show</code>型クラスのインスタンスにできる。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">instance</span> <span class="n">showTree</span> <span class="ow">::</span> <span class="kt">Show</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">show</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">genericShow</span> <span class="n">x</span>
</code></pre></div><pre class="cui">
> tree
(Node (Node (Leaf Alice) (Leaf Bob)) (Leaf Carol))
</pre>

<p><a href="https://github.com/purescript/purescript-generics-rep/blob/v6.1.1/src/Data/Generic/Rep/Show.purs">Data.Generic.Rep.Showのコード</a>を読んでみると、どうやって表現を使って実装するのかがよく分かる。</p>
<h3 id="補足showクラスのインスタンス化に関する注意点">補足：Showクラスのインスタンス化に関する注意点</h3>
<p>次のように書くと、<code>show</code>関数を呼び出した際に実行時エラー：<code>Maximum call stack size exceeded</code>起こす。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">instance</span> <span class="n">showTree</span> <span class="ow">::</span> <span class="kt">Show</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">show</span> <span class="ow">=</span> <span class="n">genericShow</span>
</code></pre></div><p><code>show x = genericShow x</code>も<code>show = genericShow</code>も本質的には同じ意味なのに、前者はうまくいき、後者は実行時エラーを吐くのはおかしい。</p>
<p>この問題について<a href="https://github.com/purescript/purescript-generics-rep/issues/23">generics-repのissue</a>や<a href="https://github.com/purescript/purescript/issues/3807">purescriptのissue</a>でも上がっている。
後者のissueではClosedになってしまっているようだし、修正されないのだろうか。単に<code>show x = genericShow x</code>と書けば防げる問題なので、そこまで大した問題ではないのかもしれないが…。</p>
<h2 id="本題tree型をserializer型クラスのインスタンスにする表現を利用する方法">本題：Tree型をSerializer型クラスのインスタンスにする(表現を利用する方法)</h2>
<p><a href="https://github.com/purescript/purescript-generics-rep/blob/v6.1.1/src/Data/Generic/Rep/Show.purs#L14-L15">Data.Generic.Rep.Showのコード</a>の手法を真似て、次のように作る。</p>
<ul>
<li>表現をシリアライズする型クラスは<code>Serializer'</code>が担う。</li>
<li><code>Tree</code>や<code>Person</code>などの普通の値をシリアライズする型クラスは<code>Serializer</code>が担う。</li>
</ul>
<p>そこで、<code>Serializer'</code>型クラスを作る。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">class</span> <span class="kt">Serializer&#39;</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">serialize&#39;</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="kt">Bit</span>
</code></pre></div><p>表現に関連する部分は全て<code>Serializer'</code>型クラスのインスタンスにする。最後の<code>Argument</code>だけ、引数に普通の型が含まれているため、型クラス制約が<code>Serializer'</code>ではなく<code>Serializer</code>であることに注意。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">instance</span> <span class="n">serializerSum</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Serializer&#39;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Serializer&#39;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Serializer&#39;</span> <span class="p">(</span><span class="kt">Sum</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">serialize&#39;</span> <span class="p">(</span><span class="kt">Inl</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">I</span> <span class="kt">:</span> <span class="n">serialize&#39;</span> <span class="n">x</span>
  <span class="n">serialize&#39;</span> <span class="p">(</span><span class="kt">Inr</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">O</span> <span class="kt">:</span> <span class="n">serialize&#39;</span> <span class="n">x</span>

<span class="kr">instance</span> <span class="n">serializerConstructor</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Serializer&#39;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Serializer&#39;</span> <span class="p">(</span><span class="kt">Constructor</span> <span class="n">name</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">serialize&#39;</span> <span class="p">(</span><span class="kt">Constructor</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="n">serialize&#39;</span> <span class="n">x</span>

<span class="kr">instance</span> <span class="n">serializerProduct</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Serializer&#39;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Serializer&#39;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Serializer&#39;</span> <span class="p">(</span><span class="kt">Product</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">serialize&#39;</span> <span class="p">(</span><span class="kt">Product</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="ow">=</span> <span class="n">serialize&#39;</span> <span class="n">x</span> <span class="o">&lt;&gt;</span> <span class="n">serialize&#39;</span> <span class="n">y</span>

<span class="kr">instance</span> <span class="n">serializerNoArguments</span> <span class="ow">::</span> <span class="kt">Serializer&#39;</span> <span class="kt">NoArguments</span> <span class="kr">where</span>
  <span class="n">serialize&#39;</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">[]</span>

<span class="kr">instance</span> <span class="n">serializerArgument</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Serializer</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Serializer&#39;</span> <span class="p">(</span><span class="kt">Argument</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">serialize&#39;</span> <span class="p">(</span><span class="kt">Argument</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="n">serialize</span> <span class="n">x</span>
</code></pre></div><p>最後に、<code>serialize'</code>を使って<code>Tree</code>を<code>Serializer</code>型クラスのインスタンスにする。<a href="#tree%E5%9E%8B%E3%82%92serializer%E5%9E%8B%E3%82%AF%E3%83%A9%E3%82%B9%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%82%BF%E3%83%B3%E3%82%B9%E3%81%AB%E3%81%99%E3%82%8B%E7%B4%A0%E6%9C%B4%E3%81%AA%E6%96%B9%E6%B3%95">前に作成したインスタンス宣言</a>は消す。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">instance</span> <span class="n">serializerTree</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Serializer</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Serializer</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">serialize</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">serialize&#39;</span> <span class="o">$</span> <span class="n">from</span> <span class="n">x</span>
</code></pre></div><p>素朴に作った場合と同じ結果が出ている。</p>
<pre class="cui">
> serialize tree
[I,I,O,I,O,O,I,O,O,O,I]
</pre>

<p><strong>Tree型の値そのものに注目せずにSerializerが実装できた</strong>ことに注目してほしい。<code>Tree a</code>に限らず、例えば型<code>T0 a b c</code>があったとき、</p>
<ul>
<li><code>T0</code>は<code>Generic</code>型クラスのインスタンスである</li>
<li><code>a, b, c</code>は<code>Serializer</code>型クラスのインスタンスである</li>
</ul>
<p>という2つの条件が揃えば、<code>T0</code>はシリアライズできることになる。</p>
<h3 id="補足tree以外の型をserializer型クラスのインスタンスにする">補足：Tree以外の型をSerializer型クラスのインスタンスにする</h3>
<p>自作の型なら、容易に<code>Serizlizer</code>のインスタンスにできる。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">T0</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">=</span> <span class="kt">One</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Two</span> <span class="n">b</span> <span class="o">|</span> <span class="kt">Tree</span> <span class="n">c</span>

<span class="nf">derive</span> <span class="kr">instance</span> <span class="n">genericT0</span> <span class="ow">::</span> <span class="kt">Generic</span> <span class="p">(</span><span class="kt">T0</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="p">)</span> <span class="kr">_</span>

<span class="kr">instance</span> <span class="n">serializerT0</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Serializer</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Serializer</span> <span class="n">b</span><span class="p">,</span> <span class="kt">Serialier</span> <span class="n">c</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Serializer</span> <span class="p">(</span><span class="kt">T0</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">serialize</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">serialize&#39;</span> <span class="o">$</span> <span class="n">from</span> <span class="n">x</span>
</code></pre></div><p><code>Maybe a</code>に関しては特別に<code>Data.Generic.Rep</code>でインスタンス宣言がなされているため、次のように<code>Serializer</code>のインスタンスにできる。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">instance</span> <span class="n">serializerTree</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Serializer</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Serializer</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">serialize</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">serialize&#39;</span> <span class="o">$</span> <span class="n">from</span> <span class="n">x</span>
</code></pre></div><p>別モジュールで定義された型を、<code>Generic</code>を使って<code>Serializer</code>のインスタンスにすることはできない。
なぜなら、今回の場合「<code>Main</code>外で定義された型」に対して「<code>Main</code>外で定義された型クラス<code>Generic</code>」のインスタンス宣言をすることになり、これはOrphan instanceに当たるからだ
PureScriptではOrphan instanceは禁止されている(<a href="https://github.com/purescript/documentation/blob/master/language/Type-Classes.md#orphan-instances">参考</a>)。</p>
<p>この問題を解決するためにぱっと思いついた方法は、以下のようなもの。以下は<code>Either</code>を<code>Serializer</code>型クラスのインスタンスにしている。<code>Either</code>の別表現として<code>Either'</code>を用意する。
<code>Either</code>は<code>Main</code>外のモジュールで定義されているため、直接<code>Generic</code>型インスタンスにすることはできない。しかし、<code>Either'</code>は<code>Generic</code>にすることはできる。
よって、一旦<code>Either'</code>を経由して<code>Either</code>の<code>Serializer</code>インスタンス宣言をすることができる。</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">Either&#39;</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Left&#39;</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Right&#39;</span> <span class="n">b</span>

<span class="nf">fromEither</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span> <span class="n">b</span><span class="o">.</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Either&#39;</span> <span class="n">a</span> <span class="n">b</span>
<span class="nf">fromEither</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Left&#39;</span> <span class="n">x</span>
<span class="nf">fromEither</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Right&#39;</span> <span class="n">x</span>

<span class="nf">derive</span> <span class="kr">instance</span> <span class="n">genericEither&#39;</span> <span class="ow">::</span> <span class="kt">Generic</span> <span class="p">(</span><span class="kt">Either&#39;</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="kr">_</span>

<span class="kr">instance</span> <span class="n">serializerEither</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Serializer</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Serializer</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Serializer</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">serialize</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">serialize&#39;</span> <span class="o">$</span> <span class="n">from</span>  <span class="o">$</span> <span class="n">fromEither</span> <span class="n">x</span> 
</code></pre></div><p>ちなみに、最近<a href="https://github.com/purescript/purescript-generics-rep/pull/34">EitherをGenericのインスタンスにする動き</a>あるようだ。</p>
<h2 id="参考文献">参考文献</h2>
<p>本記事を書くに当たって参考にした文献を挙げておく。</p>
<h3 id="haskell方面">Haskell方面</h3>
<p>PureScriptはHaskellの影響を受けているので、Haskellの資料が参考になることは結構ある。ただし、構文や型名、パッケージ名など違いがあるので、それらについては根気強く調べる必要がある。</p>
<ul>
<li><a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/GHC-Generics.html">GHC.Genericsのドキュメント</a>：そもそも、purescript-generics-repはこれにインスパイアされて作ったもの(<a href="http://pursuit.purescript.org/packages/purescript-generics-rep">参考</a>)。</li>
<li><a href="https://wiki.haskell.org/GHC.Generics">Haskell wiki</a>：Serializerという型クラスを実装する例を与えている。</li>
<li><a href="https://blog.tiqwab.com/2017/01/09/ghc-generics.html">GHC.Genericsを利用したgeneric programming - tiqwablog</a>：日本語の文献。こちらも同様、Serializableという型クラスを実装している(名前は違うが上と同じ機能を持つ型クラス)。</li>
</ul>
<h3 id="purescript方面">PureScript方面</h3>
<p>あまり見つからなかった…。</p>
<ul>
<li><a href="http://pursuit.purescript.org/packages/purescript-generics-rep">purescript-generics-repのドキュメント</a></li>
<li><a href="https://qiita.com/asua/items/bc3c99111cf6c70d84a8">雰囲気で PureScript の Generics プログラミングを始める - Qiita</a>：日本語の文献。</li>
</ul>

</article>



</html>
