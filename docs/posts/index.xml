<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Chanomic Blog</title>
    <link>https://bombrary.github.io/blog/posts/</link>
    <description>Recent content in Posts on Chanomic Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Sat, 15 Jan 2022 18:45:40 +0900</lastBuildDate><atom:link href="https://bombrary.github.io/blog/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ニューラルネットワーク ノート - 誤差逆伝播の計算</title>
      <link>https://bombrary.github.io/blog/posts/nn-backprop/</link>
      <pubDate>Sat, 15 Jan 2022 18:45:40 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/nn-backprop/</guid>
      <description>誤差逆伝播法の数式の説明なんて世の中にたくさんあると思うが、理解のために自分でもまとめる。 特に添字などのミスがあると思うので、見つけ次第修正する。
誤差逆伝播の計算 (1) 問題設定 入力を第 $0$ 層、出力を第 $L$ 層とする。ニューラルネットワークはよく次のようなグラフで描かれる。 円がノードを表す。ノードに入っていく矢印が入力、出ていく矢印が出力を表す。
第 $l$ 層 $j$ 番目のノードの出力を $y_j^l$ とおく (注意: この記事では $y_j^{l}$ の $l$ は添字を表すものとする。累乗ではない。これから現れる変数についても同様)。これはある関数 $f_l$ を用いて以下の式で表される。$f_l$ は活性化関数と呼ばれる。 ただし、$u_j^{l}$ は前の層の出力を用いて計算される線形和で、以下のように定義される。 このような、線形和を取って $f$ を適用するという流れは次のようなグラフで描かれる。
この $\sum | f$ のノードがたくさん集まって第 $l$ 層を形成している。
損失関数 $E$ は、重み$w_{ij}^{l}$ についての関数である。これは出力値 $y_i^{L}$ と教師データ $\tilde{y}_i$ との違いを測る尺度であるから、$y_i^{L}$ の関数でもある。 例えば、以下の二乗誤差は損失関数の一種である。 定義中に $w_{ij}^{l}$ が含まれていないじゃないか、と思うかもしれないが、$y_i^{L}$ の定義中に $w_{ij}^{L}$ が含まれている。さらにその中の $y_i^{L-1}$ 中に $w_{ij}^{L-1}$ が含まれている。以下同様にして $w_{ij}^l$ は $E$ の中に含まれている。
いま、$E$ を最小化するような $w_{ij}^{l}$ を求めたい。これには確率的勾配法が利用できるが、そのために偏微分 $\displaystyle \frac{\partial E}{\partial w_{ij}^{l}}$ を計算する必要がある。以降、これをどう計算するかという話を展開していく。</description>
    </item>
    
    <item>
      <title>PureScriptでパーサーコンビネータを触る (2) テキストファイル</title>
      <link>https://bombrary.github.io/blog/posts/purescript-parser-combinator02/</link>
      <pubDate>Fri, 31 Dec 2021 15:26:00 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/purescript-parser-combinator02/</guid>
      <description>前回の記事 と合わせて1つの記事にする予定だったが、前回があまりに長くなってしまったので分割した。
ある書式に従ったテキストファイルをパースすることを考える。パースしたデータを整形し、HTML文書として出力するところまでやる。
前回インポートした関数で今回使うものは、(漏れが無ければ)以下の通り。
import Control.Alt ((&amp;lt;|&amp;gt;)) import Control.Lazy (defer) import Text.Parsing.Parser (Parser, fail) import Text.Parsing.Parser.String (char) テキストの仕様 テキストファイルは、複数のentryで構成される。 1つのentryはタイトルtitleと中身bodyで構成される。 titleは[と]でくくられる。 titleとbodyの間、bodyと次のentryのtitleの間には、1つの改行と、0個以上の空行があり得る。それらはbodyには含まない。 空行とは、0個以上のスペースだけから構成される行のことである。 BNF風に書くと次のようになるだろう。
&amp;lt;entries&amp;gt; = (0個以上の&amp;lt;entry&amp;gt;) &amp;lt;entry&amp;gt; = &amp;lt;title&amp;gt; &amp;#34;\n&amp;#34; &amp;lt;empty lines&amp;gt; &amp;lt;body&amp;gt; &amp;#34;\n&amp;#34; &amp;lt;empty lines&amp;gt; &amp;lt;title&amp;gt; = &amp;#34;[&amp;#34; (文字列) &amp;#34;]&amp;#34; &amp;lt;body&amp;gt; = (先頭、末尾が&amp;lt;empty lines&amp;gt;でないような文字列) &amp;lt;empty lines&amp;gt; = (0個以上の&amp;lt;empty line&amp;gt;) &amp;lt;empty line&amp;gt; = (0個以上のスペース) &amp;#34;\n&amp;#34; 例えば、以下のファイルがあったとする。
[Title1] line1 line2 line3 line4 [Title2] line1 line2 [Title3] line1 line2 line3 これは次のようにパースされる。</description>
    </item>
    
    <item>
      <title>PureScriptでパーサーコンビネータを触る (1) 四則演算のパース</title>
      <link>https://bombrary.github.io/blog/posts/purescript-parser-combinator01/</link>
      <pubDate>Thu, 30 Dec 2021 09:40:00 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/purescript-parser-combinator01/</guid>
      <description>PureScriptのパーサーコンビネータにpurescript-parsingがある。これはHaskellのParsecが基になっているので、使い方はParsecとほとんど同じだと思われる(とはいえ、Parsecを使ったことはあまりない)。これを用いて四則演算のパーサーを実装してみたが、うまく動かず詰まる点がいくつかあった。その備忘録。
パーサーコンビネータの準備 % spago install parsing 後々使うので以下のパッケージもインストール。
% spago install either integers maybe strings arrays lists src/Main.pursに以下の記述を追加。
import Text.Parsing.Parser (Parser) parser :: Parser String String parser = pure &amp;#34;Hello&amp;#34; REPLを起動して、動くか確認する。どんな文字列を食わせても&amp;quot;Hello&amp;quot;としか結果を返さないパーサーの完成。
&gt; import Main &gt; import Text.Parsing.Parser (runParser) &gt; runParser &#34;hoge&#34; parser (Right &#34;Hello&#34;) REPLでMain.pursをリロードする場合は:rをREPLで実行する。
数字のパース 1文字取得 1文字の数字を読み取りたいなら、Text.Parsing.Parser.Tokenにdigitがあるのでそれを使う。
import Text.Parsing.Parser.Token (digit) parser :: Parser String Char parser = digit &gt; runParser &#34;12345&#34; parser (Right &#39;1&#39;) 1文字以上取得 1文字以上を取得したいなら、Data.Array.Someを使う。
import Data.Array as Array parser :: Parser String (Array Char) parser = Array.</description>
    </item>
    
    <item>
      <title>モンテカルロ法による積分</title>
      <link>https://bombrary.github.io/blog/posts/monte-carlo-integral/</link>
      <pubDate>Tue, 28 Dec 2021 08:45:00 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/monte-carlo-integral/</guid>
      <description>今年の7月くらいに書き始め、存在をすっかり忘れていた記事をUP。
モンテカルロ法でどうやって積分計算をするのか、重点サンプリングとはどのようなものなのかついて勉強したので、そのメモ。
一般論 $$ \begin{aligned} \int_{\Omega_0} f(x) dx &amp;amp;= \int_{\Omega_0} \frac{f(x)}{p(x)}p(x)dx\\ &amp;amp;= \mathbb{E}\left[\frac{f(x)}{p(x)}\right] \end{aligned} $$
ここで、$p$ は確率密度関数。上の $\mathbb{E}$ が期待値であるためには、
$$ \int_{\Omega_0} p(x) dx = 1 $$
である必要がある。
大数の法則より、確率分布 $p$ に従う 標本 $x_n\ (n = 1, 2, \ldots, N)$ に対して、$N$ が十分大きければ、
$$ \mathbb{E}\left[\frac{f(x)}{p(x)}\right] \simeq \frac{1}{N} \sum_{n=1}^{N} \frac{f(x_n)}{p(x_n)} $$
となるから、結局、
$$ \begin{aligned} \int_{\Omega} f(x) dx \simeq \frac{1}{N} \sum_{n=1}^{N} \frac{f(x_n)}{p(x_n)} \end{aligned} $$
と近似できる。 ちなみに、$p(x_n) = 0$ なる $x_n$ が選ばれることは絶対に無い(確率0だから)。よって分母が0になることを心配する必要はない。
定義域を広げる $p$ の定義域をもう少し広げられる。$\Omega \supset \Omega_0$ であれば、集合$A$に関する指示関数を $\bm{1}_A$ と書くことにして、</description>
    </item>
    
    <item>
      <title>Neovimのプラグインを初めて作る - REPLの操作</title>
      <link>https://bombrary.github.io/blog/posts/nvim-plugin-repl/</link>
      <pubDate>Sat, 25 Dec 2021 18:35:00 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/nvim-plugin-repl/</guid>
      <description>動機 研究で使っているソフトウェアのREPLが少し使いづらい。というのも、制御文字がそのまま表示されてしまうため、十字キーのカーソル移動やCmd + Aの行先頭移動、Cmd + Kの行削除など効かないからだ。 rlwrap を使えばこの問題を解決できるのだが、別の解決案としてNeovimのREPL支援プラグインを作ってみようと思い立った。 Neovim のターミナル機能を使ってREPLを起動し、別バッファー上で入力した文字列をREPLに送るようなプラグインを作りたい。
GitHubで検索してみると同様の機能を実現するプラグインはいくつもあるようだが(例えば、vim-slime)、プラグインを作る勉強として、自分で作ってみる。
提供する機能 使用感をvlimeと似たものにしたい。キーマップは次のようにする。
&amp;lt;LocalLeader&amp;gt;ss カーソル下の行をREPLに送る。 &amp;lt;LocalLeader&amp;gt;s 選択範囲内行の文字列をREPLに送る。 &amp;lt;LocalLeader&amp;gt;i 1行入力用のバッファを表示し、そこで書いた文字列をREPLに送る。 &amp;lt;LocalLeader&amp;gt;cd Ctrl + DをREPLに送る。 &amp;lt;LocalLeader&amp;gt;cc Ctrl + CをREPLに送る。 その他、以下のコマンドを定義する。
ReplOpen [cmd]: REPLを起動する。例えばReplOpen pythonならpythonのREPLが起動する。 [cmd]には任意のコマンドが入れられるため、REPL支援というよりターミナル支援プラグインという感じがするが、気にしないことにする。 ReplSend [string]: 文字列[string]をREPLに送る。 補足 vlimeとキーマップが被るため、vlimeを入れている人はどうするんだという事になる。 その場合、キーマップが被らないようにしたり、ftplugin下にスクリプトを書くなど色々と方法が考えられる。 ここでは一番無難そうな、「ReplOpenが呼び出された時にキーマップを登録する」という方法を採用する。
注意 普段使っているのがVimではなくNeovimなので、Neovimを使ってプラグインを書く。Vimには無い関数/機能を使うので注意。
あとVim scriptをほとんど書いたこと無いため、今回載せるコードには色々改善点があるだろう。
準備 適切なディレクトリにプラグインのディレクトリを作成。自分の環境では、packpathの1つに~/.config/nvimがあったので、 ~/.config/nvim/pack/plugins/start/に置く。プラグインのディレクトリは愚直にrepl.nvimとする
そこにautoload、plugin、ftpluginディレクトリを作成する。
repl.nvim | +-- autoload/ | | | +-- repl.vim | +-- plugin/ | +-- repl.vim REPLの起動 autoload/repl.vimに色々関数を定義する。
まずはREPLの起動から。ウインドウを分割し、ターミナルを起動し、コマンドcmdを実行する関数は素朴には以下のように書ける。
function! repl#open(cmd) abort vnew call termopen(a:cmd) endfunction 「a:変数名とかs:変数名って何？」と初めは思ったが、これの答えは:h internal-variablesにある。 a:は関数の引数を表し、s:はこのスクリプト内の変数を表す。</description>
    </item>
    
    <item>
      <title>Web Audio API 備忘録</title>
      <link>https://bombrary.github.io/blog/posts/web-audio-api-note01/</link>
      <pubDate>Fri, 24 Dec 2021 21:12:00 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/web-audio-api-note01/</guid>
      <description>Web Audio APIで色々遊んだメモ。
サイン波を鳴らす HTMLファイルを作成。適当にindex.htmlとしておく。
&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;button id=&amp;#34;play_btn&amp;#34;&amp;gt;play&amp;lt;/button&amp;gt; &amp;lt;script src=&amp;#34;script.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; script.jsは以下のようにしておく。
const audioContext = new AudioContext(); const oscillatorNode = audioContext.createOscillator(); oscillatorNode.connect(audioContext.destination); document.getElementById(&amp;#39;play_btn&amp;#39;) .addEventListener(&amp;#39;click&amp;#39;, function() { oscillatorNode.start(); }, false); これで、&amp;ldquo;play&amp;rdquo; ボタンを押すとサイン波が再生される(音量に注意)。
説明 Web Audio APIの枠組みでは、色々な音やエフェクトをノードとして繋いでいく。最終的な出力を担うノードはAppContext.destinationである。
まずAudioContextのインスタンスを作成する。このContextというのはプログラミングをやっていると色々なところで現れるが (Canvas要素に描画する際にもgetContextが出てくるし、WinAPIだとデバイスコンテキストハンドル、AndroidアプリのプログラミングでもContextがある)、自分は「Audioについて色々な情報を提供してくれるオブジェクト」くらいの理解をしている。
const audioContext = new AudioContext(); 続いて、音源としてOscillatorNodeを作成し、繋いでやる。
const oscillatorNode = audioContext.createOscillator(); oscillatorNode.connect(audioContext.destination); oscillatorNode.start()で実際に音源が再生される。今回はclickイベントが起こったときに再生されるようにしている。
(補足) ページ読み込み時の再生はできないという仕様 Chrome/Safariの場合、以下のようにページを開いた瞬間に音がなるようなコードを書いたとしても、実際には鳴らない。
const audioContext = new AudioContext(); const oscillatorNode = audioContext.createOscillator(); oscillatorNode.connect(audioContext.destination); oscillatorNode.start(); これは、「ボタンが押す」のような、ユーザーが明示的な操作をしない限り再生されない仕様となっているかららしい。 実際 Chrome の場合、上のコードを書くと以下の警告がDevalopper Toolで表示される。</description>
    </item>
    
    <item>
      <title>Pythonを使った(静的)ページの画像のURL取得</title>
      <link>https://bombrary.github.io/blog/posts/python-get-img-url-static/</link>
      <pubDate>Thu, 09 Dec 2021 11:08:15 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/python-get-img-url-static/</guid>
      <description>Webページの画像だけを手っ取り早く取得したい場合にどうすれば良いのかを考えた。 これを行うプログラムをPythonで取得する。
この記事で作成したプログラムはGitHubのRepositoryに公開した。
前提 Pythonのバージョンは3.10を想定。
この記事では外部ライブラリとして
Requests 2.26.0 Beautiful Soup 4.10.0 tqdm 4.62.3 w3lib 1.22.0 を使う。この記事のコードを動かす場合はpipコマンドなどでインストールしておく。
方針 やることは案外単純である。
WebページのHTMLデータを取ってくる。 img要素を探して、そのsrc属性を取ってくる。 scheme、netlocが無かったらそれを付加して、完全なURLにする。 1はRequests、2はBeautiful Soupを使えば良いだろう。 3は思ったより複雑である。src属性に入っているパスには、
URL: http://foo.org/bar/hoge.png スキームが省略されている: //foo.org/bar/hoge.png 絶対パス: /bar/hoge.png 相対パス: ../bar/hoge.png データURL: data:image/png;base64,... など色々ある。 これらのフォーマットを統一して完全なURLにするのは面倒であるが、幸運にもurllib.parse.urljoinという関数があったのでこれを使う (余談: 初め、urljoinの存在を知らずに自前でURLの変換機能を実装してしまった。学びにはなったが時間を費やした…)。
ついでの機能として、「特定の要素の中に含まれているimg要素のURLを取得する」ことも考える。 これはCSSセレクタとして指定できるようにする。
まとめると、画像のURLを取得する関数は以下のようなインターフェースとなる。
def get_img_urls(url: str, selector: Optional[str]=None) -&amp;gt; list[str]: pass # これから実装する URLとセレクタを引数にとり、img要素のURLのリストを返す関数である。
ついでに画像ダウンロードのためのCLIや、画像を閲覧するWebアプリなどが作れたら良い。
プロジェクトの構造 Pythonでモジュールを作ったことがないため、正しい作り方が分からないが、とりあえず以下のような構成にしてみる。 細かいディレクトリの構成は各節で述べる。
/project | +--+ getimg/ | +--+ commandline/ | +--+ viewer/ | +--+ tests/ +-- __init__.</description>
    </item>
    
    <item>
      <title>neovimのプラグインがうまく動かなかったので原因を探した話</title>
      <link>https://bombrary.github.io/blog/posts/nvim-note0/</link>
      <pubDate>Fri, 01 Oct 2021 09:19:20 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/nvim-note0/</guid>
      <description>(2021/12/25追記) この記事で話題にした問題は最新のddc-nvim-lspで修正されている。こちらのissue及びこちらのcommitを参照。もっとも、この記事を書いてから大分経ったため、ddc_nvim_lsp.luaのソースコードも今では大分変わっている。
以下の文章のまとめ バージョン違いには注意する
ddc-nvim-lspは2021/10/1時点では、neovim 0.5.0を想定して作られているプラグインである。しかし自分はneovim 0.5.1を使ってしまっていた。neovim 0.5.1からlsp handlerの引数に破壊的変更があったため、LSPの補完が効かなかった。
究明に当たってDockerを触ったり、Luaを触ったり、ドキュメントを漁ったりして色々糧にはなったので、記録しておく。
何が起きたのか まず、プラグインの管理にはShougo/dein.vimを使った。
neovimのbuildin LSPを使ってLSPが使える環境を構築した。設定に当たって以下のプラグインを導入した。
neovim/nvim-lspconfig 入力補完はShougo/ddc.vimを使った。それにあたって以下のプラグインを導入した。
vim-denops/denops.vim: ddc.vimがDenoの機能を使うため必要。 Shougo/ddc-matcher_head Shougo/ddc-sorter_rank Shougo/ddc-around Shougo/ddc-nvim-lsp 最後のddc-nvim-lspがうまく動かなかった．
Language Serverとしてpyrightを導入したのだが、実際にPythonのファイルで入力補完を試したところ，ddc-aroundの補完は反応するが，ddc-nvim-lspの補完候補が現れなかった。
Dockerを使って再現性を検証する まず、
何か他のプラグインが邪魔しているのではないか Macという環境だから問題なのだろうか という仮説を立てた。そのためには、何も無い素のneovimの環境を作る必要があると考えた。そこで、環境をDockerで構築しようと考えた。
Docker環境の構築 適当なディレクトリを作って、そこにDockerfileとdocker-compose.ymlを作成する。
Dockerfileを以下のようにする。ベースイメージはanatolelucet/neovimにした。この時点でdeinを導入する。コマンドはdeinのQuick startを参照した。deinのインストールにあたってcurl、gitコマンドが必要なので、ここで導入する。
FROM anatolelucet/neovim:stable-ubuntu RUN apt-get update &amp;amp;&amp;amp; apt-get install -y curl git RUN curl https://raw.githubusercontent.com/Shougo/dein.vim/master/bin/installer.sh &amp;gt; installer.sh &amp;amp;&amp;amp; sh ./installer.sh ~/.cache/dein neovimの設定ファイルはコンテナ外で編集できるようにしておく。同ディレクトリにディレクトリ.config/nvim/を作成し、その上で、docker-compose.ymlを以下のようにする。
version: &amp;#39;3&amp;#39; services: nvim: build: . volumes: - .config:/root/.config entrypoint: &amp;#39;bash&amp;#39; working_dir: /root .config/nvim/の中にinit.vim、dein.toml&#39;、&#39;dein_lazy.tomlを作成。init.vimは以下の通り。
&amp;#34;dein Scripts----------------------------- if &amp;amp;compatible set nocompatible &amp;#34; Be iMproved endif &amp;#34; Required: set runtimepath+=/root/.</description>
    </item>
    
    <item>
      <title>Elmでテトリスを作った話</title>
      <link>https://bombrary.github.io/blog/posts/elm-tetris/</link>
      <pubDate>Tue, 10 Aug 2021 17:10:00 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/elm-tetris/</guid>
      <description>Elmでテトリスを作った。この記事では実装にあたって考えたポイントをメモしておく。 コードは説明のために断片的に載せる。
製作物 ここで遊べる．
Repositryはこちら。
実装しなければいけない処理 大まかに作らなければいけないのは以下の処理．
ボード・テトリミノのデータ構造 テトリミノの出現・回転・落下・固定 テトリミノの衝突判定 ラインがそろった時に消滅する処理 ゲームオーバー処理 キー操作 画面描画 この中からいくつかの項目について説明する。
ボードのデータ構造 ボードの落とす場は10x20のブロックで構成されている。 壁をボードに含めるかどうか、上部にマージンを設けるかどうかで、実際のボードサイズは変わる。
まず、ボードのブロックをセルと呼ぶことにする。セルを次のように定義する。Colorは適当に定義しておく。
type Cell = Block Color | Empty このセルを使ってボードを定義したいが、悩ましい選択が現れる。
セルを要素に持つList。セルの座標はリストの添字で判断する。 (座標, セル)を要素に持つList。 キーを座標、値をセルとしたDict。 ListをArrayにした実装も考えられる。参考までに、3つは以下のように定義できる。
type alias Board = List Cell type alias Board = List { pos : Vec Int , cell : Cell } type alias Board = Dict (Vec Int) Cell ボードのデータ構造によって諸々の関数の実装方法が大きく変わってくるので、どれを選ぶか慎重になる必要がある。
2つ目と3つ目のデータ構造はelm-gamesのRepositoryに載っているテトリスのコードから発見した。 それらのコードを見つけた時にはすでに1番目で作ってしまっていたので、現状の自分の実装は1番目のものである。
TEAのView関数としての扱いやすさを考えるなら、2番目の実装が一番良いと思う。例えばセルの描画関数をviewCellとして、viewBoardは次のように書ける。
import Svg viewBoard : Board -&amp;gt; Svg Msg viewBoard board = Svg.</description>
    </item>
    
    <item>
      <title>線形回帰メモ 正則化</title>
      <link>https://bombrary.github.io/blog/posts/regression-regularization/</link>
      <pubDate>Sat, 07 Aug 2021 07:17:00 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/regression-regularization/</guid>
      <description>問題設定 $\bm{y} = (y^{(1)}, y^{(2)}, \ldots, y^{(N)})^T,\ \bm{x}_i = (1, x_1^{(i)}, x_2^{(i)}, \ldots, x_D^{(i)})^T$ とおく。$(\bm{x}_i, y_i),\ i = 1, 2, \ldots, N$ がデータとして与えられている。このとき、入力と出力の間に
$$ \begin{aligned} y &amp;amp;= h_{\bm{w}}(\bm{x})\\ &amp;amp;:= w_0 + w_1x_1 + w_2x_2 + \cdots + w_Dx_D\\ &amp;amp;= \bm{w}^T\bm{x} \end{aligned} $$
が成り立つと仮定し、これに適する$\bm{w}$を見つけたい。
(正則化前の)コスト関数 ここで「適する」とは具体的に何なのかというと、ここでは予測とデータとの二乗誤差の和
$$ J(\bm{w}) = \frac{1}{2} \sum_{i=1}^{N} (h_{\bm{w}}(\bm{x}_i) - y^{(i)})^2 $$
が最小となる $\bm{w}$ を求める。この $J$ をここではコスト関数と呼ぶ。 係数 $1/2$ は微分した時に出てくる $2$ を消し去るための便宜的なものであり、つける必然はない。
L1正則化とL2正則化 コスト関数に $\bm{w}_i$ のL1ノルム(の1乗)の項を付けることをL1正則化という。
$$ J_1(\bm{w}) = J(\bm{w}) + \lambda \|\bm{w}\|_1 $$</description>
    </item>
    
    <item>
      <title>TikZ 備忘録</title>
      <link>https://bombrary.github.io/blog/posts/tikz-note01/</link>
      <pubDate>Fri, 30 Jul 2021 22:30:00 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/tikz-note01/</guid>
      <description>随時更新。
毎回マニュアルから情報を探すのが面倒なので、基本的なものをここにまとめたい。個人的に気になったことに対しては深堀して補足しているが、細かいことを気にしすぎた結果、TikZやPGFのソースコードを読みに行く羽目になった。
またここに書いてある内容がベストプラクティスとは限らないことに注意。もっと簡単な書き方があるかもしれない。
情報の集め方 ここに載っているものはほぼTikZ/PGFのマニュアル() に載っている。
TeX Liveを導入しているなら、コマンドtexdoc tikzで開くはず。これと同じものがCTANの &amp;ldquo;PGF Manual&amp;quot;のリンクからダウンロードできる。 非公式ではあるが、HTML版のマニュアルも公開されたようだ：The TikZ and PGF Packages この記事では、なるべく参照した情報を記載するようにする。ここに書いてあることが間違っている場合があるので、何かおかしいなと思ったらマニュアルを参照すること。
知らないキーワードや記号が出てきたらマニュアル末尾のindexで探すと良い。 TikZで出来ることを把握したいなら、Part Iのチュートリアルを読んでみるのが有効。もしくはPartIII, Vあたりを流し読みする。PGF Manualはページ数が膨大なため、全部読もうとするのは恐らく得策では無い。目次を眺めながら興味のあるところをつまむのが良いと思う(読み方について、Introductionの1.4 How to Read This Manualも参照)。 既にやりたいことがあるが、TikZで実現する方法が分からない場合は、ググる。英語のキーワードで検索すれば、大抵Stack Exchangeがヒットする。画像検索も有効。 準備 パッケージ読み込み・この記事での記法の注意 TikZはtikzパッケージから読み込める。
\usepakcage{tikz} 以降、コードを記載するときはこの記述を省略する。
また、TikZには色々な便利なライブラリが用意されている。例えば座標計算に便利なライブラリであるCalcは次のように読み込む。
\usetikzlibrary{calc} 以降、コード中で必要なライブラリがあった場合は、コードの先頭に\usetikzlibraryを記載することにする。 このコマンドは実際にはプリアンブルに書く必要があることに注意。
DVIドライバの指定 必ずクラスオプションにDVIドライバを指定すること。さもなければ、色が出力されなかったり、図形の位置が正確に計算されなかったりする。
以下は、DVIドライバをdvipdfmx、クラスをjsarticleで行う例。
\documentclass[dvipdfmx]{jsarticle} クラスオプションにDVIドライバを指定する必要性については、以下のサイトを参照： 日本語 LaTeX の新常識 2021 - Qiita。
色を定義 (TikZの話ではない) TikZではなくxcolorの話だが、大事なのでここで記す。これはtikzパッケージを読み込んだときに自動で読み込まれるようだが、もしxcolor単体で使いたいなら、xcolorパッケージを読み込むこと。
\usepakcage{xcolor} 色同士を!で混ぜることができる。例えばred!20!blue!30!whiteと書くと、赤、青、白がそれぞれ20%、30%、(100-20-30)%混ざった色になる。
カラーコードやRGB値などから定義したい場合は\definecolor、既存の色を混ぜて使いたい場合は\colorletを利用。
\definecolor{mycolor1}{HTML}{888888} # 定義する色名 カラーモデル 色の値 \colorlet{mycolor2}{orange!75!white} # 定義する色名 色 色名に-をつけると補色を表現できる。ただし、ここでの補色はRGBでの補色。例えば-redとすると赤色の補色のシアンとなる。RYBでの補色を使いたい場合は-には頼らず、色を直接\definecolorで指定する必要があると思われる。
文字にマーカーをつける 参考: TikZ で“インラインな”図を描く - Qiita</description>
    </item>
    
    <item>
      <title>ロジスティック回帰 メモ</title>
      <link>https://bombrary.github.io/blog/posts/logistic-regression/</link>
      <pubDate>Sun, 11 Jul 2021 12:40:00 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/logistic-regression/</guid>
      <description>式変形の一部はProbabilistic Machine Learning: An Introductionを参考にしている。
問題設定 データが $N$ 個あり、入力は $\bm{x}_n = (x_{n1}, x_{n2}, \ldots, x_{nD})$、出力は $y_n \in \{ 0, 1 \}$ とする。 このとき、入力 $\bm{x}$ が与えられたとき出力 $y$ を予測したい。
確率モデルの定義 ここでは確率的なモデルを考える。すなわち、 データ $\bm{x}$ が与えられたとき、 $y = 0, 1$ のどちらの確率が高いのかを考える。
$y$ は2値だから、ベルヌーイ分布としてモデル化できる。
$$ p(y ; \mu) = \mu^y (1 - \mu)^{1 - y} $$
これは、$y = 1$ である確率が $\mu$ 、$y = 0$ である確率が $1 - \mu$ であることを意味する。 $\mu$ は確率だから、$0 \le \mu \le 1$ である必要がある。</description>
    </item>
    
    <item>
      <title>PureScriptで作るBrainfuckインタプリタ 4/4 Halogenの利用</title>
      <link>https://bombrary.github.io/blog/posts/purescript-brainfuck04/</link>
      <pubDate>Fri, 09 Jul 2021 23:15:00 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/purescript-brainfuck04/</guid>
      <description>Halogenの利用 続いて、GUIでBrainfuckを動かすことをやってみる。 GUIのフレームワークとして、ここではpurescript-halogenを使ってみる。 Halogenについてはまだ勉強中で、この記事は解説記事というより勉強記録である(いままでの記事もそうではあるのだが)。
% spago install halogen 雛形 src/Main.pursを以下のようにする。 ここのコードはほとんどHalogen Guideと同様。 関数名的におそらく、body要素を取得して、その中でcomponentを走らせるのだと思う。
module Main where import Prelude import Effect (Effect) import Halogen.Aff (awaitBody, runHalogenAff) as HA import Halogen.VDom.Driver (runUI) import Component (component) main :: Effect Unit main = HA.runHalogenAff do body &amp;lt;- HA.awaitBody runUI component unit body componentはsrc/Component.pursで定義する。とりあえず雛形を作成。
module Component where import Prelude import Halogen as H import Halogen.HTML as HH data Action = Dummy type State = {} initialState :: forall input.</description>
    </item>
    
    <item>
      <title>PureScriptで作るBrainfuckインタプリタ 3/4 CUIでの可視化</title>
      <link>https://bombrary.github.io/blog/posts/purescript-brainfuck03/</link>
      <pubDate>Tue, 06 Jul 2021 10:35:00 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/purescript-brainfuck03/</guid>
      <description>動作の可視化 インタプリタ動作中における内部状態を可視化できると面白い。 そこで、インタプリタ動作中のログを出力できるような仕組みを作る。 ログは以下のタイミングで起こるようにする。
onStart: インタプリタが動作したときに起こる。 onState state: 各ステップで状態を取得したときに起こる。 onCmd cmd: 各ステップで命令を取得できたときに起こる。 onEnd: インタプリタが終了するときに起こる。 これらはイベントリスナのように、関数の形で指定する。
Logの作成 src/Brainfuck/Interp/Log.pursを作成。
以下のimport文を書く。
module Brainfuck.Interp.Log where import Prelude import Brainfuck.Interp (Interp) import Brainfuck.State (State) import Brainfuck.Command (Command) import Effect.Class (class MonadEffect, liftEffect) import Effect.Console (log) Logを定義。
newtype Log m = Log { onStart :: Interp m Unit , onState :: State -&amp;gt; Interp m Unit , onCmd :: Command -&amp;gt; Interp m Unit , onEnd :: Interp m Unit } 関連する関数を定義。</description>
    </item>
    
    <item>
      <title>PureScriptで作るBrainfuckインタプリタ 2/4 CUIでの入出力</title>
      <link>https://bombrary.github.io/blog/posts/purescript-brainfuck02/</link>
      <pubDate>Mon, 05 Jul 2021 17:05:00 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/purescript-brainfuck02/</guid>
      <description>入出力用のストリーム作成 例えば出力だけ考えてみると、まず考えられるのは単純に、 logで出力することである。しかしlog以外の選択肢も考えられる。 logでコンソール出力するだけでなく、Webページのテキスト上で出力したり、テキストファイルに吐き出したりできるような汎用性が持たせられると良い。
そこで今回は、いわゆる「ストリームオブジェクト」のようなものを作って、そこから入出力を行うような設計にしてみる。
Streamの作成 src/Brainfuck/Interp/Stream.pursを作成。この後使うモジュールをインポート。
module Brainfuck.Interp.Stream where import Prelude import Brainfuck.Interp (Interp) Stream型を作成する。これは入出力を束ねた型になっている。 inputは、外部からの入力を1文字受け取る。 outputは、Charの値を外部に出力する。
newtype Stream = Stream { input :: Interp Char , output ::Char -&amp;gt; Interp Unit } Streamを通じてデータを読み書きする関数を作成。
read :: Stream -&amp;gt; Interp Char read (Stream { input }) = input write :: Char -&amp;gt; Stream -&amp;gt; Interp Unit write c (Stream { output }) = output c defaultStream :: Stream defaultStream = Stream { input, output } where input = pure &amp;#39;N&amp;#39; -- Not Implemented output _ = pure unit -- Not Implemented &amp;lsquo;.</description>
    </item>
    
    <item>
      <title>PureScriptで作るBrainfuckインタプリタ 1/4 基礎部分の作成</title>
      <link>https://bombrary.github.io/blog/posts/purescript-brainfuck01/</link>
      <pubDate>Sun, 04 Jul 2021 11:40:00 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/purescript-brainfuck01/</guid>
      <description>Brainfuckの記事ではあるが、実はモナド変換子を使ってみたかっただけだったりする。
以下の3部の記事で構成されている。
インタプリタと基本的な命令の実装 (この記事) CUIでの入出力処理の実装 CUIでのインタプリタ可視化 Halogenを用いた入出力処理の実装 この記事でインタプリタの基本的な部分を実装し、 残りの3記事はインタプリタとはあまり関係ない話となる (とはいえ出力ができないと Hello, World すら書けないので、必要な記事ではある)。
Brainfuckインタプリタの構造 Brainfuckインタプリタは以下の情報を内部に持っているものとする。
program: 命令の列。 iptr: インストラクションポインタ。実行する命令の位置を示す。プログラムカウンタみたいなもの。 dptr: データポインタ。メモリ上のある位置を示す。 memory: メモリ。 インタプリタは以下の手順を踏む。
iptr番目の命令をprogramから読み取る。 読み取れなかったらプログラムを終了する。 命令に応じてmemory、dptrの書き換えだったり、入出力を行う。 iptrを1進め、手順1に戻る。 どんな命令があるのかについてはWikipedia参照。
準備 適当なディレクトリを作って、プロジェクトの初期化を行う。
% spago init 命令列の作成 src/Brainfuck/Command.pursを作成する。
Commandを定義。Showクラスのインスタンスにして、Charからの変換をする関数を作る。
module Brainfuck.Command where import Prelude data Command = IncPtr -- &amp;#34;+&amp;#34; | DecPtr -- &amp;#34;-&amp;#34; | IncDat -- &amp;#34;&amp;gt;&amp;#34; | DecDat -- &amp;#34;&amp;lt;&amp;#34; | LBrace -- &amp;#34;[&amp;#34; | RBrace -- &amp;#34;]&amp;#34; | Output -- &amp;#34;.</description>
    </item>
    
    <item>
      <title>線形回帰メモ 勾配降下法</title>
      <link>https://bombrary.github.io/blog/posts/regression-gradient-descent/</link>
      <pubDate>Tue, 22 Jun 2021 16:08:00 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/regression-gradient-descent/</guid>
      <description>線形回帰を勾配降下法を使って解いてみたメモ。
問題設定 $\bm{y} = (y^{(1)}, y^{(2)}, \ldots, y^{(N)})^T,\ \bm{x}_i = (1, x_1^{(i)}, x_2^{(i)}, \ldots, x_D^{(i)})^T$ とおく。$(\bm{x}_i, y_i),\ i = 1, 2, \ldots, N$ がデータとして与えられている。このとき、入力と出力の間に
$$ \begin{aligned} y &amp;amp;= h_{\bm{w}}(\bm{x})\\ &amp;amp;:= w_0 + w_1x_1 + w_2x_2 + \cdots + w_Dx_D\\ &amp;amp;= \bm{w}^T\bm{x} \end{aligned} $$
が成り立つと仮定し、これに適する$\bm{w}$を見つけたい。「適する」とは具体的に何なのかというと、ここでは予測とデータとの二乗誤差の和
$$ J(\bm{w}) = \frac{1}{2} \sum_{i=1}^{N} (h_{\bm{w}}(\bm{x}_i) - y^{(i)})^2 $$
が最小となる $\bm{w}$ を求める。この $J$ については呼び名がいくつかあるが、ここではコスト関数と呼ぶ。 係数 $1/2$ は微分した時に出てくる $2$ を消し去るための便宜的なものであり、つける必然はない。
コスト関数の勾配 $w_j$に関する偏微分を計算すると、
$$ \frac{\partial J(\bm{w})}{\partial w_j} = \sum_{i=1}^{N} (h_{\bm{w}}(\bm{x}_i) - y^{(i)})x_j^{(i)},\ j = 0, 1, \ldots, D $$</description>
    </item>
    
    <item>
      <title>線形回帰メモ 最小二乗法</title>
      <link>https://bombrary.github.io/blog/posts/regression-lstsq/</link>
      <pubDate>Sun, 20 Jun 2021 22:10:00 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/regression-lstsq/</guid>
      <description>学校の授業で勉強はしたが、自分で考えてまとめたことはなかったのでここに記しておく。
問題設定(1) $\bm{y} = (y^{(1)}, y^{(2)}, \ldots, y^{(N)})^T,\ \bm{x}_i = (1, x_1^{(i)}, x_2^{(i)}, \ldots, x_D^{(i)})^T$ とおく。$(\bm{x}_i, y_i),\ i = 1, 2, \ldots, N$ がデータとして与えられている。このとき、入力と出力の間に
$$ \begin{aligned} y &amp;amp;= h_{\bm{w}}(\bm{x})\\ &amp;amp;:= w_0 + w_1x_1 + w_2x_2 + \cdots + w_Dx_D\\ &amp;amp;= \bm{w}^T\bm{x} \end{aligned} $$
が成り立つと仮定し、これに適する$\bm{w}$を見つけたい。「適する」とは具体的に何なのかというと、ここでは予測とデータとの二乗誤差の和
$$ J(\bm{w}) = \frac{1}{2} \sum_{i=1}^{N} (h_{\bm{w}}(\bm{x}_i) - y^{(i)})^2 $$
が最小となる $\bm{w}$ を求める。この $J$ については呼び名がいくつかあるが、ここではコスト関数と呼ぶ。 係数 $1/2$ は微分した時に出てくる $2$ を消し去るための便宜的なものであり、つける必然はない。
コスト関数の最小値を求める(1) コスト関数の行列表現 まず $J$ を行列だけで表現してみる。
$$ \begin{aligned} J(\bm{w}) &amp;= \frac{1}{2} \sum_{i=1}^{N} (\bm{w}^T\bm{x}_i - y^{(i)})^2\\ &amp;= \frac{1}{2} \sum_{i=1}^{N} (\bm{x}_i^T\bm{w} - y^{(i)})^2\\ &amp;= \frac{1}{2} \begin{pmatrix} \bm{x}_1^T\bm{w} - y^{(1)}\\ \bm{x}_2^T\bm{w} - y^{(2)}\\ \vdots\\ \bm{x}_N^T\bm{w} - y^{(N)}\\ \end{pmatrix}^T \begin{pmatrix} \bm{x}_1^T\bm{w} - y^{(1)}\\ \bm{x}_2^T\bm{w} - y^{(2)}\\ \vdots\\ \bm{x}_N^T\bm{w} - y^{(N)}\\ \end{pmatrix}\\ &amp;= \frac{1}{2} \left( \begin{pmatrix} \bm{x}_1^T\bm{w}\\ \bm{x}_2^T\bm{w}\\ \vdots\\ \bm{x}_N^T\bm{w}\\ \end{pmatrix} - \bm{y} \right)^T \left( \begin{pmatrix} \bm{x}_1^T\bm{w}\\ \bm{x}_2^T\bm{w}\\ \vdots\\ \bm{x}_N^T\bm{w}\\ \end{pmatrix} - \bm{y} \right) \end{aligned} $$ ここで、</description>
    </item>
    
    <item>
      <title>PureScriptとCanvasで作る『弾むボール』</title>
      <link>https://bombrary.github.io/blog/posts/purescript-bouncing-ball/</link>
      <pubDate>Thu, 17 Jun 2021 16:50:00 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/purescript-bouncing-ball/</guid>
      <description>英語だと &amp;ldquo;bouncing ball programming&amp;rdquo; とか検索すると出てくるやつ。 単にボールが弾むだけなのだが、思ったより勉強になったので書き残す。
実際のプログラムの動作はGitHub Pagesを参照。
プロジェクトの初期化 適当なディレクトリを作って、その中でプロジェクトを作成。
% spago init % spago build 今回は、追加のパッケージは必要なときにspago installコマンドで入れることにする。
Canvas入門 src/Main.pursを以下のようにする。
module Main where import Prelude import Data.Maybe (Maybe(..)) import Effect (Effect) import Effect.Console (log) import Graphics.Canvas (CanvasElement, Dimensions) import Graphics.Canvas as Canvas import Math as Math canvasDimen :: Dimensions canvasDimen = { width: 600.0 , height: 600.0 } initCanvas :: CanvasElement -&amp;gt; Effect Unit initCanvas canvas = Canvas.setCanvasDimensions canvas canvasDimen main :: Effect Unit main = Canvas.</description>
    </item>
    
    <item>
      <title>PythonとFlask(&#43;α)で作るToDoリストAPI</title>
      <link>https://bombrary.github.io/blog/posts/todo-api-flask/</link>
      <pubDate>Thu, 03 Jun 2021 23:29:00 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/todo-api-flask/</guid>
      <description>シンプルなToDoリストのWeb APIを作る。 今までWSGIの仕様のみ、Werkzeug の2通りで実装したが、今回はFlaskといくつかのライブラリを使う。使うのは以下の通り。
Flask: WSGIアプリフレームワーク。 peewee: ORMライブラリ。 marshmallow: データの変換やvalidationをするためのライブラリ。 Flaskとは WSGIのWebアプリを作るためのフレームワーク。 フレームワークであるため、Flaskが用意した作法に従ってコードを書くことで比較的手軽にWebアプリが作成できる。 前回との比較でいうならば、例えばルーティングの仕組みをプログラマが書く必要はない。これはFlaskに備わっている。
Djangoのようなフレームワークとは違って、持っている機能は少ない。必要に応じて外部ライブラリを組み合わせる。 例えば、Djangoではデフォルトでデータベースの仕組みが内蔵されているが、Flaskにはない。その代わりに、 データベースのライブラリとしてsqlite3やSQLAlchemy、peeweeなど、好きなものを用いれば良い。
ToDoリストAPIの仕様 今回ToDoのデータは以下キーと値を持つJSONデータとする。
key value id ID content ToDoの内容 created_at 作成日時 (ISO8601) updated_at 更新日時 (ISO8601) APIの仕様は以下の通り。
URL Method 説明 返却値 /todo/ GET 全てのToDoを取得。 ToDoのデータのリスト /todo/ POST ToDoを作成。 なし (LocationヘッダにそのToDoへのURLを乗せる) /todo/&amp;lt;todo_id&amp;gt; GET todo_idのidを持つToDoを取得。 ToDoのデータ /todo/&amp;lt;todo_id&amp;gt; PUT todo_idのidを持つToDoを変更。 なし /todo/&amp;lt;todo_id&amp;gt; DELETE todo_idのidを持つToDoを削除 なし データはSQLiteで管理する。
雛形 todo_listディレクトリを作成。todo_list/__init__.pyを以下のようにする。
from flask import Flask def create_app(): app = Flask(__name__) @app.route(&amp;#39;/&amp;#39;) def hello(): return &amp;#39;Hello, World&amp;#39; return app exportコマンドで環境変数を設定する。</description>
    </item>
    
    <item>
      <title>PythonとWerkzeugで作るToDoリストAPI</title>
      <link>https://bombrary.github.io/blog/posts/todo-api-werkzeug/</link>
      <pubDate>Sun, 30 May 2021 11:49:40 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/todo-api-werkzeug/</guid>
      <description>シンプルなToDoリストのWeb APIを作る。 前回はWSGIの仕様のみを参考にして作ったが、 今回はWerkzeugというライブラリを利用する。
Werkzeugとは Werkzeugのドキュメントの &amp;ldquo;Werkzeug is a comprehensive WSGI web application library.&amp;ldquo;という文面にもある通り、 これはWSGIのWebアプリを作るためのライブラリである。 あくまでフレームワークではなく、ライブラリであることに注意する。 Webアプリを作るうえで、便利なクラスや関数が用意された「道具箱」のようなイメージを持つとよいかもしれない (そもそも&amp;quot;werkzeug&amp;quot;という単語はドイツ語で「道具」という意味)。 あくまで道具があるだけなので、どういう設計を行うかなどを考える余地がある。
ToDoリストAPIの仕様 前回と同じだが、再掲する。
簡単のため、今回ToDoのデータはidと内容のみ持つデータとし、{ id: 0, &amp;quot;content&amp;quot;: &amp;quot;やること&amp;quot; }というJSON形式とする。
APIの仕様は以下の通り。
URL Method 説明 返却値 /todo/ GET 全てのToDoを取得。 ToDoのデータのリスト /todo/ POST ToDoを作成。 なし (LocationヘッダにそのToDoへのURLを乗せる) /todo/&amp;lt;todo_id&amp;gt; GET todo_idのidを持つToDoを取得。 ToDoのデータ /todo/&amp;lt;todo_id&amp;gt; PUT todo_idのidを持つToDoを変更。 なし /todo/&amp;lt;todo_id&amp;gt; DELETE todo_idのidを持つToDoを削除 なし データは最終的にはSQLiteで管理する。
雛形 app.pyを以下のようにする。
from werkzeug.wrappers import Response def app(env, start_response): response = Response(&amp;#39;Hello, World&amp;#39;) return response(env, start_response) if __name__ == &amp;#39;__main__&amp;#39;: from werkzeug.</description>
    </item>
    
    <item>
      <title>PythonとWSGIで作るToDoリストAPI</title>
      <link>https://bombrary.github.io/blog/posts/todo-api-wsgi/</link>
      <pubDate>Sat, 29 May 2021 13:00:00 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/todo-api-wsgi/</guid>
      <description>シンプルなToDoリストを作る。 今回は勉強のため、Webアプリケーションフレームワークは使わずに、 敢えてWSGIの仕様のみ参考にして書く．
WSGIとは WSGIとは、WebサーバーとWebアプリとの間の標準的なインターフェース。 WSGIの仕様に沿ってWebアプリを作れば、 WSGI対応のどんなWebサーバーとも連携することができる。
WSGIの仕様はPEP3333に書かれている．
ToDoリストAPIの仕様 簡単のため、今回ToDoのデータはidと内容のみ持つデータとし、{ id: 0, &amp;quot;content&amp;quot;: &amp;quot;やること&amp;quot; }というJSON形式とする。
APIの仕様は以下の通り。
URL Method 説明 返却値 /todo/ GET 全てのToDoを取得。 ToDoのデータのリスト /todo/ POST ToDoを作成。 なし (LocationヘッダにそのToDoへのURLを乗せる) /todo/&amp;lt;todo_id&amp;gt; GET todo_idのidを持つToDoを取得。 ToDoのデータ /todo/&amp;lt;todo_id&amp;gt; PUT todo_idのidを持つToDoを変更。 なし /todo/&amp;lt;todo_id&amp;gt; DELETE todo_idのidを持つToDoを削除 なし データは最終的にはSQLiteで保存するが、最初は単純にlistで扱う。
雛形 まずはサーバーを作る。この時点ではルーティング処理を書いていない。 どのようなリクエストをしてもHello, Worldをレスポンスとして返す。
from wsgiref.simple_server import make_server def app(env, start_response): start_response(&amp;#39;200 OK&amp;#39;, [(&amp;#39;Content-type&amp;#39;, &amp;#39;text/plain; charset=utf-8&amp;#39;)]) return [b&amp;#39;Hello, World.&amp;#39;] if __name__ == &amp;#39;__main__&amp;#39;: httpd = make_server(&amp;#39;&amp;#39;, 5000, app) httpd.</description>
    </item>
    
    <item>
      <title>Socket通信勉強(3) - 簡易HTTPサーバー作成</title>
      <link>https://bombrary.github.io/blog/posts/socket03-http/</link>
      <pubDate>Sat, 06 Mar 2021 22:00:00 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/socket03-http/</guid>
      <description>1年以上前に書いた記事 で、HTTPサーバーもどき(リクエストを読まず、ただ一方的にレスポンスを返すだけのサーバ)を書いた。 今回はもう少しだけこれを進化させる。
動機 非常にどうでもいいのだが動機を記しておく。
Land of Lispの13章でソケット通信が出てきた。 Land of Lispで扱っているCommon Lispの処理系がCLISPなのに対し、今自分が利用しているのはSBCLなので、 本文中のコードが動かない。そこで色々調べて、usocketを利用しようと思いつく。 その後なんとか書き上げる。ところがChromeやcurlでは動くのに、Safari(現バージョンは14.0.2)では動かない。ページを読み込んだ後、タイムアウトしたかのような挙動を起こす。
その理由を明らかにしたくて「そもそもLisp以外では動くのか。例えばPythonのソケット通信では動くのか」「PythonのWebアプリ、例えばFlaskの開発用サーバーで動くのはなぜか」 など色々調べた。cpythonのsocketserverやhttp.serverなどのソースコードも読んだ。
調べた結果、どうやらSafariがたまに「何も送らない通信(?)」を行うことが原因だった。 何も送ってくれないと、リクエストをrecvで受け取るときに、ブロッキングが働いてサーバー側が固まってしまう。 ただし普通のリクエストも送ってくるので、マルチスレッドなどの多重化を行なっておけば 問題なくSafariでもページが読み込まれる。なのでFlaskの開発用サーバーでは大した問題にならなかった。 Safariがなぜこんな通信をするのかはよく分からない。HTTPの仕様をちゃんと読んでいないので、何か見落としがあるのだろうか。もしくはバグか何かなのか。
何はともあれ、色々ソースコードを読んでいくうちに、リクエストヘッダの取得のやり方など参考になった。 せっかくなのて得た知見を元に再びHTTPサーバを作ってみようと思い立った。
作るもの 以下の条件を満たすHTTPサーバのようなものを作る(そもそも、どこまで実装できたらHTTPサーバと呼べるのだろうか)。
マルチスレッドにする。 HTTPリクエストのリクエストライン、ヘッダ情報をパースする。 リクエストボディは今回は考慮しない。 前回に比べてPythonについての知見が広がったため、 コードにおいてf-stringsやtype-annotation、dataclassなどの機能を使ってみている。 また処理を細かく関数に分ける。
listen用のソケットの作成 待ち受け用のソケットを作成し、それを返す関数を作成する。 bindやlistenは前回説明した通り。 動作確認を何度も行う都合上、TIME_WAIT状態のポートを待つのは面倒なので、setsockopt(...)の記述でそれを解決している。 (この辺りの詳細は&amp;quot;TIME_WAIT&amp;quot;とか&amp;quot;REUSEADDR&amp;quot;あたりのキーワードで検索すれば出てくる)
import socket def server_socket(port: int): soc = socket.socket(socket.AF_INET, socket.SOCK_STREAM) soc.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True) soc.bind((&amp;#39;&amp;#39;, port)) soc.listen(5) return soc 動作確認 以下のようにrun_serverを作る。
def run_server(port: int): with server_socket(port) as soc: while True: conn, addr = soc.accept() print(f&amp;#39;Connected: {addr}&amp;#39;) with conn: conn.</description>
    </item>
    
    <item>
      <title>PythonでPDFの順序並び替えと空白ページ挿入(2種類の方法)</title>
      <link>https://bombrary.github.io/blog/posts/python-pdf-rearrange/</link>
      <pubDate>Thu, 07 Jan 2021 11:50:37 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/python-pdf-rearrange/</guid>
      <description>平綴じ印刷ができるように、PDFの順序を入れ替えたり、空白ページを挿入するプログラムを書いた。 方法1はPython + いろんなコマンドで、方法2はPythonのPDFライブラリであるPyPDF4を利用した方法。 実装してみた結果、後者が圧倒的に簡単だった。
動機 平綴じがしたい場面が出てきたが、印刷機に専用の設定が見つからなかった。 なので平綴じになるようにPDFのページ順を1,2,3,4,5,6,7,8,&amp;hellip;から4,1,2,3,8,5,6,7,..に変え、それをプリンタで両面刷り(短辺綴じ)・2ページ割付で印刷することを考えた。
平綴じの場合、紙に両面4ページずつ印刷されることになる。するとPDFのページ数は4の倍数でなくてはならない。よって、4の倍数でなかった場合はその分を空白ページで埋めなければならない。
PDFファイルの準備 テスト用にPDFファイルを作っておく。ここはなんでも良いのだが、とりあえず以下のLaTeXのコードから10ページのPDFファイルを作る。名前はinput.pdfとしておく。
\documentclass{jsarticle} \begin{document} \centering \Huge 1 Page \newpage 2 Page \newpage 3 Page \newpage 4 Page \newpage 5 Page \newpage 6 Page \newpage 7 Page \newpage 8 Page \newpage 9 Page \newpage 10 Page \end{document} 方法1：Python + 諸々のコマンドの利用 方針 PDFのページ順を変えるためには、pdftkコマンドを利用すれば良い。pdftkは、Homebrewならbrew install pdftk-javaで使えるようになる)。例えば8ページのPDFファイルinput.pdfを並び替えるなら次のコマンドで可能。
$ pdftk A=input.pdf cat A4 A1 A2 A3 A8 A5 A6 A7 output output.pdf 例えば空白ページを1ページ持つファイルをblank.pdfとすると、6ページのPDFファイルを並び替え、7、8ページを空白ページとするコマンドは次のように書ける。A7とA8がB1に置き換わっていることに注目。
$ pdftk A=input.pdf B=blank.</description>
    </item>
    
    <item>
      <title>Purescriptメモ - 配列のシャッフルを様々な方法で実装する</title>
      <link>https://bombrary.github.io/blog/posts/purescript-shuffle/</link>
      <pubDate>Mon, 04 Jan 2021 13:29:19 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/purescript-shuffle/</guid>
      <description>PureScriptで配列のシャッフルをしたい。型はこんな感じ。乱数は副作用を伴うため、返り値の型はEffectで包まれる。
shuffle :: forall a. Array a -&amp;gt; Effect (Array a) アルゴリズムはFisher-Yates ShuffleのModern Algorithmの項の2つ目を利用する。これをさまざまな方法で作成したところ、Functor, Applicative, Monadなどに関連する事項だったり、STモナドの使い方、FFIの使い方だったりが学べたので、備忘のために書く。
準備 適当なディレクトリでプロジェクトを作成する。今回使うパッケージをインストールする。
$ spago init $ spago install arrays $ spago install random $ spago install foldable-traversable 方法1: 素直(?)な書き方 ここでは、src/Shuffle.pursに記述する。
天下り的ではあるが、これから使う関数、型をimportしておく。
module Shuffle where import Prelude import Effect (Effect) import Data.Array (range, (!!), updateAt, length) import Data.Traversable (for) import Effect.Random (randomInt) import Data.Maybe (maybe) import Data.Foldable (foldr) まずは、「どの添字ととの添字の値を交換するか」という情報をもったデータExchangeIndexと、それを作成する関数exchangeIndiciesを作成する。
type ExchangeIndex = { i :: Int , j :: Int } exchangeIndicies :: Int -&amp;gt; Effect (Array ExchangeIndex) exchangeIndicies n = for (range 0 (n - 2)) \i -&amp;gt; do j &amp;lt;- randomInt i (n - 1) pure { i, j } 次に、ExchangeIndexの情報を元に配列を交換する関数exchangeを作成。配列の添字が不正だった場合(配列外参照を起こしそうなとき)は!</description>
    </item>
    
    <item>
      <title>PureScriptメモ - Generics</title>
      <link>https://bombrary.github.io/blog/posts/purescript-note-generics/</link>
      <pubDate>Tue, 03 Nov 2020 13:17:39 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/purescript-note-generics/</guid>
      <description>purescript-generics-repパッケージを使ってGenericなSerializer型クラスを作った。以下はそのメモ。
準備 プロジェクトを作成。
$ spago init Arrayを使うので、パッケージをインストールしてsrc/Main.pursにimport文を書き込んでいく。 本記事の本命であるgenerics-rep入れる。 $ spago install arrays $ spago install generics-rep import Data.Array ((:)) REPLで色々実験するので、あらかじめ起動しておく。 $ spago repl &gt; import Main 以降はsrc/Main.pursに色々書き足していく。REPLで:r(もしくは:reload)とコマンドを打てばモジュールが再読み込みされるので、src/Main.pursを書き換える度にこのコマンドを打つと良い。
Serializer そもそもSerializerとは何か。ここでは単に「データをビット列に変換するもの」程度の意味で捉えれば良い。 厳密にはJSONなどの階層を持つデータを，文字列などの平坦なデータに変換するという意味合いとしてシリアライズ(直列化)という言葉を使う。実際、本記事では最終的に木構造をシリアライズする。
まずビットは次のように定義する。
data Bit = O | I instance showBit :: Show Bit where show O = &amp;#34;O&amp;#34; show I = &amp;#34;I&amp;#34; Serializer型クラスを以下のように定義する。
class Serializer a where serialize :: a -&amp;gt; Array Bit 試しに適当な型をつくり、それをSerializer型クラスのインスタンスにしてみる。
data Person = Alice | Bob | Carol instance serializerUser :: Serializer Person where serialize Alice = [ I ] serialize Bob = [ O, I ] serialize Carol = [ O, O, I ] 余談。今回はデシリアライザは実装しないので、シリアライズしたデータを同じ形に戻せるかは考えない。このあたりは情報理論の授業で「一意復号化可能性」などをやった気がするけど、忘れてしまった。</description>
    </item>
    
    <item>
      <title>PureScriptでじゃんけんゲーム(CUI)を作る</title>
      <link>https://bombrary.github.io/blog/posts/purescript-janken/</link>
      <pubDate>Thu, 25 Jun 2020 09:05:09 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/purescript-janken/</guid>
      <description>プログラミングの初歩で作りそうなじゃんけんゲームを作る。ただし、PureScriptで作る。
方針 Jankenというモジュールを作る グー・チョキ・パーをHandとして定義する じゃんけんの勝負の結果をJudgementとして定義する コンピュータが出す手はランダムに出したいので、ランダムな手を出す関数randomを作っておく 入力は文字列にしたいので、文字列から手に変換する関数fromStringを作っておく 入出力はMainに書く。Node.ReadLineモジュールの力で入力を受け付ける。 準備 適当なプロジェクトディレクトリを作っておいて、
$ spago init /src/Main.pursと/src/Janken.pursを作っておく。
/src/Main.pursはとりあえず以下のようにしておく。
module Main where import Prelude import Effect (Effect) import Effect.Console (log) main :: Effect Unit main = do log &amp;#34;Hello&amp;#34; 次のコマンドでHelloが出力されることを確認する。
$ spago run Jankenモジュールの定義 この節では/src/Janken.pursを編集していく。
module Janken where import Prelude Handの定義 じゃんけんの手を表す型Handを定義する。
data Hand = Rock | Scissors | Paper 余談。これは公式ではタグ付き共用体と呼ばれているもの。Haskellでは代数的データ型と呼ばれているが、正直名前はどうでもいい。データをこのように表現すれば、「データはこの値しかとりえない」という制限が得られる。制限があれば、プログラムのバグも減らせる。たとえば、「グーを0、チョキを1、パーを2」として表現すると、万が一それ以外の値が来た場合に困る。上のようなHandの定義では、「それ以外の値」が入る余地すら与えない。…この話は、Elm Guideの受け売り。
Judgementの定義 同じようにして、じゃんけんの勝敗を表す型Judgementを定義する。
Judgement = WinLeft | WinRight | Draw なぜWinとかLoseではないのかというと、これはjudge関数の都合である。Judgeは、2つの手を引数にとり、その勝負結果を返す。WinやLoseだと、どっちが勝ちでどっちが負けか分からない。なので、「judgeの左側の引数が勝ったらWinLeft、右側が勝ったらWinRight、引き分けならDraw」と定義している。
judge :: Hand -&amp;gt; Hand -&amp;gt; Judgement judge Rock Rock = Draw judge Scissors Scissors = Draw judge Papser Paper = Draw judge Rock Scissors = WinLeft judge Scissors Paper = WinLeft judge Paper Rock = WinLeft judge _ _ = WinRight REPLで遊ぶ REPLでテストしてみたい。Showクラスのインスタンスにすることで、REPLで値が出力できるようになる。</description>
    </item>
    
    <item>
      <title>VimでLaTeXを使うための環境構築(Mac)</title>
      <link>https://bombrary.github.io/blog/posts/vim-latex-setup/</link>
      <pubDate>Sun, 31 May 2020 19:03:00 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/vim-latex-setup/</guid>
      <description>備忘録。基本的にはMacのTerminalでやることを想定。Macをインストールしたての状態を仮定する。
homebrewを使って、TeXLiveとSkimをインストールする。latexmkの設定をした後、vimにdein.vimを入れて、それを用いてvimtexを入れるところまでやる。おまけでvimrcの他の設定や、colorschemeの設定もやる。
注意 なるべくコマンドを載せるようにするが、それを実行しても上手くいかない場合は、公式サイトなどを参照すること。この記事が古くなっていて、打つべきコマンドが変わっている可能性がある。
homebrewのインストール homebrewをインストールしておくと、いろいろなソフトがbrew (cack) install ...だけでインストールできる。便利なので入れる。
homebrewの公式サイトのインストールを参照。
念のため、Terminalを再起動しておく。
TeXLive(MacTeX)のインストール TeXLiveの説明についてはWikiを参照。TeX関連のあらゆるパッケージやソフトの詰め合わせ。そのMac版がMacTeX。
MacTeXやそのインストール方法については、Wikiを参照。homebrewをインストールしたので、次のコマンドでインストールできる。以下はmactex-no-guiとしているが、もしguiアプリも入れたい場合はmactexとする。どんなguiアプリが入るのかについてはWikiを参照。
かなり巨大なファイル群のため、インストールにかなり時間がかかった気がする。
$ brew cask install mactex-no-gui $ sudo tlmgr update --self --all $ sudo tlmgr paper a4 念のため、Terminalを再起動しておく。
Skimのインストール SkimとはPDFビュワーの一種で、PDFの自動リロードを行ってくれる。こちらもhomebrewでインストールできる。
$ brew cask install Skim 起動して、環境設定を開く。「同期」タブに移動して、「ファイルの変更をチェック」と「自動的にリロードする」にチェックを入れておく。
latexmkの設定 後でインストールするVimのプラグイン(vimtex)がlatexmkを利用するので、設定しておく。
こちらのページは、latexmkについて分かりやすく説明してくれているので見ておくと良い。
~/.latexmkrcを作成し、内容を以下のようにする。これは上の参考サイトの引用。
#!/usr/bin/env perl $latex = &amp;#39;platex -synctex=1 -halt-on-error&amp;#39;; $latex_silent = &amp;#39;platex -synctex=1 -halt-on-error -interaction=batchmode&amp;#39;; $bibtex = &amp;#39;pbibtex&amp;#39;; $biber = &amp;#39;biber --bblencoding=utf8 -u -U --output_safechars&amp;#39;; $dvipdf = &amp;#39;dvipdfmx %O -o %D %S&amp;#39;; $makeindex = &amp;#39;mendex %O -o %D %S&amp;#39;; $max_repeat = 5; $pdf_mode = 3; $pvc_view_file_via_temporary = 0; $pdf_previewer = &amp;#34;open -ga /Applications/Skim.</description>
    </item>
    
    <item>
      <title>Eular法とRunge-Kutta法をPythonで実装する</title>
      <link>https://bombrary.github.io/blog/posts/eular_runge-kutta/</link>
      <pubDate>Thu, 28 May 2020 10:50:13 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/eular_runge-kutta/</guid>
      <description>備忘のために。数値解析関連の話はほとんど学んだことがないため、何か間違いがあるかも。
Eular法 以下、例に出そうとしている微分方程式が運動方程式なので、文字の使い方を力学っぽくしている(位置、速度、時間を $x, v, t$ みたいな気持ちで書いている)。
導出(1階) まず次の常微分方程式がある。
\[ \frac{dx}{dt} = f(t, x) \]
上の式を以下のように近似する。$h$を十分小さくすれば、微分の定義より上の式に近づく。
\[ \begin{aligned} \frac{x(t + h) - x(t)}{h} \simeq f(t, x) \\ \Rightarrow x(t + h) \simeq x(t) + f(t, x)h \end{aligned} \]
これが、$x(t)$の更新式となっている。つまり、ある時刻$t_0$における値$x_0 = x(t_0)$を決めておけば、
\[ \begin{aligned} &amp;amp; t_k := t_{k-1} + h\\ \end{aligned} \]
とおいて、
\[ \begin{aligned} &amp;amp; x(t_1) := x(t_0) + f(t_0, x_0)h \\ &amp;amp; x(t_2) := x(t_1) + f(t_1, x_1)h \\ &amp;amp; x(t_3) := x(t_2) + f(t_2, x_2)h \\ &amp;amp; &amp;hellip; \end{aligned} \]</description>
    </item>
    
    <item>
      <title>HaskellでStateモナドを自作する</title>
      <link>https://bombrary.github.io/blog/posts/haskell-state-monad/</link>
      <pubDate>Sat, 28 Mar 2020 19:16:20 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/haskell-state-monad/</guid>
      <description>Stateモナドがわからない状態から、ギリギリ分かる状態になった。
Stateモナドを学習した流れ 結局、具体例を通して学習した。個人的には、いきなりモナドの定義から学習するよりも、たくさんの例を見たり、実際に例を作ってみたりした方が覚えられた。抽象的な概念を理解するためには具体的な概念に触れるべきだ、ということを改めて認識した。
以下は、自分が行った学習の流れ。Haskell IOモナド 超入門は学習のうえで参考になった。とくに、&amp;gt;&amp;gt;=を漏斗の形に見立てる比喩のおかげで、モナドと関数の組み合わせのイメージがクリアになった。
Maybeモナド、Listモナドの使い方を理解する。 IOモナドの使い方を理解する。 いくつかのモナドについて、do構文を&amp;gt;&amp;gt;=に書き換えてみる。 Stateモナドの使い方を理解する。 Stateモナドを自作する。 この記事ではStateモナドを自作することをテーマとしているため、ある程度Stateモナドに慣れた人でないとわかりづらいかもしれない。
Stateの定義 まずはStateを自作する。Stateは、状態 -&amp;gt; (計算結果,次の状態)という関数を内部に持っている。この関数のことを、この記事では「内部関数」「状態付き計算」などと表現する。
newtype State s a = State (s -&amp;gt; (a, s)) これは本来のStateの定義とは異なることに注意。本来は、StateはStateTを使って実装されている。上のように定義してしまうと、モナド変換子としての機能が利用できない。ただ、そこまで考えると面倒なので、今回はStateを単なる関数のラッパーとして定義した。
型引数の順番と内部関数が返すタプルの順番が逆なのが微妙に気持ち悪い。これはあくまで推測でしかないが、
あくまで状態付きの計算なので、重要なのは計算の結果。なので返り値は(a, s)と計算結果を先に書いている。 型引数の順番がs aなのは、Monadにするときに不都合を生じないため。 なのだと思う。
余談 Stateモナドがよくわかっていない時は、Stateのことを「状態を持つ型」と勘違いしていた。正しくは、「状態付き計算を持つ型」。Stateは状態を持っているわけでなく、あくまで、「状態を引数にとり、計算結果と次の状態を返す関数」を持っている。なので、初期状態は内部関数の引数として、自分で投入する。
runStateの定義 レコード構文を使って、runStateを定義する。runStateは、Stateから中身の関数を取り出す関数。
newtype State s a = State { runState :: s -&amp;gt; (a, s) } 試す 上の定義を踏まえて、次のようにプログラムを書いてみる。以下は、状態を[Int]とする状態付き計算。
addX doubleAll sumUpはそれぞれ、単純な内部関数を持つStateである。一方で、calc0はこれらの関数を組み合わせた、新たなStateであることに注目。一連の状態付き計算を一つにまとめて、新たな状態付き計算を作っている。
calc0において、初期状態をs、次の状態をs0、その次の状態をs1、…と置いている。計算結果を返すのはsumUpだけで、他の関数は単に状態を変更するだけ。なので計算結果は()となっている。
addX :: Int -&amp;gt; State [Int] () addX x = State $ \s -&amp;gt; ((), x:s) doubleAll :: State [Int] () doubleAll = State $ \s -&amp;gt; ((), map (* 2) s) sumUp :: State [Int] Int sumUp = State $ \s -&amp;gt; (sum s, s) calc0 :: State [Int] Int calc0 = State $ \s -&amp;gt; let (_, s0) = runState (addX 1) s (_, s1) = runState (addX 2) s0 (a2, s2) = runState sumUp s1 (_, s3) = runState (addX a2) s2 (_, s4) = runState doubleAll s3 in runState sumUp s4 main = do print $ runState calc0 [] 実行結果は以下のようになる。</description>
    </item>
    
    <item>
      <title>webpackに入門する - p5.jsの開発環境作り</title>
      <link>https://bombrary.github.io/blog/posts/webpack-intro-p5/</link>
      <pubDate>Thu, 19 Mar 2020 09:44:48 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/webpack-intro-p5/</guid>
      <description>webpackを利用してp5.jsの開発環境を作り、ボールが弾むプログラムを作成する。
使用するパッケージのバージョン webpack@5.15.0 webpack-cli@4.3.1 webpack-dev-server@3.11.2 p5@1.2.0 動機 ふとしたきっかけで久々にp5.jsを触りたくなった。
昔使っていたときは、p5.jsのファイルをダウンロードしてscriptタグに直接指定することで書いていた。しかし最近、Vue.jsのガイドを読んでいてwebpackの存在を知った。名前は知っていたのだが、具体的に何をするためのものなのかはよく分かっていなかったので調べた。
webpackとは 以下、個人的に調べた限りの理解を書く。
Conceptによれば、webpackとは&amp;quot;module bundler&amp;quot;の一種。bundleという意味から、「複数のモジュールを一つに束ねるツール」だと予想できる。JSのプログラムを、モジュールとして複数の単位に分割して開発する。それを一つのファイルにまとめ上げてくれるのがwebpack。
例えばp5.jsで、ボールが弾むだけのプログラムを書こう、と思った場合、
ボールを管理するモジュールをBall.jsに書く スケッチを管理するモジュールをsketch.jsに書く メインの処理をindex.jsに書く みたいにモジュールを分けられる。
ただし、モジュールを扱うための機能であるimport/export文はES2015の仕様で標準採用され、多くのブラウザで実装されている。じゃあwebpackの他の強みは何かというと、おそらく「JS以外のファイルもまとめてくれる点」だと思う。例えばcssやsassのファイルもJSに埋め込むことができる。TypeScriptやJSXのファイルもwebpackでまとめられる。ただしwebpackの核の機能はあくまでJSのモジュールをまとめることなので、JS以外のファイルはloaderと呼ばれる変換器を通しておく必要がある。とはいえ、「このファイルはこのloaderに通してね」というのをあらかじめ設定ファイルに書いておけば、少ないコマンドで変換からbundleまでやってくれるので、便利である。
今回はp5.jsの開発環境づくりのためにwebpackを用意するのだが、JSのモジュールしか扱うつもりはない。なのでwebpackの恩恵は少ないかもしれない。しかし練習として使ってみる。
webpackの導入と動作確認 まず適当にプロジェクト用のディレクトリを作る。npmでプロジェクトを初期化する。
$ mkdir p5-sandbox $ cd p5-sandbox $ npm init -y 以下、このプロジェクトのルートディレクトリを/で表す。
webpack本体を入れる。webpackをコマンドラインから実行するためにはwebpack-cliが必要なので、それも入れる。個人で使う分にはどうでもよいと思うが、これらは開発のみに利用されるパッケージなので、--save-devをつけておく。
$ npm install webpack webpack-cli --save-dev ディレクトリの作成 今回は次のようにする。
ソースコードは/src/index.jsに書く。 bundle後のファイルは/public/js/bundle.jsとして出力されるようにする。 あらかじめディレクトリを作成しておく。
$ mkdir src $ mkdir -p public/js index.jsの作成 /src/index.jsを作成。動作確認のため適当に書く。
console.log(&amp;#34;Hello, World&amp;#34;); webpackの設定 /webpack.config.jsを作成する。
const path = require(&amp;#39;path&amp;#39;); module.exports = { mode: &amp;#39;development&amp;#39;, entry: &amp;#39;./src/index.js&amp;#39;, output: { filename: &amp;#39;bundle.</description>
    </item>
    
    <item>
      <title>zipファイルの構造を少しだけ理解する</title>
      <link>https://bombrary.github.io/blog/posts/zip-format-report/</link>
      <pubDate>Wed, 04 Mar 2020 13:50:16 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/zip-format-report/</guid>
      <description>Unix系のコマンド(od、grep)だけを使って、zipファイルの中身をのぞく。
zip形式の参考サイト zipの仕様書はZIP File Format Specificationで確認できる。ページ内検索をかけながら必要なところをつまんでいく、という読み方が良さそう。
日本語ならWikipediaがある。こちらは図が書かれているし日本語なので分かりやすい。
zipファイルの用意 まずはzipファイルを用意する。
foo.txtとbar.txtを用意する。
$ echo &#34;Hello, World.&#34; &gt; foo.txt $ echo &#34;Good Bye.&#34; &gt; bar.txt これらをzipコマンドでまとめる。
$ zip tmp.zip foo.txt bar.txt バイナリ形式で出力 zipファイルはテキストとして表示できるものではなく、バイナリとして表示しないとあまり意味を掴めない。バイナリ表示ができるテキストエディタを使ってもよいが、ここではodコマンドを用いる。
$ od -Ax -tx1z tmp.zip 引数の意味は以下の通り。man odでも確認できる。
-A: アドレスの基数(Address-radix)。出力時、最も左の値がファイル先頭から何バイト目なのかを表示する。続けてxと書くと、16進数(hex)で出力する。 -t: データの出力形式(おそらくtypeの略)。 続けてx1と書くと、1バイト区切りの16進数で出力する。 続けてzと書くと、右側にテキストでの表示を添える。ただし表示されるのはASCIIコードで認識される文字のみ。 結果は以下のようになる。
000000 50 4b 03 04 0a 00 00 00 00 00 28 70 64 50 4b 82 &gt;PK........(pdPK.&lt; 000010 70 33 0e 00 00 00 0e 00 00 00 07 00 1c 00 66 6f &gt;p3.</description>
    </item>
    
    <item>
      <title>Elmメモ ドラッグ移動の実現(2) - elm-draggableの利用</title>
      <link>https://bombrary.github.io/blog/posts/elm-drag02/</link>
      <pubDate>Thu, 27 Feb 2020 12:39:44 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/elm-drag02/</guid>
      <description>前回はBrowsertやSvgなどの標準的なパッケージを利用してドラッグ機能を実現した。今回はelm-draggableというパッケージを使ってドラッグ機能を実現してみる。
準備 Elmのプロジェクトを作成して、src/Main.elmとsrc/Circle.elmを作成。
Circle.elm 前回と同じなのでコードだけ載せる。
module Circle exposing (..) type alias Id = Int type alias Circle = { id : Id , x : Float , y : Float , r : Float } type alias Circles = { all : List Circle , nextId : Id } empty : Circles empty = { all = [] , nextId = 0 } type alias CircleNoId = { x : Float , y : Float , r : Float } add : CircleNoId -&amp;gt; Circles -&amp;gt; Circles add c circles = let circle = { id = circles.</description>
    </item>
    
    <item>
      <title>Elmメモ ドラッグ移動の実現(1)</title>
      <link>https://bombrary.github.io/blog/posts/elm-drag01/</link>
      <pubDate>Tue, 25 Feb 2020 19:15:00 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/elm-drag01/</guid>
      <description>ElmでSVGの要素をドラッグ移動したいと思った。ドラッグ操作を実現するパッケージにelm-draggableがある。今回は勉強として、それに頼らず実装することを試みる。elm-draggableを用いた方法については次回やる。
初期状態 詳細は省略するが、Elmプロジェクトを作成してelm/svgとelm/jsonをインストールしておく。
src/Main.elmは以下のようにしておく。elm reactorで動くことを確認する。
module Main exposing (..) import Browser import Browser.Events as BE import Html exposing (..) import Html.Attributes exposing (..) import Json.Decode as JD import Svg as S exposing (Svg) import Svg.Attributes as SA import Svg.Events as SE main = Browser.element { init = init , update = update , view = view , subscriptions = subscriptions } type alias Model = {} type Msg = Dummy init : () -&amp;gt; ( Model, Cmd Msg ) init _ = ( {}, Cmd.</description>
    </item>
    
    <item>
      <title>Vue.js勉強メモ(1) - 簡易Todoリストの作成</title>
      <link>https://bombrary.github.io/blog/posts/viewjs01-todo/</link>
      <pubDate>Sun, 16 Feb 2020 18:52:20 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/viewjs01-todo/</guid>
      <description>公式ガイドの、コンポーネントの詳細の手前まで読み終えたので、この時点でTodoリストっぽいものを作ってみる。データベースを用意しないため、厳密にはTodoリストではない。
コンポーネントについてはまだ学んでいないため、これから書くコードにはまだ改善の余地があるだろう。
準備 index.htmlを用意する。
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;ja&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charet=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;script src=&amp;#34;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;Todo List&amp;lt;/h1&amp;gt; &amp;lt;script src=&amp;#34;script.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 以下の部分でVue.jsを読み込んでいる。
&amp;lt;script src=&amp;#34;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; script.jsを作成しておく。中身はまだ空。
実装する機能 初めにも述べたが、データベースは用意しない。以下の簡単な機能だけ実装する。
入力エリア Todoリスト表示エリア 各要素に削除ボタンをつける。 勉強を兼ねて、いくらか遠回りしながら作っていく。
配列の要素をli要素として表示 index.htmlに追記する。
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li v-for=&amp;#34;todo in todos&amp;#34;&amp;gt;{{ todo }}&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; Vue.jsが用意したテンプレート構文をHTMLに埋め込むことによって、データとDOMを結びつけることができる。v-という接頭辞がついた属性はディレクティブと呼ばれる。今回のv-forディレクティブは、その名の通りfor文を実現する。構文から分かると思うが、JSとかPythonで使われているfor-in文と同じ文法。
式の埋め込みは{{ 式 }}で行う。ガイドではMustache(口髭)構文と呼んでいる。良いネーミングだなと思ったけど、{{ }}の書式をそう呼ぶのはわりと一般的みたい？
さて、そうするとtodosというデータを用意する必要がありそうだが、これはscript.jsで行う。
const app = new Vue({ el: &amp;#39;#app&amp;#39;, data: { todos: [&amp;#39;todo1&amp;#39;, &amp;#39;todo2&amp;#39;, &amp;#39;todo3&amp;#39;, &amp;#39;todo4&amp;#39;, &amp;#39;todo5&amp;#39;] } }) elプロパティに、データと結びつく要素を指定する。これはセレクタの書式。elとは恐らくelementの略。dataプロパティに、結びつけるデータを指定する。v-forで利用するために、todosプロパティは配列にする。
こんな感じで、Vue.jsでは「データとDOMを結びつける」みたいなコーディングを行っていくみたい。この部分に関してはD3.jsと通ずるものがある。
index.htmlを開くとこんな感じになる。todosの各要素がli要素の内部に埋め込まれていることが分かる。</description>
    </item>
    
    <item>
      <title>GraphvizでTeXの数式を表示する(2) - PDFにしたい場合</title>
      <link>https://bombrary.github.io/blog/posts/graphviz-tex02/</link>
      <pubDate>Tue, 11 Feb 2020 21:57:47 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/graphviz-tex02/</guid>
      <description>TeXのレポートに貼り付けたいが、TeXではSVG形式は扱えないのでPDFにしたくなった。やってみたら思ったより面倒だったので備忘録として残す。
dotファイルの用意 前回と同じにする。ファイル名はgraph.dotとする。
digraph { graph [ rankdir=&amp;#34;LR&amp;#34; ]; node [ shape=&amp;#34;circle&amp;#34;, fixedsize=true, height=0.6 ]; Q0 [texlbl=&amp;#34;$q_0$&amp;#34;]; Q1 [texlbl=&amp;#34;$q_1$&amp;#34;]; Q2 [texlbl=&amp;#34;$q_2$&amp;#34;]; Q3 [texlbl=&amp;#34;$q_3$&amp;#34;]; Q4 [texlbl=&amp;#34;$q_4$&amp;#34;]; Q5 [texlbl=&amp;#34;$q_5$&amp;#34;]; Q6 [texlbl=&amp;#34;$q_6$&amp;#34;]; Q7 [texlbl=&amp;#34;$q_7$&amp;#34;]; Q8 [texlbl=&amp;#34;$q_8$&amp;#34;]; Q9 [texlbl=&amp;#34;$q_9$&amp;#34;]; Q10 [texlbl=&amp;#34;$q_{10}$&amp;#34;]; Q11 [texlbl=&amp;#34;$q_{11}$&amp;#34;]; Q12 [texlbl=&amp;#34;$q_{12}$&amp;#34;]; Q13 [texlbl=&amp;#34;$q_{13}$&amp;#34;]; Q0 -&amp;gt; Q1 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$\varepsilon$&amp;#34;]; Q0 -&amp;gt; Q4 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$\varepsilon$&amp;#34;]; Q0 -&amp;gt; Q7 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$\varepsilon$&amp;#34;]; Q1 -&amp;gt; Q2 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$a$&amp;#34;]; Q2 -&amp;gt; Q3 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$b$&amp;#34;]; Q3 -&amp;gt; Q7 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$\varepsilon$&amp;#34;]; Q4 -&amp;gt; Q5 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$b$&amp;#34;]; Q5 -&amp;gt; Q6 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$b$&amp;#34;]; Q6 -&amp;gt; Q7 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$\varepsilon$&amp;#34;]; Q7 -&amp;gt; Q8 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$a$&amp;#34;]; Q7 -&amp;gt; Q0 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$\varepsilon$&amp;#34;]; Q8 -&amp;gt; Q9 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$\varepsilon$&amp;#34;]; Q8 -&amp;gt; Q11 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$\varepsilon$&amp;#34;]; Q9 -&amp;gt; Q10 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$b$&amp;#34;]; Q10 -&amp;gt; Q13 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$\varepsilon$&amp;#34;]; Q11 -&amp;gt; Q12 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$c$&amp;#34;]; Q12 -&amp;gt; Q13 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$\varepsilon$&amp;#34;]; } dot → tex $ dot2tex graph.</description>
    </item>
    
    <item>
      <title>GraphvizでTeXの数式を表示する(1)</title>
      <link>https://bombrary.github.io/blog/posts/graphviz-tex01/</link>
      <pubDate>Sun, 26 Jan 2020 14:00:25 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/graphviz-tex01/</guid>
      <description>Graphvizはグラフを描画してくれる素晴らしいソフトなのだが、単体では数式を表示することができない。
dot2tex dot2texを利用すると、グラフのラベルに数式が使えるようになる。
次の手順でグラフを作る。
dot言語でグラフを書く dot2texでdotファイルをtexファイルに変換 texを使ってpdfなりsvgなりを作る。 pdfならplatex + dvipdfを使う(詳細は別記事にて) svgならplatex + dvisvgmを使う。 いやGraphviz使ってないじゃないか、と思うかもしれない。しかしDependensiesにGraphvizが含まれているから、おそらくGraphvizの描画エンジンを利用してノードの位置を決定しているのだと思う。
インストール Python製のソフトウェアみたいで、pip経由でインストールする。
$ pip3 install dot2tex 利用の手順 dot言語でグラフを書く 今回は次のようにする。ファイル名は適当にgraph.dotとする。
digraph { graph [ rankdir=&amp;#34;LR&amp;#34; ] node [ shape=&amp;#34;circle&amp;#34;, fixedsize=true, height=0.6 ] Q0 [texlbl=&amp;#34;$q_0$&amp;#34;]; Q1 [texlbl=&amp;#34;$q_1$&amp;#34;]; Q2 [texlbl=&amp;#34;$q_2$&amp;#34;]; Q3 [texlbl=&amp;#34;$q_3$&amp;#34;]; Q4 [texlbl=&amp;#34;$q_4$&amp;#34;]; Q5 [texlbl=&amp;#34;$q_5$&amp;#34;]; Q6 [texlbl=&amp;#34;$q_6$&amp;#34;]; Q7 [texlbl=&amp;#34;$q_7$&amp;#34;]; Q8 [texlbl=&amp;#34;$q_8$&amp;#34;]; Q9 [texlbl=&amp;#34;$q_9$&amp;#34;]; Q10 [texlbl=&amp;#34;$q_{10}$&amp;#34;]; Q11 [texlbl=&amp;#34;$q_{11}$&amp;#34;]; Q12 [texlbl=&amp;#34;$q_{12}$&amp;#34;]; Q13 [texlbl=&amp;#34;$q_{13}$&amp;#34;]; Q0 -&amp;gt; Q1 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$\varepsilon$&amp;#34;]; Q0 -&amp;gt; Q4 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$\varepsilon$&amp;#34;]; Q0 -&amp;gt; Q7 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$\varepsilon$&amp;#34;]; Q1 -&amp;gt; Q2 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$a$&amp;#34;]; Q2 -&amp;gt; Q3 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$b$&amp;#34;]; Q3 -&amp;gt; Q7 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$\varepsilon$&amp;#34;]; Q4 -&amp;gt; Q5 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$b$&amp;#34;]; Q5 -&amp;gt; Q6 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$b$&amp;#34;]; Q6 -&amp;gt; Q7 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$\varepsilon$&amp;#34;]; Q7 -&amp;gt; Q8 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$a$&amp;#34;]; Q7 -&amp;gt; Q0 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$\varepsilon$&amp;#34;]; Q8 -&amp;gt; Q9 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$\varepsilon$&amp;#34;]; Q8 -&amp;gt; Q11 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$\varepsilon$&amp;#34;]; Q9 -&amp;gt; Q10 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$b$&amp;#34;]; Q10 -&amp;gt; Q13 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$\varepsilon$&amp;#34;]; Q11 -&amp;gt; Q12 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$c$&amp;#34;]; Q12 -&amp;gt; Q13 [label=&amp;#34; &amp;#34;, texlbl=&amp;#34;$\varepsilon$&amp;#34;]; } texlblとはdot2texが読むための属性。おそらくtex labelの略で、これがnodeまたはedgeのラベルとして、texファイルに直接展開される。そのため、数式を描きたいなら$で囲む。もしdotファイル上にlabel属性が定義されていたら、texlblの内容に上書きされる。</description>
    </item>
    
    <item>
      <title>Elmメモ - 画像のプレビュー機能を作る</title>
      <link>https://bombrary.github.io/blog/posts/elm-image-preview/</link>
      <pubDate>Mon, 13 Jan 2020 11:00:50 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/elm-image-preview/</guid>
      <description>Elmを利用して、画像を選択してそれを表示するアプリを作る。
ファイル読み込みの方法 Select.file関数を利用する。これはファイル選択用のエクスプローラを開くためのCmd Msgを作成してくれる。選択したファイルはMsgに載せられる。
適切なMIMEタイプを指定すると、エクスプローラ上にてそのタイプのファイルしか選択できなくなる。例えば、text/plainを選択しておけば、拡張子.txtのファイルしか選択できなくなる。
Select.file &amp;#34;MIMEタイプのリスト&amp;#34; &amp;#34;Msg&amp;#34; 画像ファイルへの変換 こうして得られたファイルはFileと呼ばれる型で保持される。
もしファイルを文字列として扱いたいなら、File.toStringを利用する。
もし画像として扱いたいなら、File.toUrlを利用する。これは画像をBase64符号化した文字列を作る。これをimgタグのsrc属性に指定すれば、画像が表示される。
画像を選択し、それを表示するアプリの作成 準備 プロジェクトを作成して、elm/fileをインストール。
$ elm init $ elm install elm/file src/Main.elmの雛形を作る。
module Main exposing (..) import Browser import Html exposing (..) import Html.Attributes exposing (..) import Html.Events exposing (..) import File exposing (File) import File.Select as Select import Task main = Browser.element { init = init , update = update , view = view , subscriptions = subscriptions } type alias Model = { } init : () -&amp;gt; (Model, Cmd Msg) init _ = ( { } , Cmd.</description>
    </item>
    
    <item>
      <title>Elmメモ - 文字列をIPアドレスに変換(2) Parserを用いる方法</title>
      <link>https://bombrary.github.io/blog/posts/elm-ipaddr-parse/</link>
      <pubDate>Sun, 05 Jan 2020 14:29:15 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/elm-ipaddr-parse/</guid>
      <description>準備 前回のsrc/IPAddr.elmを全て消し、内容を以下の通りにする。
module IPAddr exposing (..) import Parser type IPAddr = IPAddr Int Int Int Int $ elm repl &gt; import Parser exposing (..) &gt; import IPAddr exposing (..) Parserの基本 以下の2つのステップに分かれる。
Parserを作る Parserを実行する - Parser.runを用いる ライブラリでは、標準で用意されているParserと、それらを組み合わせて新たなParserを作るための関数が用意されている。
&gt; run int &#34;123&#34; Ok 123 : Result (List Parser.DeadEnd) Int &gt; run int &#34;123abc&#34; Ok 123 : Result (List Parser.DeadEnd) Int &gt; run int &#34;abc123abc&#34; Err [{ col = 1, problem = ExpectingInt, row = 1 }] : Result (List Parser.</description>
    </item>
    
    <item>
      <title>Elmメモ - 文字列をIPアドレスに変換(1) splitを用いる方法</title>
      <link>https://bombrary.github.io/blog/posts/elm-ipaddr-split/</link>
      <pubDate>Sun, 05 Jan 2020 11:27:01 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/elm-ipaddr-split/</guid>
      <description>IPv4アドレスの文字列&amp;quot;192.168.1.1&amp;quot;をパースする方法を考える。IPAddrの内部表現は次のようにする。
type IPAddr = IPAddr Int Int Int Int 思いつくのは次の2通り。
ピリオドでsplitして、整数値に変換する。 パーサを利用する。 いずれにしても結構面倒。この記事では前者だけやる。
準備 適当なディレクトリで次のコマンドを実行。
$ elm init $ elm install elm/parser src/IPAddr.elmを作り、内容を以下の通りにする。
module IPAddr exposing (..) type IPAddr = IPAddr Int Int Int Int $ elm repl &gt; import IPAddr exposing (..) 方針 次の処理を行う関数をfromStringとして定義する。
文字列を.でsplitする。 Listの要素数が4でなければ失敗。 Listの各要素にString.toIntを適用し、どれか一つでも失敗すれば全体としても失敗。 Listを[a,b,c,d]としたとき、IPAddr a b c dを返す。 traverseの実装 3の処理は、次の関数として抽象化できる: リストの各要素にfを適用し、その結果すべてがJustを返したときだけ、全体の結果を返す。
traverse : (a -&amp;gt; Maybe b) -&amp;gt; List a -&amp;gt; Maybe List b 原始的な実装 なるべくfoldrとかを使わずに書こうとするとこんな感じになる。</description>
    </item>
    
    <item>
      <title>Elmメモ - ランダムな位置に円を描画する</title>
      <link>https://bombrary.github.io/blog/posts/elm-random-circle/</link>
      <pubDate>Wed, 01 Jan 2020 21:03:50 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/elm-random-circle/</guid>
      <description>乱数の練習に。
準備 プロジェクト用のディレクトリを適当に作り、そこで以下のコマンドを実行。
$ elm init 必要なモジュールを入れる。
$ elm install elm/svg $ elm install elm/random Main.elmを作成し、最低限の文を定義しておく。
module Main exposing (..) import Browser import Svg exposing (..) import Svg.Attributes as SA exposing (..) import Svg.Events as SE exposing (..) import Random 円の描画 こんな感じの円を描画する。
1 SVGでは次のように書く。
&amp;lt;svg width=&amp;#34;100px&amp;#34; height=&amp;#34;100px&amp;#34;&amp;gt; &amp;lt;g transform=&amp;#34;translate(50, 50)&amp;#34;&amp;gt; &amp;lt;circle r=&amp;#34;10&amp;#34; fill=&amp;#34;white&amp;#34; stroke=&amp;#34;black&amp;#34; /&amp;gt; &amp;lt;text text-anchor=&amp;#34;middle&amp;#34; dominant-baseline=&amp;#34;central&amp;#34;&amp;gt;1&amp;lt;/text&amp;gt; &amp;lt;/g&amp;gt; &amp;lt;/svg&amp;gt; 円の情報で必要なのは次の4つ:
x座標 y座標 半径 text要素の文字列 そこで円は次のように定義する。
type alias Circle = { r: Float , x: Float , y: Float , text: String } Elmでは宣言的にSVGやHTMLを書けるので、SVGの文法とほとんど似た構造でかける。直感的で嬉しい。</description>
    </item>
    
    <item>
      <title>JavaScript/Elm ビット演算のときにはまったこと</title>
      <link>https://bombrary.github.io/blog/posts/js-elm-bitwise-caution/</link>
      <pubDate>Tue, 31 Dec 2019 09:34:25 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/js-elm-bitwise-caution/</guid>
      <description>結論 JavaScriptにおいて、&amp;gt;&amp;gt;&amp;gt;以外のビット演算は32ビット符号付き整数値として扱われる。
→ 例えば&amp;amp;|^~の計算前に、オペランドに型変換が起こる(ソース)。 JSにおいて数字はNumberという型しかないが、ビット演算のときだけ32ビット整数値に変換されるっぽい JavaScriptにおいて、x &amp;gt;&amp;gt;&amp;gt; 0を使うと符号なし整数になる。 負数を2で割り続けても、コンピュータにおける2進表現にはならない。 これはすごく当たり前だった コンピュータにおける2進数表現にしたいなら，論理シフトを使うこと。 ElmはJavaScriptに変換されるので、上の事実はすべてElmでも当てはまる。 各種ビット演算は、JSの演算をそのまま使っているっぽい(ソース) 検証コード $ elm init src/MyBitwise.elmを作成し、内容を以下のようにする。
module MyBitwise exposing (..) import Bitwise toBinaryString : Int -&amp;gt; String toBinaryString x = let bit = Bitwise.and x 1 rem = Bitwise.shiftRightZfBy 1 x in if rem &amp;gt; 0 then (toBinaryString rem) ++ (String.fromInt bit) else String.fromInt bit elm replを起動し、試す。まず必要なモジュールをimportする。
$ elm repl &gt; import Bitwise &gt; import MyBitwise exposing (..) 232-1 = 4294967295を2進表示すると、1が32個並んだ数になる。32ビット整数の2の補数表現では、-1と4294967295は同じ表現方法になる。</description>
    </item>
    
    <item>
      <title>iPhoneアプリ開発メモ - 棒グラフの作成(Chartsの利用)</title>
      <link>https://bombrary.github.io/blog/posts/iphone-barchart-ioscharts/</link>
      <pubDate>Sun, 29 Dec 2019 22:37:26 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/iphone-barchart-ioscharts/</guid>
      <description>今度は外部ライブラリChartsを利用して、棒グラフを作成してみる。
目標 値が最大のデータは色をオレンジにする アニメーションがある 棒グラフの上に値を表示する ページ切り替えができる棒グラフを作る タップしたらイベントを発生させる 1〜3、5は機能としてある。4だけ頑張って作る。思い通りのレイアウトにするためにはプロパティとかドキュメントとかを漁る必要があるが、どこにどのプロパティがあるのかは大体予想できる。
ChartDataSet.colorsで各棒の色を変更できる。 BarChartView.animate(yAxisDuration:)を利用。 BarChartView.drawValueAboveBarEnabled = trueとする。表示形式を変更するためにはChartDataSet.valueFormatterにフォーマット用のオブジェクトを指定する。 ScrollViewの中ににBarChartViewを複数配置。 ChartViewDelegateを利用。 その他デフォルトの設定だと表示する情報量が多すぎるので、いくつかのプロパティをいじる。
Chartsのインストール まず、CocoaPodsがインストールされていることが前提。
プロジェクトフォルダで以下のコマンドを実行。
$ pod init podfileが作成されるので、それを編集する。use_frameworks!の下に以下の記述を追加。
pod &amp;#39;Charts&amp;#39; プロジェクトフォルダで以下のコマンドを実行。
$ pod install 以降、プロジェクトはプロジェクト名.xcodeprojではなくプロジェクト名.xcworkspaceから開く。
基本 import UIKit import Charts struct BarChartModel { let value: Int let name: String } class ViewController: UIViewController { let barItems = [ (7, &amp;#34;太郎&amp;#34;), (1, &amp;#34;次郎&amp;#34;), (2, &amp;#34;三郎&amp;#34;), (6, &amp;#34;四郎&amp;#34;), (3, &amp;#34;五郎&amp;#34;), (9, &amp;#34;六郎&amp;#34;), (2, &amp;#34;七郎&amp;#34;), (3, &amp;#34;八郎&amp;#34;), (1, &amp;#34;九郎&amp;#34;), (5, &amp;#34;十郎&amp;#34;), (1, &amp;#34;十一郎&amp;#34;), (1, &amp;#34;十二郎&amp;#34;), (6, &amp;#34;十三郎&amp;#34;) ] override func viewDidLoad() { super.</description>
    </item>
    
    <item>
      <title>iPhoneアプリ開発メモ - 棒グラフの作成(UIStackView) (2) アニメーションとタップ処理</title>
      <link>https://bombrary.github.io/blog/posts/iphone-barchart-view02/</link>
      <pubDate>Thu, 26 Dec 2019 10:00:00 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/iphone-barchart-view02/</guid>
      <description>棒グラフをアニメーションさせたり、タップしたら詳細画面に遷移するようにしたい。
(寄り道) StackViewのアニメーション 自分がいままでやったことがあるのは以下のような感じで、frameやlayer.positionをいじるパターン。
UIView.animate(withDuration: 1, animations: { view.position.x += 100 view.frame.size.height += 20 }); ただし、これをAutoLayoutと混ぜて使おうとすると動かなかったり、動いたとしても変な挙動を起こす。そもそも、AutoLayoutは制約を設定して位置やサイズを決定する仕組みで、frameは位置やサイズを手動で決める仕組み。これが競合を起こすのは当たり前な気もする。
StackViewはframeを設定しても何も反応しない。これは内部的にAutoLayoutっぽいことをやっているからなのかもしれない。例えば次のようにしてもStackViewの子要素は変更されない。
subView.frame.size.height = 100 stackView.addArrangedSubview(subView) その代わり、次のようにすると、ちゃんと子要素の高さは100になる。
subView.heightAnchor.constraint(equalToConstant: 100).isActive = true stackView.addArrangedSubview(subView) よって、StackViewでアニメーションするためには、AutoLayoutでのアニメーションの方法を知る必要がある。
AutoLayoutでのアニメーション 例えば、「ボタンを押すと長方形が0から伸びる」アニメーションを実現したい。
まずは次のように、高さ制約を0に設定しておく。ただし、それを何か変数に入れておく。
var constraint: NSLayoutConstraint view.addSubview(view0) constraint = view0.heightAnchor.constraint(equalToConstant: 0) constraint.isActive = true アニメーションをしたいタイミングで、次のように書けば良い。
UIView.animate(withDuration: 1, animations: { constraint.constant = 100 view.layoutIfNeeded() }) constraintにはconstantプロパティがあるので、そこで制約の定数を変更できる。layoutIfNeededは、アプリにレイアウト変更を直ちにさせるメソッド。
画面遷移後、下から長方形が伸びてくる処理は次のように書ける。
class ViewController: UIViewController { var constraint: NSLayoutConstraint! override func viewDidLoad() { super.viewDidLoad() let myView = UIView() myView.</description>
    </item>
    
    <item>
      <title>iPhoneアプリ開発メモ - 棒グラフの作成(UIStackView) (1)</title>
      <link>https://bombrary.github.io/blog/posts/iphone-barchart-view01/</link>
      <pubDate>Tue, 24 Dec 2019 13:07:39 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/iphone-barchart-view01/</guid>
      <description>前に頑張ってCoreGraphicsを使って棒グラフを描いたが、やはりViewを棒に見立てて扱った方が良さそうだ。考えられる利点は次の3つ。
タップ時に何かアクションを起こせる。例えば、棒グラフをタップしたら、そのデータに関する詳細ページに飛ぶ、などの処理が実装できる。 アニメーションについてのコードを描きやすい。例えば棒グラフの高さを0から伸ばしていくアニメーションが実現できる。 StackViewで棒を管理すれば、棒のサイズや棒同士の間隔を自動で設定してくれる これはやるしかない。
基本的にはこちらを参考にしながら進めていく。
UIStackViewをコード上で使う基本 とりあえず使い方を確認する。
Main.storyboard こんな感じにする。
ViewController.swift class ViewController: UIViewController { let colors: [UIColor] = [.systemRed, .systemBlue, .systemPink, .systemGreen, .systemIndigo] let percentages: [CGFloat] = [0.1, 0.2, 0.5, 0.3, 0.9] @IBOutlet weak var graphStackView: UIStackView! override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view. graphStackView.distribution = .fillEqually graphStackView.alignment = .bottom graphStackView.spacing = 20 graphStackView.isLayoutMarginsRelativeArrangement = true graphStackView.layoutMargins.left = 20 graphStackView.layoutMargins.right = 20 for (color, percentage) in zip(colors, percentages) { addBar(bgColor: color, percentage: percentage) } } private func addBar(bgColor: UIColor, percentage: CGFloat ) { let view = UIView() let height = graphStackView.</description>
    </item>
    
    <item>
      <title>iPhoneアプリ開発メモ - 棒グラフの作成(UIKit/CoreGraphics) (2)</title>
      <link>https://bombrary.github.io/blog/posts/iphone-barchart-cg02/</link>
      <pubDate>Sun, 22 Dec 2019 15:10:30 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/iphone-barchart-cg02/</guid>
      <description>目標 前回の棒グラフを複数ページにする 今回は、1ページに最大5本の棒が並ぶ、とする。 ページは横スライドで切り替える プロジェクトは前回のものを引き継がず、新しく作る。
用いるデータ ViewController.swiftが次のようなデータを持っていることを想定する。
var dataSource = [ (7, &amp;#34;太郎&amp;#34;), (1, &amp;#34;次郎&amp;#34;), (2, &amp;#34;三郎&amp;#34;), (6, &amp;#34;四郎&amp;#34;), (3, &amp;#34;五郎&amp;#34;), (9, &amp;#34;六郎&amp;#34;), (2, &amp;#34;七郎&amp;#34;), (3, &amp;#34;八郎&amp;#34;), (1, &amp;#34;九郎&amp;#34;), (5, &amp;#34;十郎&amp;#34;), (1, &amp;#34;十一郎&amp;#34;), (1, &amp;#34;十二郎&amp;#34;), (6, &amp;#34;十三郎&amp;#34;) ] このデータは、後で整形してグラフ描画用のデータに変換する。
UScrollViewの配置 Main.storyboardにUIScrollViewを配置する。サイズ設定はコードで行うので、ここでは単に配置するだけ。
その後、UIScrollViewのOutlet接続をViewController.swiftに対して行う。
UIScrollVieの設定 「スクロールの対象となるコンテンツを中に入れる」だけで、スクロール可能なViewが作れる。ただし、思い通りの表示にするためには、UIScrollViewやコンテンツのサイズを設定しておく必要がある。
複数ページを持つコンテンツを作りたいので、コンテンツ用Viewの中にページ用のViewが複数存在する状態になる。なのでページの位置やサイズもちゃんと設定する。
ScrollViewのレイアウト こんな感じにする。
なのでコードはこんな感じにする。
class ViewController: UIViewController { @IBOutlet weak var scrollView: UIScrollView! let marginX: CGFloat = 80 let marginY: CGFloat = 40 override func viewDidLoad() { super.</description>
    </item>
    
    <item>
      <title>iPhoneアプリ開発メモ - 棒グラフの作成(UIKit/CoreGraphics) (1)</title>
      <link>https://bombrary.github.io/blog/posts/iphone-barchart-cg01/</link>
      <pubDate>Sat, 21 Dec 2019 20:10:36 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/iphone-barchart-cg01/</guid>
      <description>iPhoneアプリで棒グラフを描く方法として考えられるのは次の3通り。
ライブラリを使う - Chartsというライブラリがある。おそらくこれが一般的な選択肢。 Viewを棒グラフに見立てる - UIStackViewをうまく使った例にこんなのがある。 CoreGraphicsを使って手で描画する - 厳密にはUIKit側でこれを扱いやすくしたものがあるみたいで、Drawingとしてまとめられている。 ここではCoreGraphicsの練習を兼ねて、3つ目の方法で棒グラフを書いてみる。
目標 棒グラフを表示する 棒グラフの先端に値を表示する 今回用いるデータは(ラベル, 整数値)とする 整数値を棒グラフの高さとし、棒グラフの頂点にその数字を描く ラベルは棒グラフの下に描く 整数値が最も大きなものの色をオレンジ色にする 画面の大きさに関わらない図を作る 要するに以下のようなものを作る。
細かいレイアウト 画面の大きさに応じて棒グラフのサイズを変更する必要があるため、レイアウトについてそれなりに決めておく。テキストについては適当なサイズに設定する。
ビューの幅を$W$、barWidthを$w$、データの個数を$n$とする。するとpadXの個数は$n+1$である。このとから、$w$は次のように計算できる。
$$ \begin{aligned} &amp;amp; wn + \frac{w}{2}(n+1) = W \\ \Leftrightarrow&amp;amp;\ w = \frac{2W}{3n + 1} \end{aligned} $$
この計算結果をbarWidthとして利用する。
準備 Main.storyboardを次のようにしておく。
GraphViewのClassをGraphViewにする。新たにGraphView.swiftを作っておく。
GraphView.swiftを作る 以下が雛形。
class GraphView: UIView { override func awakeFromNib() { } let data: [(String, CGFloat)] = [(7, &amp;#34;太郎&amp;#34;), (1, &amp;#34;次郎&amp;#34;), (2, &amp;#34;三郎&amp;#34;), (6, &amp;#34;四郎&amp;#34;), (3, &amp;#34;五郎&amp;#34;)] override func draw(_ rect: CGRect) { } } Viewの枠線 layer.</description>
    </item>
    
    <item>
      <title>iPhoneアプリ開発メモ - UIPresentationControllerの利用</title>
      <link>https://bombrary.github.io/blog/posts/iphone-uipresentation/</link>
      <pubDate>Thu, 19 Dec 2019 10:01:42 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/iphone-uipresentation/</guid>
      <description>UIPresentationControllerを利用すると、モーダル表示の方法をカスタマイズできる。これについて備忘録を残す。
そもそもモーダル表示とは そもそもモーダル表示って何？と思ったので調べる。モーダルと検索すると「モーダルウインドウ」の話がよく出てくる。これは「ある操作を終えるまで親ウインドウの操作ができない子ウインドウ」という意味で使われているようだ。これはモーダル表示と似たような意味なのだろうか。判然としないので一次資料を漁る。
AppleのHuman Interface GuidelineにModalityの意味が書いてあって、これを引用すると、
Modality is a design technique that presents content in a temporary mode that’s separate from the user&#39;s previous current context and requires an explicit action to exit. [意訳] Modalityとは、ユーザの以前の文脈から離れた一時的なモードでコンテンツを表示するデザインの手法。そのモードを終了するためには何か明示的なアクションを必要とする。 ほとんど同じ意味っぽい。
例えば次のようなモーダル表示(Page Sheet)の場合，呼び出し元が下にあってその上に青いビューが載っている。ここでは、「上から下に引っ張る」というアクションを起こすことで、このビューを閉じることができる。
用意するもの 表示元のViewController 表示先のViewController UIPresentationControllerのサブクラス - これが表示先のViewControllerの表示方法を規定する。 ここでは、表示先のViewControllerのStoryboard IDをdestとする．
準備 まずはボタンをクリックすると表示されるものだけ作る。
Main.storyboard 表示元にはボタンを配置する。表示先はラベルを配置し、適切なConstraintを設定しておく。
ViewController.swift ボタンのAction接続を作る。ボタンがタップされたら遷移するようにする。
class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view. } @IBAction func buttonTapped(_ sender: Any) { let vc = (storyboard?</description>
    </item>
    
    <item>
      <title>Elm/JavaScript ローカルサーバーで通信する際にハマったこと</title>
      <link>https://bombrary.github.io/blog/posts/elm-with-localserver/</link>
      <pubDate>Thu, 19 Dec 2019 09:50:00 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/elm-with-localserver/</guid>
      <description>今回たまたまクライアント側でElmを使ったけど、これはElmに限ったことではない。
結論 Client側での留意点 urlはlocalhost:[port]ではなくhttp://localhost:[port]と指定しなければならない。つまり、URLにはちゃんとスキーム名を指定する。 Server側での留意点 Access-Control-Allow-Originに関連するヘッダーをちゃんと設定する。 成功コード プログラムの内容 サーバーは{ &amp;quot;msg&amp;quot; : &amp;quot;Hello, World!&amp;quot; }という内容のJSONを送ってくるので、クライアントはその値を受け取って&amp;quot;Success: Hello, World!&amp;ldquo;を出力する。それだけ。
Client: Elm module Main exposing (..) import Browser exposing (..) import Json.Decode exposing (..) import Http exposing (..) import Html exposing (..) import Html.Attributes exposing (..) main = Browser.element { init = init , update = update , view = view , subscriptions = subscriptions } type Model = Loading | Failed | Success String init : () -&amp;gt; (Model, Cmd Msg) init _ = ( Loading, getServer ) type Msg = GotData (Result Http.</description>
    </item>
    
    <item>
      <title>D3.js 01信号の可視化</title>
      <link>https://bombrary.github.io/blog/posts/d3js-01signal/</link>
      <pubDate>Tue, 17 Dec 2019 13:56:36 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/d3js-01signal/</guid>
      <description>信号に関する授業を聴いていたらふと思い立ったのでやってみた。
コード index.html 個人的テンプレを書く。
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;ja&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;0-1 Signal&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;0-1 Signale&amp;lt;/h1&amp;gt; &amp;lt;svg&amp;gt; &amp;lt;/svg&amp;gt; &amp;lt;script src=&amp;#34;https://d3js.org/d3.v5.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;script.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; script.js JavaScriptでflatMap使うのはこれが初めてかも。
const format = (data, w) =&amp;gt; { const pairs = d3.pairs(data); const deltas = pairs.flatMap(e =&amp;gt; { let sig = e.toString() if (sig == &amp;#39;0,0&amp;#39;) { return [[1,0]]; } else if (sig == &amp;#39;0,1&amp;#39;) { return [[1,0],[0,-1]]; } else if (sig == &amp;#39;1,0&amp;#39;) { return [[1,0],[0,1]]; } else if (sig == &amp;#39;1,1&amp;#39;) { return [[1,0]]; } else { throw new Error(&amp;#39;invalid element.</description>
    </item>
    
    <item>
      <title>iPhoneアプリ開発メモ - TableViewCellのスワイプ処理</title>
      <link>https://bombrary.github.io/blog/posts/iphone-table-swipe/</link>
      <pubDate>Sun, 15 Dec 2019 10:27:58 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/iphone-table-swipe/</guid>
      <description>目標 スワイプしたら削除されるテーブルを作る。
準備 TableViewに最低限の設定をしておく。
Main.storyboardを次のようにする。
ViewController.swiftの内容を以下のようにする。
class ViewController: UIViewController { @IBOutlet weak var tableView: UITableView! var items = [&amp;#34;Item1&amp;#34;, &amp;#34;Item2&amp;#34;, &amp;#34;Item3&amp;#34;, &amp;#34;Item4&amp;#34;, &amp;#34;Item5&amp;#34;] override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view. tableView.dataSource = self tableView.delegate = self } } extension ViewController: UITableViewDataSource { func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&amp;gt; Int { items.count } func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell { let cell = tableView.</description>
    </item>
    
    <item>
      <title>iPhoneアプリ開発メモ - UIPageViewControllerの利用</title>
      <link>https://bombrary.github.io/blog/posts/iphone-pageview/</link>
      <pubDate>Sat, 14 Dec 2019 22:35:31 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/iphone-pageview/</guid>
      <description>目標 ウォークスルーっぽいものを作る。
メイン画面でボタンを押すとウォークスルー画面に飛ぶ。 ウォークスルー画面では、左右にスワイプすると画面が移動する。 画面下に、何ページかを教えてくれる白丸(Page Control)を配置する。 登場物 Main.storyboardとViewController.swift Walkthrough.storyboardとPageViewController.swift 準備 上に書いたものをとりあえず全て作る。ただし、PageViewControllerのサブクラスはUIPageViewControllerであることに注意。
Main.storyboard ボタンを一つ作っておく。
Walkthrough.storyboard 配置を次のようにする
Page View Controllerのidentifierはwalkとする。また、classをPageViewControllerにする。 &amp;ldquo;Page1&amp;quot;と書かれたViewControllerのidentifierはpage1とする。 &amp;ldquo;Page2&amp;quot;と書かれたViewControllerのidentifierはpage2とする。 &amp;ldquo;Page3&amp;quot;と書かれたViewControllerのidentifierはpage3とする。 以下で、Transition Styleを&amp;quot;Scroll&amp;quot;とする。もし&amp;quot;Page Curl&amp;quot;とした場合は、ページをめくるようなアニメーションになる。その代わりにPage Controlが表示されない。
PageViewController.swift 次のように書く。
class PageViewController: UIPageViewController { var controllers: [UIViewController] = [] override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view. view.backgroundColor = .black let stb = storyboard! let page1 = stb.instantiateViewController(withIdentifier: &amp;#34;page1&amp;#34;) let page2 = stb.instantiateViewController(withIdentifier: &amp;#34;page2&amp;#34;) let page3 = stb.</description>
    </item>
    
    <item>
      <title>iPhoneアプリ開発メモ - addTarget/SegmentedControl</title>
      <link>https://bombrary.github.io/blog/posts/iphone-addtarget-segmentctl/</link>
      <pubDate>Sat, 14 Dec 2019 19:44:49 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/iphone-addtarget-segmentctl/</guid>
      <description>目標 降順、昇順の切り替えができるTableViewを作成する。 準備 Main.storyborad 部品を以下のように配置する。
Segmented Controlのラベルの設定は以下で行える。
TableViewCellのindentifierはtestCellとする。
ViewController.swift 後々の処理のため、TableViewに表示するデータをitems、その元データをitemsSourceと分けることにする。
class ViewController: UIViewController { let itemsSource = [&amp;#34;items1&amp;#34;, &amp;#34;items2&amp;#34;, &amp;#34;items3&amp;#34;, &amp;#34;items4&amp;#34;, &amp;#34;items5&amp;#34;, &amp;#34;items6&amp;#34;, &amp;#34;items7&amp;#34;, &amp;#34;items8&amp;#34;] var items: [String] = [] @IBOutlet weak var segmentedControl: UISegmentedControl! @IBOutlet weak var tableView: UITableView! override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view. tableView.dataSource = self items = itemsSource } } extension ViewController: UITableViewDataSource { func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&amp;gt; Int { return items.</description>
    </item>
    
    <item>
      <title>iPhoneアプリ開発メモ - セミモーダルビューからの遷移</title>
      <link>https://bombrary.github.io/blog/posts/iphone-modal-segue/</link>
      <pubDate>Sat, 14 Dec 2019 11:00:24 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/iphone-modal-segue/</guid>
      <description>目標 セミモーダルビューを作成する セミモーダルビュー上のボタンを押すと、それを閉じた後に別ビューに遷移する。 登場物 Main.storyboardとViewController Menu.storyboardとMenuViewController Dest1.storyboard Dest2.storyboard 前提 今後Viewが増えていく状況を想定して、Storyboardを分割することを考える。Storyboard同士はStoryboard Referenceで結びつける。 セミモーダルビューの作成 検索して良く出てくるのはUIPresentationControllerを利用する方法。ただ今回はなるべくStoryboardで完結させたい。
そこで、以下のページを参考して作ることを考える。
ハンバーガーメニューを作成するには？ - Swift Life
ファイル作成 Menu.storyboard、MenuViewController、 Menu.storyboard、Dest1.storyboard、 Dest2.storyboardの5つをあらかじめ作成しておく。
Menu.storyboard classにはMenuViewControllerを指定する。部品配置は以下のようにする。
全体を包むViewを親View、その中に作ったViewを子Viewと呼ぶことにすると、
Constraintは適当に設定する。子Viewが画面下に配置されるようにする。 StackViewにはFill Equallyの設定を行っておく。 親Viewの背景色を、黒の半透明に設定する。設定手順は以下の通り。 BackgroundをBlackに設定 BackgroundをCustomに設定し直すと、カラーピッカーが現れる。そこで透明度を50%に設定する。 また、&amp;ldquo;Initial View Controller&amp;quot;にチェックをつける。
親Viewのtagを1に設定しておく。これはタッチイベントを捕捉する際に必要になる。
Dest1.storyboard、Dest2.storyboard Dest1.storyboardの部品配置は以下のようにする。
&amp;ldquo;Is initial View Controller&amp;quot;にチェックをつける。
Dest2.storyboardの部品配置は以下のようにする。
&amp;ldquo;Is initial View Controller&amp;quot;にチェックをつける。
Main.storyboard 部品配置は以下のようにする。
OpenButtonからStoryboard ReferenceへのSegueのActionは&amp;quot;Present Modally&amp;quot;を選択。Segueの設定は以下のようにする。
Storyboard Referenceにて、&amp;ldquo;Storyboard&amp;quot;をMenuに、&amp;ldquo;Referenced ID&amp;quot;を未記入にする。
&amp;ldquo;Referenced ID&amp;quot;が未記入の場合、Storyboard上のInitial View Controllerへの参照にしてくれる。もしInitial View ControllerでないViewControllerに遷移したいなら、ここに記入する。ただし、遷移先のView ControllerにてIdentifierを設定しておくことを忘れずに。
MenuViewController.swift Menu.storyboardの小ViewのOutletを作成する。名前はmenuViewとする。
その上で以下の文を追記する。
class MenuViewController: UIViewController { ... override func viewWillAppear(_ animated: Bool) { super.</description>
    </item>
    
    <item>
      <title>Socket通信勉強(2) - Pythonでの書き方/HTTPサーバーもどき作成</title>
      <link>https://bombrary.github.io/blog/posts/socket02-python/</link>
      <pubDate>Sun, 08 Dec 2019 11:09:35 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/socket02-python/</guid>
      <description>PythonでのSocket通信 やってることはCでやったときと同じである。サーバーとクライアントの通信手順は同じだし、関数名も同じである。しかしCで書いた場合に比べてシンプルに書ける。エラーは例外として投げられるため、自分で書く必要がない。またsockaddr_inなどの構造体が登場することはなく、Pythonでのbind関数とconnect関数の引数に直接アドレス・ポートを指定する。
server.py 前回と同じく、以下の手順で通信を行う。
listen(待ち受け)用のソケット作成 - socket 「どこからの接続を待つのか」「どのポートにて待ち受けするのか」を決める - bind関数の引数 ソケットにその情報を紐つける - bind 実際に待ち受けする - listen 接続要求が来たら受け入れる - accept 4によって通信用のソケットが得られるので、それを用いてデータのやりとりをする- send/recv import socket s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind((&amp;#34;&amp;#34;, 8000)) s.listen(5) (sock, addr) = s.accept() print(&amp;#34;Connected by&amp;#34; + str(addr)) sock.send(&amp;#34;Hello, World&amp;#34;.encode(&amp;#39;utf-8&amp;#39;)) sock.close() s.close() 上のコードを見れば各関数がどんな形で引数をとって、どんな値を返すのかがわかると思う。いくつか補足しておく。
bind (受け入れアドレス, ポート)というタプルを引数にとる。受け入れアドレスを空文字列にしておけば、どんなアドレスからの接続も受け入れる。つまりCでやったINADDR_ANYと同じ。
s.bind((&amp;#34;&amp;#34;, 8000)) encode Pythonのstring型をそのまま送ることはできないので、byte型に変換する。これはstring.encodeで行える。
sock.send(&amp;#34;Hello, World&amp;#34;.encode(&amp;#39;utf-8&amp;#39;)) client.py サーバーとの通信用のソケット作成 - socket サーバが待ち受けている宛先を設定 - connectの引数 2で設定した宛先に対して接続する - connect 1で作ったソケットを用いてデータのやりとりをする。 - send/recv import socket sock = socket.socket(socket.AF_INET, socket.</description>
    </item>
    
    <item>
      <title>Androidアプリ開発勉強(4) - LiveData/TableLayout/電卓アプリ作成</title>
      <link>https://bombrary.github.io/blog/posts/android04-calc/</link>
      <pubDate>Thu, 28 Nov 2019 14:24:39 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/android04-calc/</guid>
      <description>どんなアプリを作るか 電卓を作る。
市販の電卓とは違い、括弧が使えるようにする。なので、軽い構文解析を書くことになる。しかし今回の記事ではデータの扱い方やViewの組み方に焦点を当てているため、電卓の計算処理についてはかなり軽めに説明する。
プロジェクト作成 プロジェクト名は&amp;quot;Calculator&amp;quot;とする。 DataBindingは有効にする Fragmentに分ける 今回は1画面のアプリなのでわざわざFragmentに分ける必要もないのだが、「もしかしたら他にもFragmentを追加するかもしれない」というケースを想定して、一応分けてみる。
CalcFragmentを作成する。xmlファイルはfragment_calc.xmlとする。 activity_main.xmlの内容を以下のようにする。 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;merge xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34; xmlns:app=&amp;#34;http://schemas.android.com/apk/res-auto&amp;#34; xmlns:tools=&amp;#34;http://schemas.android.com/tools&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;match_parent&amp;#34; tools:context=&amp;#34;.MainActivity&amp;#34;&amp;gt; &amp;lt;fragment android:id=&amp;#34;@+id/calcFragment&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;match_parent&amp;#34; android:name=&amp;#34;com.example.calculator.CalcFragment&amp;#34; /&amp;gt; &amp;lt;/merge&amp;gt; merge Android Kotlin Fundamentals 06.2で存在を初めて知った。こうするとactivity_main.xmlでLayoutを作って、fragmentの中でもまたLayoutを作るといった冗長性を排除できる。
CalcFragmentの設定 string.xml fragment_calc.xmlに設定するための文字列定数を定義する。string.xmlを以下のようにする。
&amp;lt;resources&amp;gt; &amp;lt;string name=&amp;#34;app_name&amp;#34;&amp;gt;Calculator&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_0&amp;#34;&amp;gt;0&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_1&amp;#34;&amp;gt;1&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_2&amp;#34;&amp;gt;2&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_3&amp;#34;&amp;gt;3&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_4&amp;#34;&amp;gt;4&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_5&amp;#34;&amp;gt;5&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_6&amp;#34;&amp;gt;6&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_7&amp;#34;&amp;gt;7&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_8&amp;#34;&amp;gt;8&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_9&amp;#34;&amp;gt;9&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_plus&amp;#34;&amp;gt;+&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_minus&amp;#34;&amp;gt;-&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_mul&amp;#34;&amp;gt;*&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_div&amp;#34;&amp;gt;/&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_ac&amp;#34;&amp;gt;AC&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_eq&amp;#34;&amp;gt;=&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_lp&amp;#34;&amp;gt;(&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_rp&amp;#34;&amp;gt;)&amp;lt;/string&amp;gt; &amp;lt;/resources&amp;gt; fmagment_calc.</description>
    </item>
    
    <item>
      <title>gnuplotの使い方メモ</title>
      <link>https://bombrary.github.io/blog/posts/gnuplot/</link>
      <pubDate>Tue, 26 Nov 2019 10:59:56 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/gnuplot/</guid>
      <description>備忘録に。
インストール Macの場合はbrewでインストールできる。
$ brew install gnuplot gnuplotコマンドで起動。
ファイルをプロットする 例えばdata.txtが以下のようになっているとする。
#x #y1 #y2 0 1 2 1 2 1 2 0 2 3 1 1 これを描画する。
using X:Yで、X番目の列を横軸、Y番目の列を縦軸にする。
w lpとは&amp;quot;with linespoints&amp;quot;の略。つまり線と点を描画する。w lだと&amp;quot;with line&amp;quot;、w lp lt 3 lw 2だと&amp;quot;with linepoints linetype 3 linewidth 2&amp;quot;という意味。いろいろある。
$ set xlabel &amp;#34;X axis&amp;#34; $ set ylabel &amp;#34;Y axis&amp;#34; $ plot &amp;#34;data.txt&amp;#34; using 1:2 w pl 軸の範囲指定 例えばx軸を[0,3000]の範囲に制限して描画したいなら、次のコマンドを打つ。
$ set xrange [0:3000] こんな感じで、gnuplotはset 属性名 値で様々な設定をする印象がある。
グラフの重ね書き replotを使う方法 $ plot &amp;#34;data.</description>
    </item>
    
    <item>
      <title>Socket通信の勉強(1) - ディスクリプタ/TCPによる通信</title>
      <link>https://bombrary.github.io/blog/posts/socket01-file-tcp/</link>
      <pubDate>Sun, 24 Nov 2019 17:08:19 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/socket01-file-tcp/</guid>
      <description>Socket通信を勉強する。
前提 プログラムはMac(Mojave)で動かす。 ネットワークに関する知識はほんの少しある。 使うプログラミング言語はC++だが、ここではbetter Cの意味でしか用いない。 (寄り道) ファイル入出力 Socket通信を学んでいると、ファイルディスクリプタが出てきたので、まずはそこから勉強する。
関数定義についてはJM Projectから引用したものを用いる。これはLinuxマニュアルと同じらしいので、恐らくmanコマンドで出力されるものと同じである(ただし英語であるが)。
ファイルディスクリプタとは ファイルディスクリプタとは、ファイルと結びつけられた単なる整数値である。データの読み書きを行う場合は、この整数値を指定してアクセスする。例えばファイルtest.txtのファイルディスクリプタが4だった場合、読み書きをする関数read/writeには引数4を指定する。
個人的には、ファイルとプロセスのやりとりはあるケーブルを介して行なっているイメージがある。例えば番号4の端子にはすでにtest.txtが繋がっているとしよう。このとき、プロセスがtext.txtにアクセスしたいなら、番号4の端子にアクセスすれば良い。
ファイルの読み込み ファイルディスクリプタを用いてファイルを読み込む例を以下に示す。以下は、test.txtを読み込んで、そのファイルディスクリプタとファイルの内容を出力するプログラムである。
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; int main() { int fd = open(&amp;#34;test.txt&amp;#34;, O_RDONLY); char buf[64]; read(fd, buf, sizeof(buf)); printf(&amp;#34;fd: %d\n&amp;#34;, fd); printf(&amp;#34;%s\n&amp;#34;, buf); close(fd); return 0; } test.txtの内容は以下のようにする。
Hello, World 実行すると、以下のように出力される。fdの値は実行環境によって異なる。
fd: 3 Hello, World 以下説明するopen/read/closeは関数ではなく、全てシステムコールである。
openでファイルを開く 開きたいファイルのパスと、読み書きの方法を引数に指定する。成功するとファイルディスクリプタを返す。
#include &amp;lt;fcntl.h&amp;gt; int open(const char *pathname, int flags); readで読み込む ファイルディスクリプタと、読み取った値を保持しておくためのバッファ、また読み取るデータの長さを指定する。
#include &amp;lt;unistd.h&amp;gt; ssize_t read(int fd, void *buf, size_t count); closeでディスクリプタを解放する openで結びつけられたファイルディスクリプタはcloseで解放しなければならないことに注意。低級寄りの処理なだけあって、自動では解放してくれない。</description>
    </item>
    
    <item>
      <title>Androidアプリ開発勉強(3) - データの受け渡し</title>
      <link>https://bombrary.github.io/blog/posts/android03-dataholding/</link>
      <pubDate>Fri, 22 Nov 2019 08:53:21 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/android03-dataholding/</guid>
      <description>次の2つの事項について扱う。
DataBindingにおけるデータの受け渡し Navigationを用いた、異なるFragment間におけるデータの受け渡し さらに具体的に言うと、次の機能を持つアプリを作る
MainFragmentにはEditTextが1つある。 EditTextが入力されると、TextViewが&amp;quot;String: [EditTextの文字列]&amp;ldquo;に変わる。 Buttonが押されると、ReverseFragmentに遷移する ReverseFragmentは、MainFragmentのテキストフィールドの文字列を受け取って、それを逆順にした文字列を表示する。 Android Kotlin Fundamentals Courseでの05辺りを勉強した記録なので、詳しいことはそちらに載っている。
プロジェクト初期設定 &amp;ldquo;Empty Project&amp;quot;として作成して、名前を&amp;quot;DataTest&amp;quot;とする。
build.gradle(module:App)について、dataBindingの設定をしておく。
次のようにMainFragmentとReverseFragmentを作成しておく。作成時、&amp;ldquo;Create layout XML?&amp;ldquo;にのみチェックをつけておく。 MainFragmentの設定 fragment_main.xmlを次のようにする。
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;layout xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34; xmlns:tools=&amp;#34;http://schemas.android.com/tools&amp;#34; tools:context=&amp;#34;.main.MainFragment&amp;#34;&amp;gt; &amp;lt;data&amp;gt; &amp;lt;variable name=&amp;#34;myMsg&amp;#34; type=&amp;#34;com.example.datatest.main.MainFragment.MyMsg&amp;#34; /&amp;gt; &amp;lt;/data&amp;gt; &amp;lt;LinearLayout android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34; android:orientation=&amp;#34;vertical&amp;#34; android:layout_gravity=&amp;#34;center_vertical&amp;#34; &amp;gt; &amp;lt;EditText android:id=&amp;#34;@+id/edit_text&amp;#34; android:layout_width=&amp;#34;wrap_content&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34; android:hint=&amp;#34;@string/hello_blank_fragment&amp;#34; android:layout_gravity=&amp;#34;center_horizontal&amp;#34; android:textAlignment=&amp;#34;center&amp;#34; /&amp;gt; &amp;lt;TextView android:id=&amp;#34;@+id/text_view&amp;#34; android:layout_width=&amp;#34;wrap_content&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34; android:text=&amp;#34;@={myMsg.text}&amp;#34; android:layout_gravity=&amp;#34;center_horizontal&amp;#34; android:textAlignment=&amp;#34;center&amp;#34; /&amp;gt; &amp;lt;Button android:id=&amp;#34;@+id/button&amp;#34; android:layout_width=&amp;#34;wrap_content&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34; android:layout_gravity=&amp;#34;center_horizontal&amp;#34; android:text=&amp;#34;@string/to_reverse_fragment&amp;#34; android:textAllCaps=&amp;#34;false&amp;#34; /&amp;gt; &amp;lt;/LinearLayout&amp;gt; &amp;lt;/layout&amp;gt; 重要なのは以下の部分で、これはMainFragment.ktで定義されたMyMsgというクラスのインスタンスをこのファイルではmyMsgとして扱う、という意味。
&amp;lt;data&amp;gt; &amp;lt;variable name=&amp;#34;myMsg&amp;#34; type=&amp;#34;com.</description>
    </item>
    
    <item>
      <title>Androidアプリ開発勉強(2) - Navigationの基本</title>
      <link>https://bombrary.github.io/blog/posts/android02-navigation/</link>
      <pubDate>Wed, 20 Nov 2019 09:03:17 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/android02-navigation/</guid>
      <description>Navigationを用いて画面遷移をやってみる。具体的には以下の処理を行う。
Fragment01とFragment02を用意する Fragment01でボタンが押されたらFragment02に遷移する Android Kotlin Fundamentals Courseでの03辺りを勉強した記録なので、詳しいことはそちらに載っている。
Navigationについて 異なるFragment間の遷移を制御する仕組み。遷移の設定を視覚的に行えるらしい。
これ以前はIntentという仕組みを用いていたらしい。これについては必要になりそうならいつか調べる。
プロジェクト作成 Empty Activityを選択し、名前をNavigation Testとする。
build.gradle(Module: app)でDataBindingを有効にしておく。
Fragmentの作成 layouts/にFragmentを作成する。&amp;ldquo;Create layout XML?&amp;ldquo;だけチェックをつけておく。Fragmentは2つ作成し、それぞれ&amp;quot;Fragment01&amp;quot;と&amp;quot;Fragment02&amp;quot;とする。xmlファイルはそれぞれfragment_fragment01.xml、fragment_fragment02.xmlとする。
まずTextViewのtext要素に設定するための定数をstrings.xmlに内容を追加しておく。 &amp;lt;resources&amp;gt; &amp;lt;string name=&amp;#34;app_name&amp;#34;&amp;gt;NavigationTest&amp;lt;/string&amp;gt; &amp;lt;!-- TODO: Remove or change this placeholder text --&amp;gt; &amp;lt;string name=&amp;#34;hello_blank_fragment&amp;#34;&amp;gt;Hello blank fragment&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;fragment01&amp;#34;&amp;gt;Fragment01&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;fragment02&amp;#34;&amp;gt;Fragment02&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;click&amp;#34;&amp;gt;Click&amp;lt;/string&amp;gt; &amp;lt;/resources&amp;gt;
fragment_fragment01.xmlの内容は以下の通りにする。Buttonを追加し、textを@string/clickに設定する。TextViewのtextを@string/fragment01に設定する。また全体をConstraintLayoutで包み、DataBindingのためにlayoutでさらに包む。
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;layout xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34; xmlns:app=&amp;#34;http://schemas.android.com/apk/res-auto&amp;#34; xmlns:tools=&amp;#34;http://schemas.android.com/tools&amp;#34; tools:context=&amp;#34;.Fragment01&amp;#34;&amp;gt; &amp;lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;match_parent&amp;#34;&amp;gt; &amp;lt;TextView android:id=&amp;#34;@+id/text_fragment01&amp;#34; android:layout_width=&amp;#34;wrap_content&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34; android:text=&amp;#34;@string/fragment01&amp;#34; app:layout_constraintBottom_toBottomOf=&amp;#34;parent&amp;#34; app:layout_constraintEnd_toEndOf=&amp;#34;parent&amp;#34; app:layout_constraintStart_toStartOf=&amp;#34;parent&amp;#34; app:layout_constraintTop_toTopOf=&amp;#34;parent&amp;#34; /&amp;gt; &amp;lt;Button android:id=&amp;#34;@+id/button&amp;#34; android:layout_width=&amp;#34;wrap_content&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34; android:text=&amp;#34;@string/click&amp;#34; app:layout_constraintBottom_toTopOf=&amp;#34;@+id/text_fragment01&amp;#34; app:layout_constraintEnd_toEndOf=&amp;#34;parent&amp;#34; app:layout_constraintStart_toStartOf=&amp;#34;parent&amp;#34; app:layout_constraintTop_toTopOf=&amp;#34;parent&amp;#34; /&amp;gt; &amp;lt;/androidx.</description>
    </item>
    
    <item>
      <title>Androidアプリ開発勉強(1) - onClick/DataBinding/Fragment</title>
      <link>https://bombrary.github.io/blog/posts/android01-helloworld/</link>
      <pubDate>Tue, 19 Nov 2019 19:54:40 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/android01-helloworld/</guid>
      <description>Android + Kotlinを用いてアプリ開発をするときの勉強メモ。勉強メモなので備忘録程度にしか書いてない。
次のことをやった。
ボタンを押すとToastを表示 DataBindingを用いる Fragmentを用いる Fragment + DataBinding Android Kotlin Fundamentals Courseでの01-03辺りを勉強した記録なので、詳しいことはそちらに載っている。
前提 Kotlinは未学習だが雰囲気で読める Android開発は完全未経験 iPhoneアプリ開発は少しだけ経験 Android Studioの環境構築は済んでいる エミュレータのインストールも完了している Build &amp;amp; Runの方法も知っている プロジェクト作成 とりあえずプロジェクト名はTestProjectとする。
左側のペインに色々ディレクトリ・ファイルがある。色々漁ってみると、次のようなものがある。
java/com.example.testapplication/: 基本的にはこの中にKotlinのソースコードを入れるっぽい。ディレクトリ名がjavaなのは歴史的な理由らしい。 res/: resourceの略で、画面や定数の定義がこの中に色々入っている。 res/layout: 画面の定義ファイルが入っている res/values: 定数の定義が入っている res/values/colors.xml: 色定義 res/values/strings.xml: 文字列定数の定義 res/values/styles.xml: styleの定義。画面の部品のstyleをCSSみたいに設定するためのもの。 build.gradle: Buildの際の様々な設定を記したファイル。 ボタンの配置 res/layouts/activity_main.xmlにメイン画面の定義が書かれている。中央ペイン左下にDesign/Textを切り替えるタブがある。
Designタブ GUIで画面の構造をいじるための画面。直感的に操作できる。色々なペインで分かれている。
Palette: ドラックアンドドロップできる。 Component Tree: 部品同士の階層構造を表示している。内部構造はXMLなので部品は階層構造になっている。 Attributes: 部品の様々な属性を設定。たくさんあるが、虫眼鏡マークで検索可能。便利。中でもid属性は重要。 id: 部品の識別子。プログラムからアクセスするためにここの設定が必要。 Component Treeにおいて、rootがConstraint Layoutであることに注目。これはConstraint(制約)を用いて部品の配置を設定するためのLayoutである。Constraintについてはやってみた方が早い。
PaletteからButtonをドラッグ&amp;amp;ドロップする。 Buttonをクリックすると4辺が白丸になる。以下のようにしてConstraintを設定する。ボタンの配置は一意に決まる。 上/右/左側の丸を画面上/右/左端にくっつける 下側の丸をTextViewの上端にくっつける こんな感じでカーソルで引っ張って部品の位置を決定していく。Padding/Margin、Biasなどの設定はAttributeの方で行える。
次にButtonのテキストを設定する。
Attributeタブのtext属性を見つける。入力欄の右に細い長方形があるのでクリックすると&amp;quot;Pick a Resource&amp;quot;というウインドウが現れる。右上の&amp;quot;Add new resource&amp;quot; → &amp;ldquo;New string value&amp;quot;を選ぶ。設定を以下のようにする。 Resource name: click Resource value: Click すると、新たに文字列定数clickが追加され、その定数が使われる。res/values/strings.</description>
    </item>
    
    <item>
      <title>Djangoの勉強でTodoリストを作る</title>
      <link>https://bombrary.github.io/blog/posts/django-todo-list/</link>
      <pubDate>Fri, 15 Nov 2019 08:26:41 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/django-todo-list/</guid>
      <description>更新(2021/06/13): いくつか間違っていたところがあったので修正。
どんなTodoリストを作るか Todoの登録 情報は短いテキストだけ Todoをリスト表示 Todoをクリックすると削除 サイトの作成 適当なディレクトリで次のコマンドを実行すると、mysiteというディレクトリが作られる。
$ django-admin startproject mysite 以降はmysiteディレクトリで作業する。
アプリの作成 mysiteディレクトリにて以下のコマンドを実行すると、todo_listというディレクトリが作られる。ここに実際のアプリの処理を記述していく。
$ python3 manage.py startapp todo_list 続いてmysite/mysite/settings.pyを開いて、INSTALL_APPSを以下の記述にする。&#39;todo_list.apps.TodoListConfig&#39;を追加しただけ。これはデータベース作成やテンプレート作成のために、djangoがtodo_listのディレクトリを教えているっぽい。Todo_listConfigかと思ったが違うらしい(エラーで「TodoListConfigだよ」と教えてくれた。優しい)。
INSTALLED_APPS = [ &amp;#39;todo_list.apps.TodoListConfig&amp;#39;, &amp;#39;django.contrib.admin&amp;#39;, &amp;#39;django.contrib.auth&amp;#39;, &amp;#39;django.contrib.contenttypes&amp;#39;, &amp;#39;django.contrib.sessions&amp;#39;, &amp;#39;django.contrib.messages&amp;#39;, &amp;#39;django.contrib.staticfiles&amp;#39;, ] viewの作成 mysite/todo_list/views.pyを編集する。とりあえずviewが動くかどうかだけ確認したいので、レスポンスは適当な文字列にする。
from django.http import HttpResponse # Create your views here. def index(request): return HttpResponse(&amp;#39;Hello&amp;#39;) urlの設定 まずmysite/mysite/urls.pyの設定をする。urls.pyとは「どんなurlにアクセスされたらどんなviewに処理を任せるか」を記述したものっぽい。ここでは、todo_list/で始まるurlだったらtodo_list/urls.pyに処理を任せるように書いている。
from django.contrib import admin from django.urls import include, path urlpatterns = [ path(&amp;#39;todo_list/&amp;#39;, include(&amp;#39;todo_list.urls&amp;#39;)), path(&amp;#39;admin/&amp;#39;, admin.site.urls), ] ということでmysite/todo_list/urls.pyの設定をする。恐らく存在しないので新しく作成する。todo_list/以降に何も指定されなかったら表示をviews.pyのindex関数に任せるように書いている。
from django.urls import path from .</description>
    </item>
    
    <item>
      <title>置換(Permutaion)の勉強メモ(1)</title>
      <link>https://bombrary.github.io/blog/posts/permutation/</link>
      <pubDate>Tue, 12 Nov 2019 10:07:09 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/permutation/</guid>
      <description>置換について、線形代数の教科書に出てきたけど、授業ではあまり触れられなかったので自分で勉強してみる。以下はそのメモ。
置換の定義 定義(置換) $X_n$は$n$個の元を持つ集合とする。このとき、全単射写像 $\sigma: X_n \rightarrow X_n$ を$X_n$上の置換(Permutation)と呼ぶ。 言い換えると、$X_n$を適当に並べたとき、置換 $\sigma$ とはそれを並び替える方法を表したものである。
置換と聞くとReplacementがまず思い浮かぶけど、ここではPermutationなのね。
例 $X_3 = {1,2,3}$ とする。このとき、 $X_n$ の元を並べて $(1,2,3)$ としよう。このとき、 $\sigma(1)=2,\sigma(2)=3,\sigma(3)=1$ とすれば、写像 $\sigma$ は $X_3$ 上の置換となる。このとき、 $(1,2,3)$ という列が $\sigma$ によって $(2,3,1)$ に並び替えられたように見える。 $X_n$の元はなんでも良いが、以後説明のため$X_n = \lbrace 1,2,\ldots,n \rbrace$とする。
置換は以下のように表示することがある：$\sigma(i) = p_i\ (i=1,\ldots,n)$について、
$$ \sigma = \begin{pmatrix} 1 &amp;amp; 2 &amp;amp; \ldots &amp;amp; n \\ p_1 &amp;amp; p_2 &amp;amp; \ldots &amp;amp; p_n \end{pmatrix} $$
先ほど置換とは $X_n$ を適当に並べたとき、置換 $\sigma$ とはそれを並び替えたもの、と表現した。実際、$\sigma$はただの写像なので、並び替えというより対応関係だけが大事である。上の表示方法はあくまで「上の段の元と下の段の元の対応関係」にだけ着目している。従って、上の段が$1,2,\ldots n$という並びになるとは限らない。</description>
    </item>
    
    <item>
      <title>Elmで超簡易Todoリスト</title>
      <link>https://bombrary.github.io/blog/posts/elm-todo-list/</link>
      <pubDate>Sun, 10 Nov 2019 21:08:12 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/elm-todo-list/</guid>
      <description>Todoリストと言っても、フィールドに入力した内容がli要素として追加されるだけ。
Elm習いたてなので、何か無駄があるかも。
個人的になるほどと思った点はList.mapを利用してli要素を生成するところで、これは要素を生成する関数が子要素のリストを引数に取るから実現できる。
import Browser import Html exposing (..) import Html.Attributes exposing (..) import Html.Events exposing (onClick, onInput) main = Browser.sandbox { init = init, update = update, view = view } --Model type alias Todo = { description : String } type alias Model = { todos : List Todo , input : Todo } init : Model init = { todos = [] , input = Todo &amp;#34;&amp;#34; } type Msg = Add | Change String --Update update : Msg -&amp;gt; Model -&amp;gt; Model update msg model = case msg of Add -&amp;gt; { model | todos = model.</description>
    </item>
    
    <item>
      <title>HugoセットアップからGitHubにデプロイするまでの備忘録</title>
      <link>https://bombrary.github.io/blog/posts/hugo-setup/</link>
      <pubDate>Sat, 09 Nov 2019 19:33:37 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/hugo-setup/</guid>
      <description>簡単にセットアップ方法を備忘のために書いておく
前提 MacOS Mojave Homebrew 2.1.16 GitHubのblogリポジトリで公開する この記事でディレクトリを表記する時は、blogローカルリポジトリの最上位を/で表現する インストール ターミナルにて以下のコマンドを叩く
$ brew install hugo ブログサイトの作成 blogサイトのローカルリポジトリがある前提で進める。blogディレクトリに移動して以下のコマンドを実行する。 forceフラグをつけると、今のディレクトリに何かファイルがあった場合でもサイトを生成してくれる。僕の環境の場合はREADME.mdしかなかったので何も上書きされなかったが、hugoが生成するファイルと名前がかぶる場合は、何かファイルが上書きされる恐れがあるので注意。
$ hugo new site ./ --force すると、何やらたくさんファイルやディレクトリを生成してくれる。
テーマの追加 contrast-hugoが気に入ったのでこれを使う。
/themesに移動して、contrast-hugoのファイルをcloneしてくる
$ git clone https://github.com/niklasbuschmann/contrast-hugo.git 後でテーマをいじるので、一応テーマ名を変更しておく。contrast-hugoをch-modifiedに変更する。
シンタックスハイライトの設定 Chromaというハイライターが入っているらしい。そのテーマはこちらで見られる。今回はgithubというテーマを利用する。
/config.tomlでpygmentsStyle=githubと指定すると、スタイルをhtmlに直接埋め込んでくれる。しかしCSSを後で自分でいじりたいのでこの方法は用いない。その代わり、pygmentsUseClasses=trueとして、CSSを利用することにする。
/themes/ch-modified/static/cssに移動して、以下のコマンドを実行する。
$ hugo gen chromastyles --style=github &amp;gt; syntax.css configの設定 /config.tomlの内容を以下の通りにする。ほとんどの設定項目がデフォルトのもので、正直意味が分かっていないものもある。コメントアウトのところはAboutページのリンクを貼るものだが、Aboutページができたらコメントを外そうと思っている。
baseURL = [ブログのURL] title = [ブログのタイトル] author = [作成者] paginate = 3 languageCode = &amp;#34;ja-jp&amp;#34; DefaultContentLanguage = &amp;#34;ja&amp;#34; enableInlineShortcodes = true footnoteReturnLinkContents = &amp;#34;^&amp;#34; theme = [テーマ] publishDir=&amp;#34;docs&amp;#34; pygmentsUseClasses = true [menu] # 気が向いたら設定する # [[menu.</description>
    </item>
    
    <item>
      <title>Test</title>
      <link>https://bombrary.github.io/blog/posts/my-first-post/</link>
      <pubDate>Sat, 09 Nov 2019 16:00:56 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/my-first-post/</guid>
      <description>このブログではHugoを使っている。
Syntax highlighting #include &amp;lt;iostream&amp;gt; int main() { std::cout &amp;lt;&amp;lt; &amp;#34;Hello&amp;#34; &amp;lt;&amp;lt; std::endl; return 0; }
KaTeX
inline: $x = 2$ block: $$ x^2 + x + 1 = 0 $$ </description>
    </item>
    
  </channel>
</rss>
