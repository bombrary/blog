<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Chanomic Blog</title>
    <link>https://bombrary.github.io/blog/posts/</link>
    <description>Recent content in Posts on Chanomic Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Thu, 19 Dec 2019 10:01:42 +0900</lastBuildDate>
    
	<atom:link href="https://bombrary.github.io/blog/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>iPhoneアプリ開発メモ - UIPresentationControllerの利用</title>
      <link>https://bombrary.github.io/blog/posts/iphone-uipresentation/</link>
      <pubDate>Thu, 19 Dec 2019 10:01:42 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/iphone-uipresentation/</guid>
      <description>UIPresentationControllerを利用すると、モーダル表示の方法をカスタマイズできる。これについて備忘録を残す。
そもそもモーダル表示とは そもそもモーダル表示って何？と思ったので調べる。モーダルと検索すると「モーダルウインドウ」の話がよく出てくる。これは「ある操作を終えるまで親ウインドウの操作ができない子ウインドウ」という意味で使われているようだ。これはモーダル表示と似たような意味なのだろうか。判然としないので一次資料を漁る。
AppleのHuman Interface GuidelineにModalityの意味が書いてあって、これを引用すると、
 Modality is a design technique that presents content in a temporary mode that’s separate from the user&#39;s previous current context and requires an explicit action to exit. [意訳] Modalityとは、ユーザの以前の文脈から離れた一時的なモードでコンテンツを表示するデザインの手法。そのモードを終了するためには何か明示的なアクションを必要とする。  ほとんど同じ意味っぽい。
例えば次のようなモーダル表示(Page Sheet)の場合，呼び出し元が下にあってその上に青いビューが載っている。ここでは、「上から下に引っ張る」というアクションを起こすことで、このビューを閉じることができる。
  用意するもの  表示元のViewController 表示先のViewController UIPresentationControllerのサブクラス - これが表示先のViewControllerの表示方法を規定する。  ここでは、表示先のViewControllerのStoryboard IDをdestとする．
準備 まずはボタンをクリックすると表示されるものだけ作る。
Main.storyboard 表示元にはボタンを配置する。表示先はラベルを配置し、適切なConstraintを設定しておく。
  ViewController.swift ボタンのAction接続を作る。ボタンがタップされたら遷移するようにする。
class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view.</description>
    </item>
    
    <item>
      <title>Elm/JavaScript ローカルサーバーで通信する際にハマったこと</title>
      <link>https://bombrary.github.io/blog/posts/elm-with-localserver/</link>
      <pubDate>Thu, 19 Dec 2019 09:50:00 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/elm-with-localserver/</guid>
      <description>今回たまたまクライアント側でElmを使ったけど、これはElmに限ったことではない。
結論 Client側での留意点  urlはlocalhost:[port]ではなくhttp://localhost:[port]と指定しなければならない。つまり、URLにはちゃんとスキーム名を指定する。  Server側での留意点  Access-Control-Allow-Originに関連するヘッダーをちゃんと設定する。  成功コード プログラムの内容 サーバーは{ &amp;quot;msg&amp;quot; : &amp;quot;Hello, World!&amp;quot; }という内容のJSONを送ってくるので、クライアントはその値を受け取って&amp;rdquo;Success: Hello, World!&amp;ldquo;を出力する。それだけ。
Client: Elm module Main exposing (..) import Browser exposing (..) import Json.Decode exposing (..) import Http exposing (..) import Html exposing (..) import Html.Attributes exposing (..) main = Browser.element { init = init , update = update , view = view , subscriptions = subscriptions } type Model = Loading | Failed | Success String init : () -&amp;gt; (Model, Cmd Msg) init _ = ( Loading, getServer ) type Msg = GotData (Result Http.</description>
    </item>
    
    <item>
      <title>D3.js 01信号の可視化</title>
      <link>https://bombrary.github.io/blog/posts/d3js-01signal/</link>
      <pubDate>Tue, 17 Dec 2019 13:56:36 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/d3js-01signal/</guid>
      <description>信号に関する授業を聴いていたらふと思い立ったのでやってみた。
コード index.html 個人的テンプレを書く。
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;ja&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;0-1 Signal&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;0-1 Signale&amp;lt;/h1&amp;gt; &amp;lt;svg&amp;gt; &amp;lt;/svg&amp;gt; &amp;lt;script src=&amp;#34;https://d3js.org/d3.v5.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;script.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; script.js JavaScriptでflatMap使うのはこれが初めてかも。
const format = (data, w) =&amp;gt; { const pairs = d3.pairs(data); const deltas = pairs.flatMap(e =&amp;gt; { let sig = e.toString() if (sig == &amp;#39;0,0&amp;#39;) { return [[1,0]]; } else if (sig == &amp;#39;0,1&amp;#39;) { return [[1,0],[0,-1]]; } else if (sig == &amp;#39;1,0&amp;#39;) { return [[1,0],[0,1]]; } else if (sig == &amp;#39;1,1&amp;#39;) { return [[1,0]]; } else { throw new Error(&amp;#39;invalid element.</description>
    </item>
    
    <item>
      <title>iPhoneアプリ開発メモ - TableViewCellのスワイプ処理</title>
      <link>https://bombrary.github.io/blog/posts/iphone-table-swipe/</link>
      <pubDate>Sun, 15 Dec 2019 10:27:58 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/iphone-table-swipe/</guid>
      <description>目標 スワイプしたら削除されるテーブルを作る。
準備 TableViewに最低限の設定をしておく。
Main.storyboardを次のようにする。
  ViewController.swiftの内容を以下のようにする。
class ViewController: UIViewController { @IBOutlet weak var tableView: UITableView! var items = [&amp;#34;Item1&amp;#34;, &amp;#34;Item2&amp;#34;, &amp;#34;Item3&amp;#34;, &amp;#34;Item4&amp;#34;, &amp;#34;Item5&amp;#34;] override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view. tableView.dataSource = self tableView.delegate = self } } extension ViewController: UITableViewDataSource { func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&amp;gt; Int { items.count } func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell { let cell = tableView.</description>
    </item>
    
    <item>
      <title>iPhoneアプリ開発メモ - UIPageViewControllerの利用</title>
      <link>https://bombrary.github.io/blog/posts/iphone-pageview/</link>
      <pubDate>Sat, 14 Dec 2019 22:35:31 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/iphone-pageview/</guid>
      <description>目標 ウォークスルーっぽいものを作る。
 メイン画面でボタンを押すとウォークスルー画面に飛ぶ。 ウォークスルー画面では、左右にスワイプすると画面が移動する。 画面下に、何ページかを教えてくれる白丸(Page Control)を配置する。  登場物  Main.storyboardとViewController.swift Walkthrough.storyboardとPageViewController.swift  準備 上に書いたものをとりあえず全て作る。ただし、PageViewControllerのサブクラスはUIPageViewControllerであることに注意。
Main.storyboard ボタンを一つ作っておく。
Walkthrough.storyboard 配置を次のようにする
   Page View Controllerのidentifierはwalkとする。また、classをPageViewControllerにする。 &amp;ldquo;Page1&amp;rdquo;と書かれたViewControllerのidentifierはpage1とする。 &amp;ldquo;Page2&amp;rdquo;と書かれたViewControllerのidentifierはpage2とする。 &amp;ldquo;Page3&amp;rdquo;と書かれたViewControllerのidentifierはpage3とする。  以下で、Transition Styleを&amp;rdquo;Scroll&amp;rdquo;とする。もし&amp;rdquo;Page Curl&amp;rdquo;とした場合は、ページをめくるようなアニメーションになる。その代わりにPage Controlが表示されない。
  PageViewController.swift 次のように書く。
class PageViewController: UIPageViewController { var controllers: [UIViewController] = [] override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view. view.backgroundColor = .black let stb = storyboard! let page1 = stb.</description>
    </item>
    
    <item>
      <title>iPhoneアプリ開発メモ - addTarget/SegmentedControl</title>
      <link>https://bombrary.github.io/blog/posts/iphone-addtarget-segmentctl/</link>
      <pubDate>Sat, 14 Dec 2019 19:44:49 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/iphone-addtarget-segmentctl/</guid>
      <description>目標  降順、昇順の切り替えができるTableViewを作成する。  準備 Main.storyborad 部品を以下のように配置する。
  Segmented Controlのラベルの設定は以下で行える。
  TableViewCellのindentifierはtestCellとする。
ViewController.swift 後々の処理のため、TableViewに表示するデータをitems、その元データをitemsSourceと分けることにする。
class ViewController: UIViewController { let itemsSource = [&amp;#34;items1&amp;#34;, &amp;#34;items2&amp;#34;, &amp;#34;items3&amp;#34;, &amp;#34;items4&amp;#34;, &amp;#34;items5&amp;#34;, &amp;#34;items6&amp;#34;, &amp;#34;items7&amp;#34;, &amp;#34;items8&amp;#34;] var items: [String] = [] @IBOutlet weak var segmentedControl: UISegmentedControl! @IBOutlet weak var tableView: UITableView! override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view. tableView.dataSource = self items = itemsSource } } extension ViewController: UITableViewDataSource { func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&amp;gt; Int { return items.</description>
    </item>
    
    <item>
      <title>iPhoneアプリ開発メモ - セミモーダルビューからの遷移</title>
      <link>https://bombrary.github.io/blog/posts/iphone-modal-segue/</link>
      <pubDate>Sat, 14 Dec 2019 11:00:24 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/iphone-modal-segue/</guid>
      <description>目標  セミモーダルビューを作成する セミモーダルビュー上のボタンを押すと、それを閉じた後に別ビューに遷移する。  登場物  Main.storyboardとViewController Menu.storyboardとMenuViewController Dest1.storyboard Dest2.storyboard  前提  今後Viewが増えていく状況を想定して、Storyboardを分割することを考える。Storyboard同士はStoryboard Referenceで結びつける。  セミモーダルビューの作成 検索して良く出てくるのはUIPresentationControllerを利用する方法。ただ今回はなるべくStoryboardで完結させたい。
そこで、以下のページを参考して作ることを考える。
ハンバーガーメニューを作成するには？ - Swift Life
ファイル作成 Menu.storyboard、MenuViewController、 Menu.storyboard、Dest1.storyboard、 Dest2.storyboardの5つをあらかじめ作成しておく。
Menu.storyboard classにはMenuViewControllerを指定する。部品配置は以下のようにする。
全体を包むViewを親View、その中に作ったViewを子Viewと呼ぶことにすると、
 Constraintは適当に設定する。子Viewが画面下に配置されるようにする。 StackViewにはFill Equallyの設定を行っておく。 親Viewの背景色を、黒の半透明に設定する。設定手順は以下の通り。  BackgroundをBlackに設定 BackgroundをCustomに設定し直すと、カラーピッカーが現れる。そこで透明度を50%に設定する。   また、&amp;rdquo;Initial View Controller&amp;rdquo;にチェックをつける。
親Viewのtagを1に設定しておく。これはタッチイベントを捕捉する際に必要になる。
  Dest1.storyboard、Dest2.storyboard Dest1.storyboardの部品配置は以下のようにする。
&amp;ldquo;Is initial View Controller&amp;rdquo;にチェックをつける。
  Dest2.storyboardの部品配置は以下のようにする。
&amp;ldquo;Is initial View Controller&amp;rdquo;にチェックをつける。
  Main.storyboard 部品配置は以下のようにする。
  OpenButtonからStoryboard ReferenceへのSegueのActionは&amp;rdquo;Present Modally&amp;rdquo;を選択。Segueの設定は以下のようにする。</description>
    </item>
    
    <item>
      <title>Socket通信勉強(2) - Pythonでの書き方/HTTPサーバーもどき作成</title>
      <link>https://bombrary.github.io/blog/posts/socket02-python/</link>
      <pubDate>Sun, 08 Dec 2019 11:09:35 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/socket02-python/</guid>
      <description>PythonでのSocket通信 やってることはCでやったときと同じである。サーバーとクライアントの通信手順は同じだし、関数名も同じである。しかしCで書いた場合に比べてシンプルに書ける。エラーは例外として投げられるため、自分で書く必要がない。またsockaddr_inなどの構造体が登場することはなく、Pythonでのbind関数とconnect関数の引数に直接アドレス・ポートを指定する。
server.py 前回と同じく、以下の手順で通信を行う。
 listen(待ち受け)用のソケット作成 - socket 「どこからの接続を待つのか」「どのポートにて待ち受けするのか」を決める - bind関数の引数 ソケットにその情報を紐つける - bind 実際に待ち受けする - listen 接続要求が来たら受け入れる - accept 4によって通信用のソケットが得られるので、それを用いてデータのやりとりをする- send/recv  import socket s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind((&amp;#34;&amp;#34;, 8000)) s.listen(5) (sock, addr) = s.accept() print(&amp;#34;Connected by&amp;#34; + str(addr)) sock.send(&amp;#34;Hello, World&amp;#34;.encode(&amp;#39;utf-8&amp;#39;)) sock.close() s.close() 上のコードを見れば各関数がどんな形で引数をとって、どんな値を返すのかがわかると思う。いくつか補足しておく。
bind (受け入れアドレス, ポート)というタプルを引数にとる。受け入れアドレスを空文字列にしておけば、どんなアドレスからの接続も受け入れる。つまりCでやったINADDR_ANYと同じ。
s.bind((&amp;#34;&amp;#34;, 8000)) encode Pythonのstring型をそのまま送ることはできないので、byte型に変換する。これはstring.encodeで行える。
sock.send(&amp;#34;Hello, World&amp;#34;.encode(&amp;#39;utf-8&amp;#39;)) client.py  サーバーとの通信用のソケット作成 - socket サーバが待ち受けている宛先を設定 - connectの引数 2で設定した宛先に対して接続する - connect 1で作ったソケットを用いてデータのやりとりをする。 - send/recv  import socket sock = socket.</description>
    </item>
    
    <item>
      <title>Androidアプリ開発勉強(4) - LiveData/TableLayout/電卓アプリ作成</title>
      <link>https://bombrary.github.io/blog/posts/android04-calc/</link>
      <pubDate>Thu, 28 Nov 2019 14:24:39 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/android04-calc/</guid>
      <description>どんなアプリを作るか 電卓を作る。
市販の電卓とは違い、括弧が使えるようにする。なので、軽い構文解析を書くことになる。しかし今回の記事ではデータの扱い方やViewの組み方に焦点を当てているため、電卓の計算処理についてはかなり軽めに説明する。
プロジェクト作成  プロジェクト名は&amp;rdquo;Calculator&amp;rdquo;とする。 DataBindingは有効にする  Fragmentに分ける 今回は1画面のアプリなのでわざわざFragmentに分ける必要もないのだが、「もしかしたら他にもFragmentを追加するかもしれない」というケースを想定して、一応分けてみる。
 CalcFragmentを作成する。xmlファイルはfragment_calc.xmlとする。 activity_main.xmlの内容を以下のようにする。  &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;merge xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34; xmlns:app=&amp;#34;http://schemas.android.com/apk/res-auto&amp;#34; xmlns:tools=&amp;#34;http://schemas.android.com/tools&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;match_parent&amp;#34; tools:context=&amp;#34;.MainActivity&amp;#34;&amp;gt; &amp;lt;fragment android:id=&amp;#34;@+id/calcFragment&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;match_parent&amp;#34; android:name=&amp;#34;com.example.calculator.CalcFragment&amp;#34; /&amp;gt; &amp;lt;/merge&amp;gt; merge Android Kotlin Fundamentals 06.2で存在を初めて知った。こうするとactivity_main.xmlでLayoutを作って、fragmentの中でもまたLayoutを作るといった冗長性を排除できる。
CalcFragmentの設定 string.xml fragment_calc.xmlに設定するための文字列定数を定義する。string.xmlを以下のようにする。
&amp;lt;resources&amp;gt; &amp;lt;string name=&amp;#34;app_name&amp;#34;&amp;gt;Calculator&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_0&amp;#34;&amp;gt;0&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_1&amp;#34;&amp;gt;1&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_2&amp;#34;&amp;gt;2&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_3&amp;#34;&amp;gt;3&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_4&amp;#34;&amp;gt;4&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_5&amp;#34;&amp;gt;5&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_6&amp;#34;&amp;gt;6&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_7&amp;#34;&amp;gt;7&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_8&amp;#34;&amp;gt;8&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_9&amp;#34;&amp;gt;9&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_plus&amp;#34;&amp;gt;+&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_minus&amp;#34;&amp;gt;-&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_mul&amp;#34;&amp;gt;*&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_div&amp;#34;&amp;gt;/&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_ac&amp;#34;&amp;gt;AC&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_eq&amp;#34;&amp;gt;=&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_lp&amp;#34;&amp;gt;(&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;calc_rp&amp;#34;&amp;gt;)&amp;lt;/string&amp;gt; &amp;lt;/resources&amp;gt; fmagment_calc.</description>
    </item>
    
    <item>
      <title>gnuplotの使い方メモ</title>
      <link>https://bombrary.github.io/blog/posts/gnuplot/</link>
      <pubDate>Tue, 26 Nov 2019 10:59:56 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/gnuplot/</guid>
      <description>備忘録に。
インストール Macの場合はbrewでインストールできる。
$ brew install gnuplot gnuplotコマンドで起動。
ファイルをプロットする 例えばdata.txtが以下のようになっているとする。
#x #y1 #y2 0 1 2 1 2 1 2 0 2 3 1 1 これを描画する。
using X:Yで、X番目の列を横軸、Y番目の列を縦軸にする。
w lpとは&amp;rdquo;with linespoints&amp;rdquo;の略。つまり線と点を描画する。w lだと&amp;rdquo;with line&amp;rdquo;、w lp lt 3 lw 2だと&amp;rdquo;with linepoints linetype 3 linewidth 2&amp;rdquo;という意味。いろいろある。
$ set xlabel &amp;#34;X axis&amp;#34; $ set ylabel &amp;#34;Y axis&amp;#34; $ plot &amp;#34;data.txt&amp;#34; using 1:2 w pl 軸の範囲指定 例えばx軸を[0,3000]の範囲に制限して描画したいなら、次のコマンドを打つ。
$ set xrange [0:3000] こんな感じで、gnuplotはset 属性名 値で様々な設定をする印象がある。</description>
    </item>
    
    <item>
      <title>Socket通信の勉強(1) - ディスクリプタ/TCPによる通信</title>
      <link>https://bombrary.github.io/blog/posts/socket01-file-tcp/</link>
      <pubDate>Sun, 24 Nov 2019 17:08:19 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/socket01-file-tcp/</guid>
      <description>Socket通信を勉強する。
前提  プログラムはMac(Mojave)で動かす。 ネットワークに関する知識はほんの少しある。 使うプログラミング言語はC++だが、ここではbetter Cの意味でしか用いない。  (寄り道) ファイル入出力 Socket通信を学んでいると、ファイルディスクリプタが出てきたので、まずはそこから勉強する。
関数定義についてはJM Projectから引用したものを用いる。これはLinuxマニュアルと同じらしいので、恐らくmanコマンドで出力されるものと同じである(ただし英語であるが)。
ファイルディスクリプタとは ファイルディスクリプタとは、ファイルと結びつけられた単なる整数値である。データの読み書きを行う場合は、この整数値を指定してアクセスする。例えばファイルtest.txtのファイルディスクリプタが4だった場合、読み書きをする関数read/writeには引数4を指定する。
個人的には、ファイルとプロセスのやりとりはあるケーブルを介して行なっているイメージがある。例えば番号4の端子にはすでにtest.txtが繋がっているとしよう。このとき、プロセスがtext.txtにアクセスしたいなら、番号4の端子にアクセスすれば良い。
  ファイルの読み込み ファイルディスクリプタを用いてファイルを読み込む例を以下に示す。以下は、test.txtを読み込んで、そのファイルディスクリプタとファイルの内容を出力するプログラムである。
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;fcntl.h&amp;gt; int main() { int fd = open(&amp;#34;test.txt&amp;#34;, O_RDONLY); char buf[64]; read(fd, buf, sizeof(buf)); printf(&amp;#34;fd: %d\n&amp;#34;, fd); printf(&amp;#34;%s\n&amp;#34;, buf); close(fd); return 0; }  test.txtの内容は以下のようにする。
Hello, World 実行すると、以下のように出力される。fdの値は実行環境によって異なる。
fd: 3 Hello, World 以下説明するopen/read/closeは関数ではなく、全てシステムコールである。
openでファイルを開く 開きたいファイルのパスと、読み書きの方法を引数に指定する。成功するとファイルディスクリプタを返す。
#include &amp;lt;fcntl.h&amp;gt; int open(const char *pathname, int flags);  readで読み込む ファイルディスクリプタと、読み取った値を保持しておくためのバッファ、また読み取るデータの長さを指定する。</description>
    </item>
    
    <item>
      <title>Androidアプリ開発勉強(3) - データの受け渡し</title>
      <link>https://bombrary.github.io/blog/posts/android03-dataholding/</link>
      <pubDate>Fri, 22 Nov 2019 08:53:21 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/android03-dataholding/</guid>
      <description>次の2つの事項について扱う。
 DataBindingにおけるデータの受け渡し Navigationを用いた、異なるFragment間におけるデータの受け渡し  さらに具体的に言うと、次の機能を持つアプリを作る
 MainFragmentにはEditTextが1つある。 EditTextが入力されると、TextViewが&amp;rdquo;String: [EditTextの文字列]&amp;ldquo;に変わる。 Buttonが押されると、ReverseFragmentに遷移する ReverseFragmentは、MainFragmentのテキストフィールドの文字列を受け取って、それを逆順にした文字列を表示する。  Android Kotlin Fundamentals Courseでの05辺りを勉強した記録なので、詳しいことはそちらに載っている。
プロジェクト初期設定 &amp;ldquo;Empty Project&amp;rdquo;として作成して、名前を&amp;rdquo;DataTest&amp;rdquo;とする。
build.gradle(module:App)について、dataBindingの設定をしておく。
次のようにMainFragmentとReverseFragmentを作成しておく。作成時、&amp;rdquo;Create layout XML?&amp;ldquo;にのみチェックをつけておく。   MainFragmentの設定 fragment_main.xmlを次のようにする。
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;layout xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34; xmlns:tools=&amp;#34;http://schemas.android.com/tools&amp;#34; tools:context=&amp;#34;.main.MainFragment&amp;#34;&amp;gt; &amp;lt;data&amp;gt; &amp;lt;variable name=&amp;#34;myMsg&amp;#34; type=&amp;#34;com.example.datatest.main.MainFragment.MyMsg&amp;#34; /&amp;gt; &amp;lt;/data&amp;gt; &amp;lt;LinearLayout android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34; android:orientation=&amp;#34;vertical&amp;#34; android:layout_gravity=&amp;#34;center_vertical&amp;#34; &amp;gt; &amp;lt;EditText android:id=&amp;#34;@+id/edit_text&amp;#34; android:layout_width=&amp;#34;wrap_content&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34; android:hint=&amp;#34;@string/hello_blank_fragment&amp;#34; android:layout_gravity=&amp;#34;center_horizontal&amp;#34; android:textAlignment=&amp;#34;center&amp;#34; /&amp;gt; &amp;lt;TextView android:id=&amp;#34;@+id/text_view&amp;#34; android:layout_width=&amp;#34;wrap_content&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34; android:text=&amp;#34;@={myMsg.text}&amp;#34; android:layout_gravity=&amp;#34;center_horizontal&amp;#34; android:textAlignment=&amp;#34;center&amp;#34; /&amp;gt; &amp;lt;Button android:id=&amp;#34;@+id/button&amp;#34; android:layout_width=&amp;#34;wrap_content&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34; android:layout_gravity=&amp;#34;center_horizontal&amp;#34; android:text=&amp;#34;@string/to_reverse_fragment&amp;#34; android:textAllCaps=&amp;#34;false&amp;#34; /&amp;gt; &amp;lt;/LinearLayout&amp;gt; &amp;lt;/layout&amp;gt; 重要なのは以下の部分で、これはMainFragment.</description>
    </item>
    
    <item>
      <title>Androidアプリ開発勉強(2) - Navigationの基本</title>
      <link>https://bombrary.github.io/blog/posts/android02-navigation/</link>
      <pubDate>Wed, 20 Nov 2019 09:03:17 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/android02-navigation/</guid>
      <description>Navigationを用いて画面遷移をやってみる。具体的には以下の処理を行う。
 Fragment01とFragment02を用意する Fragment01でボタンが押されたらFragment02に遷移する  Android Kotlin Fundamentals Courseでの03辺りを勉強した記録なので、詳しいことはそちらに載っている。
Navigationについて 異なるFragment間の遷移を制御する仕組み。遷移の設定を視覚的に行えるらしい。
これ以前はIntentという仕組みを用いていたらしい。これについては必要になりそうならいつか調べる。
プロジェクト作成 Empty Activityを選択し、名前をNavigation Testとする。
build.gradle(Module: app)でDataBindingを有効にしておく。
Fragmentの作成 layouts/にFragmentを作成する。&amp;rdquo;Create layout XML?&amp;ldquo;だけチェックをつけておく。Fragmentは2つ作成し、それぞれ&amp;rdquo;Fragment01&amp;rdquo;と&amp;rdquo;Fragment02&amp;rdquo;とする。xmlファイルはそれぞれfragment_fragment01.xml、fragment_fragment02.xmlとする。
まずTextViewのtext要素に設定するための定数をstrings.xmlに内容を追加しておく。 &amp;lt;resources&amp;gt; &amp;lt;string name=&amp;#34;app_name&amp;#34;&amp;gt;NavigationTest&amp;lt;/string&amp;gt; &amp;lt;!-- TODO: Remove or change this placeholder text --&amp;gt; &amp;lt;string name=&amp;#34;hello_blank_fragment&amp;#34;&amp;gt;Hello blank fragment&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;fragment01&amp;#34;&amp;gt;Fragment01&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;fragment02&amp;#34;&amp;gt;Fragment02&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;click&amp;#34;&amp;gt;Click&amp;lt;/string&amp;gt; &amp;lt;/resources&amp;gt;
fragment_fragment01.xmlの内容は以下の通りにする。Buttonを追加し、textを@string/clickに設定する。TextViewのtextを@string/fragment01に設定する。また全体をConstraintLayoutで包み、DataBindingのためにlayoutでさらに包む。
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;layout xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34; xmlns:app=&amp;#34;http://schemas.android.com/apk/res-auto&amp;#34; xmlns:tools=&amp;#34;http://schemas.android.com/tools&amp;#34; tools:context=&amp;#34;.Fragment01&amp;#34;&amp;gt; &amp;lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;match_parent&amp;#34;&amp;gt; &amp;lt;TextView android:id=&amp;#34;@+id/text_fragment01&amp;#34; android:layout_width=&amp;#34;wrap_content&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34; android:text=&amp;#34;@string/fragment01&amp;#34; app:layout_constraintBottom_toBottomOf=&amp;#34;parent&amp;#34; app:layout_constraintEnd_toEndOf=&amp;#34;parent&amp;#34; app:layout_constraintStart_toStartOf=&amp;#34;parent&amp;#34; app:layout_constraintTop_toTopOf=&amp;#34;parent&amp;#34; /&amp;gt; &amp;lt;Button android:id=&amp;#34;@+id/button&amp;#34; android:layout_width=&amp;#34;wrap_content&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34; android:text=&amp;#34;@string/click&amp;#34; app:layout_constraintBottom_toTopOf=&amp;#34;@+id/text_fragment01&amp;#34; app:layout_constraintEnd_toEndOf=&amp;#34;parent&amp;#34; app:layout_constraintStart_toStartOf=&amp;#34;parent&amp;#34; app:layout_constraintTop_toTopOf=&amp;#34;parent&amp;#34; /&amp;gt; &amp;lt;/androidx.</description>
    </item>
    
    <item>
      <title>Androidアプリ開発勉強(1) - onClick/DataBinding/Fragment</title>
      <link>https://bombrary.github.io/blog/posts/android01-helloworld/</link>
      <pubDate>Tue, 19 Nov 2019 19:54:40 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/android01-helloworld/</guid>
      <description>Android + Kotlinを用いてアプリ開発をするときの勉強メモ。勉強メモなので備忘録程度にしか書いてない。
次のことをやった。
 ボタンを押すとToastを表示 DataBindingを用いる Fragmentを用いる Fragment + DataBinding  Android Kotlin Fundamentals Courseでの01-03辺りを勉強した記録なので、詳しいことはそちらに載っている。
前提  Kotlinは未学習だが雰囲気で読める Android開発は完全未経験  iPhoneアプリ開発は少しだけ経験  Android Studioの環境構築は済んでいる  エミュレータのインストールも完了している Build &amp;amp; Runの方法も知っている   プロジェクト作成 とりあえずプロジェクト名はTestProjectとする。
左側のペインに色々ディレクトリ・ファイルがある。色々漁ってみると、次のようなものがある。
 java/com.example.testapplication/: 基本的にはこの中にKotlinのソースコードを入れるっぽい。ディレクトリ名がjavaなのは歴史的な理由らしい。 res/: resourceの略で、画面や定数の定義がこの中に色々入っている。  res/layout: 画面の定義ファイルが入っている res/values: 定数の定義が入っている  res/values/colors.xml: 色定義 res/values/strings.xml: 文字列定数の定義 res/values/styles.xml: styleの定義。画面の部品のstyleをCSSみたいに設定するためのもの。   build.gradle: Buildの際の様々な設定を記したファイル。  ボタンの配置 res/layouts/activity_main.xmlにメイン画面の定義が書かれている。中央ペイン左下にDesign/Textを切り替えるタブがある。
Designタブ GUIで画面の構造をいじるための画面。直感的に操作できる。色々なペインで分かれている。
 Palette: ドラックアンドドロップできる。 Component Tree: 部品同士の階層構造を表示している。内部構造はXMLなので部品は階層構造になっている。 Attributes: 部品の様々な属性を設定。たくさんあるが、虫眼鏡マークで検索可能。便利。中でもid属性は重要。  id: 部品の識別子。プログラムからアクセスするためにここの設定が必要。   Component Treeにおいて、rootがConstraint Layoutであることに注目。これはConstraint(制約)を用いて部品の配置を設定するためのLayoutである。Constraintについてはやってみた方が早い。</description>
    </item>
    
    <item>
      <title>Djangoの勉強でTodoリストを作る</title>
      <link>https://bombrary.github.io/blog/posts/django-todo-list/</link>
      <pubDate>Fri, 15 Nov 2019 08:26:41 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/django-todo-list/</guid>
      <description>どんなTodoリストを作るか  Todoの登録  情報は短いテキストだけ  Todoをリスト表示 Todoをクリックすると削除  サイトの作成 適当なディレクトリで次のコマンドを実行すると、mysiteというディレクトリが作られる。以降はmysiteディレクトリで作業する。
$ django-admin startproject mysite  アプリの作成 mysiteディレクトリにて以下のコマンドを実行すると、todo_listというディレクトリが作られる。ここに実際のアプリの処理を記述していく。:w
$ python3 manage.py startapp todo_list  続いてmysite/settings.pyを開いて、INSTALL_APPSを以下の記述にする。&#39;todo_list.apps.TodoListConfig&#39;を追加しただけ。これはデータベース作成やテンプレート作成のために、djangoがtodo_listのディレクトリを教えているっぽい。Todo_listConfigかと思ったが違うらしい(エラーで「TodoListConfigだよ」と教えてくれた。優しい)。
INSTALLED_APPS = [ &amp;#39;todo_list.apps.TodoListConfig&amp;#39;, &amp;#39;django.contrib.admin&amp;#39;, &amp;#39;django.contrib.auth&amp;#39;, &amp;#39;django.contrib.contenttypes&amp;#39;, &amp;#39;django.contrib.sessions&amp;#39;, &amp;#39;django.contrib.messages&amp;#39;, &amp;#39;django.contrib.staticfiles&amp;#39;, ] viewの作成 mysite/todo_list/views.pyを編集する。とりあえずviewが動くかどうかだけ確認したいので、レスポンスは適当な文字列にする。
from django.shortcuts import render # Create your views here. def index(request): return HttpResponse(&amp;#39;Hello&amp;#39;) urlの設定 まずmysite/mysite/urls.pyの設定をする。urls.pyとは「どんなurlにアクセスされたらどんなviewに処理を任せるか」を記述したものっぽい。ここでは、todo_list/で始まるurlだったらtodo_list/urls.pyに処理を任せるように書いている。
from django.contrib import admin from django.urls import include, path urlpatterns = [ path(&amp;#39;todo_list/&amp;#39;, include(&amp;#39;todo_list.urls&amp;#39;)), path(&amp;#39;admin/&amp;#39;, admin.site.urls), ] ということでmysite/todo_list/urls.</description>
    </item>
    
    <item>
      <title>置換(Permutaion)の勉強メモ(1)</title>
      <link>https://bombrary.github.io/blog/posts/permutation/</link>
      <pubDate>Tue, 12 Nov 2019 10:07:09 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/permutation/</guid>
      <description>置換について、線形代数の教科書に出てきたけど、授業ではあまり触れられなかったので自分で勉強してみる。以下はそのメモ。
置換の定義 定義(置換) $X_n$は$n$個の元を持つ集合とする。このとき、全単射写像 $\sigma: X_n \rightarrow X_n$ を$X_n$上の置換(Permutation)と呼ぶ。  言い換えると、$X_n$を適当に並べたとき、置換 $\sigma$ とはそれを並び替える方法を表したものである。
置換と聞くとReplacementがまず思い浮かぶけど、ここではPermutationなのね。
例 $X_3 = {1,2,3}$ とする。このとき、 $X_n$ の元を並べて $(1,2,3)$ としよう。このとき、 $\sigma(1)=2,\sigma(2)=3,\sigma(3)=1$ とすれば、写像 $\sigma$ は $X_3$ 上の置換となる。このとき、 $(1,2,3)$ という列が $\sigma$ によって $(2,3,1)$ に並び替えられたように見える。  $X_n$の元はなんでも良いが、以後説明のため$X_n = \lbrace 1,2,\ldots,n \rbrace$とする。
置換は以下のように表示することがある：$\sigma(i) = p_i\ (i=1,\ldots,n)$について、
$$ \sigma = \begin{pmatrix} 1 &amp;amp; 2 &amp;amp; \ldots &amp;amp; n \\ p_1 &amp;amp; p_2 &amp;amp; \ldots &amp;amp; p_n \end{pmatrix} $$
先ほど置換とは $X_n$ を適当に並べたとき、置換 $\sigma$ とはそれを並び替えたもの、と表現した。実際、$\sigma$はただの写像なので、並び替えというより対応関係だけが大事である。上の表示方法はあくまで「上の段の元と下の段の元の対応関係」にだけ着目している。従って、上の段が$1,2,\ldots n$という並びになるとは限らない。</description>
    </item>
    
    <item>
      <title>Elmで超簡易Todoリスト</title>
      <link>https://bombrary.github.io/blog/posts/elm-todo-list/</link>
      <pubDate>Sun, 10 Nov 2019 21:08:12 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/elm-todo-list/</guid>
      <description>Todoリストと言っても、フィールドに入力した内容がli要素として追加されるだけ。
Elm習いたてなので、何か無駄があるかも。
個人的になるほどと思った点はList.mapを利用してli要素を生成するところで、これは要素を生成する関数が子要素のリストを引数に取るから実現できる。
import Browser import Html exposing (..) import Html.Attributes exposing (..) import Html.Events exposing (onClick, onInput) main = Browser.sandbox { init = init, update = update, view = view } --Model type alias Todo = { description : String } type alias Model = { todos : List Todo , input : Todo } init : Model init = { todos = [] , input = Todo &amp;#34;&amp;#34; } type Msg = Add | Change String --Update update : Msg -&amp;gt; Model -&amp;gt; Model update msg model = case msg of Add -&amp;gt; { model | todos = model.</description>
    </item>
    
    <item>
      <title>HugoセットアップからGitHubにデプロイするまでの備忘録</title>
      <link>https://bombrary.github.io/blog/posts/hugo-setup/</link>
      <pubDate>Sat, 09 Nov 2019 19:33:37 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/hugo-setup/</guid>
      <description>簡単にセットアップ方法を備忘のために書いておく
前提  MacOS Mojave Homebrew 2.1.16 GitHubのblogリポジトリで公開する この記事でディレクトリを表記する時は、blogローカルリポジトリの最上位を/で表現する  インストール ターミナルにて以下のコマンドを叩く
$ brew install hugo ブログサイトの作成 blogサイトのローカルリポジトリがある前提で進める。blogディレクトリに移動して以下のコマンドを実行する。 forceフラグをつけると、今のディレクトリに何かファイルがあった場合でもサイトを生成してくれる。僕の環境の場合はREADME.mdしかなかったので何も上書きされなかったが、hugoが生成するファイルと名前がかぶる場合は、何かファイルが上書きされる恐れがあるので注意。
$ hugo new site ./ --force すると、何やらたくさんファイルやディレクトリを生成してくれる。
テーマの追加 contrast-hugoが気に入ったのでこれを使う。
/themesに移動して、contrast-hugoのファイルをcloneしてくる
$ git clone https://github.com/niklasbuschmann/contrast-hugo.git 後でテーマをいじるので、一応テーマ名を変更しておく。contrast-hugoをch-modifiedに変更する。
シンタックスハイライトの設定 Chromaというハイライターが入っているらしい。そのテーマはこちらで見られる。今回はgithubというテーマを利用する。
/config.tomlでpygmentsStyle=githubと指定すると、スタイルをhtmlに直接埋め込んでくれる。しかしCSSを後で自分でいじりたいのでこの方法は用いない。その代わり、pygmentsUseClasses=trueとして、CSSを利用することにする。
/themes/ch-modified/static/cssに移動して、以下のコマンドを実行する。
$ hugo gen chromastyles --style=github &amp;gt; syntax.css configの設定 /config.tomlの内容を以下の通りにする。ほとんどの設定項目がデフォルトのもので、正直意味が分かっていないものもある。コメントアウトのところはAboutページのリンクを貼るものだが、Aboutページができたらコメントを外そうと思っている。
baseURL = [ブログのURL] title = [ブログのタイトル] author = [作成者] paginate = 3 languageCode = &amp;#34;ja-jp&amp;#34; DefaultContentLanguage = &amp;#34;ja&amp;#34; enableInlineShortcodes = true footnoteReturnLinkContents = &amp;#34;^&amp;#34; theme = [テーマ] publishDir=&amp;#34;docs&amp;#34; pygmentsUseClasses = true [menu] # 気が向いたら設定する # [[menu.</description>
    </item>
    
    <item>
      <title>Test</title>
      <link>https://bombrary.github.io/blog/posts/my-first-post/</link>
      <pubDate>Sat, 09 Nov 2019 16:00:56 +0900</pubDate>
      
      <guid>https://bombrary.github.io/blog/posts/my-first-post/</guid>
      <description>このブログではHugoを使っている。
 Syntax highlighting #include &amp;lt;iostream&amp;gt; int main() { std::cout &amp;lt;&amp;lt; &amp;#34;Hello&amp;#34; &amp;lt;&amp;lt; std::endl; return 0; } 
 KaTeX
 inline: $x = 2$ block: $$ x^2 + x + 1 = 0 $$   </description>
    </item>
    
  </channel>
</rss>