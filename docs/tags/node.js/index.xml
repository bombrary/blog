<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Node.js on Chanomic Blog</title>
    <link>https://bombrary.github.io/blog/tags/node.js/</link>
    <description>Recent content in Node.js on Chanomic Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Thu, 25 Jun 2020 09:05:09 +0900</lastBuildDate>
    <atom:link href="https://bombrary.github.io/blog/tags/node.js/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>PureScriptでじゃんけんゲーム(CUI)を作る</title>
      <link>https://bombrary.github.io/blog/posts/purescript-janken/</link>
      <pubDate>Thu, 25 Jun 2020 09:05:09 +0900</pubDate>
      <guid>https://bombrary.github.io/blog/posts/purescript-janken/</guid>
      <description>プログラミングの初歩で作りそうなじゃんけんゲームを作る。ただし、PureScriptで作る。&#xA;方針 Jankenというモジュールを作る グー・チョキ・パーをHandとして定義する じゃんけんの勝負の結果をJudgementとして定義する コンピュータが出す手はランダムに出したいので、ランダムな手を出す関数randomを作っておく 入力は文字列にしたいので、文字列から手に変換する関数fromStringを作っておく 入出力はMainに書く。Node.ReadLineモジュールの力で入力を受け付ける。 準備 適当なプロジェクトディレクトリを作っておいて、&#xA;$ spago init /src/Main.pursと/src/Janken.pursを作っておく。&#xA;/src/Main.pursはとりあえず以下のようにしておく。&#xA;module Main where import Prelude import Effect (Effect) import Effect.Console (log) main :: Effect Unit main = do log &amp;#34;Hello&amp;#34; 次のコマンドでHelloが出力されることを確認する。&#xA;$ spago run Jankenモジュールの定義 この節では/src/Janken.pursを編集していく。&#xA;module Janken where import Prelude Handの定義 じゃんけんの手を表す型Handを定義する。&#xA;data Hand = Rock | Scissors | Paper 余談。これは公式ではタグ付き共用体と呼ばれているもの。Haskellでは代数的データ型と呼ばれているが、正直名前はどうでもいい。データをこのように表現すれば、「データはこの値しかとりえない」という制限が得られる。制限があれば、プログラムのバグも減らせる。たとえば、「グーを0、チョキを1、パーを2」として表現すると、万が一それ以外の値が来た場合に困る。上のようなHandの定義では、「それ以外の値」が入る余地すら与えない。…この話は、Elm Guideの受け売り。&#xA;Judgementの定義 同じようにして、じゃんけんの勝敗を表す型Judgementを定義する。&#xA;Judgement = WinLeft | WinRight | Draw なぜWinとかLoseではないのかというと、これはjudge関数の都合である。Judgeは、2つの手を引数にとり、その勝負結果を返す。WinやLoseだと、どっちが勝ちでどっちが負けか分からない。なので、「judgeの左側の引数が勝ったらWinLeft、右側が勝ったらWinRight、引き分けならDraw」と定義している。&#xA;judge :: Hand -&amp;gt; Hand -&amp;gt; Judgement judge Rock Rock = Draw judge Scissors Scissors = Draw judge Papser Paper = Draw judge Rock Scissors = WinLeft judge Scissors Paper = WinLeft judge Paper Rock = WinLeft judge _ _ = WinRight REPLで遊ぶ REPLでテストしてみたい。Showクラスのインスタンスにすることで、REPLで値が出力できるようになる。</description>
    </item>
    <item>
      <title>Elm/JavaScript ローカルサーバーで通信する際にハマったこと</title>
      <link>https://bombrary.github.io/blog/posts/elm-with-localserver/</link>
      <pubDate>Thu, 19 Dec 2019 09:50:00 +0900</pubDate>
      <guid>https://bombrary.github.io/blog/posts/elm-with-localserver/</guid>
      <description>今回たまたまクライアント側でElmを使ったけど、これはElmに限ったことではない。&#xA;結論 Client側での留意点 urlはlocalhost:[port]ではなくhttp://localhost:[port]と指定しなければならない。つまり、URLにはちゃんとスキーム名を指定する。 Server側での留意点 Access-Control-Allow-Originに関連するヘッダーをちゃんと設定する。 成功コード プログラムの内容 サーバーは{ &amp;quot;msg&amp;quot; : &amp;quot;Hello, World!&amp;quot; }という内容のJSONを送ってくるので、クライアントはその値を受け取って&amp;quot;Success: Hello, World!&amp;ldquo;を出力する。それだけ。&#xA;Client: Elm module Main exposing (..) import Browser exposing (..) import Json.Decode exposing (..) import Http exposing (..) import Html exposing (..) import Html.Attributes exposing (..) main = Browser.element { init = init , update = update , view = view , subscriptions = subscriptions } type Model = Loading | Failed | Success String init : () -&amp;gt; (Model, Cmd Msg) init _ = ( Loading, getServer ) type Msg = GotData (Result Http.</description>
    </item>
  </channel>
</rss>
