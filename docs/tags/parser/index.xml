<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Parser on Chanomic Blog</title>
    <link>https://bombrary.github.io/blog/tags/parser/</link>
    <description>Recent content in Parser on Chanomic Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Fri, 31 Dec 2021 15:26:00 +0900</lastBuildDate>
    <atom:link href="https://bombrary.github.io/blog/tags/parser/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>PureScriptでパーサーコンビネータを触る (2) テキストファイル</title>
      <link>https://bombrary.github.io/blog/posts/purescript-parser-combinator02/</link>
      <pubDate>Fri, 31 Dec 2021 15:26:00 +0900</pubDate>
      <guid>https://bombrary.github.io/blog/posts/purescript-parser-combinator02/</guid>
      <description>前回の記事 と合わせて1つの記事にする予定だったが、前回があまりに長くなってしまったので分割した。&#xA;ある書式に従ったテキストファイルをパースすることを考える。パースしたデータを整形し、HTML文書として出力するところまでやる。&#xA;前回インポートした関数で今回使うものは、(漏れが無ければ)以下の通り。&#xA;import Control.Alt ((&amp;lt;|&amp;gt;)) import Control.Lazy (defer) import Text.Parsing.Parser (Parser, fail) import Text.Parsing.Parser.String (char) テキストの仕様 テキストファイルは、複数のentryで構成される。 1つのentryはタイトルtitleと中身bodyで構成される。 titleは[と]でくくられる。 titleとbodyの間、bodyと次のentryのtitleの間には、1つの改行と、0個以上の空行があり得る。それらはbodyには含まない。 空行とは、0個以上のスペースだけから構成される行のことである。 BNF風に書くと次のようになるだろう。&#xA;&amp;lt;entries&amp;gt; = (0個以上の&amp;lt;entry&amp;gt;) &amp;lt;entry&amp;gt; = &amp;lt;title&amp;gt; &amp;#34;\n&amp;#34; &amp;lt;empty lines&amp;gt; &amp;lt;body&amp;gt; &amp;#34;\n&amp;#34; &amp;lt;empty lines&amp;gt; &amp;lt;title&amp;gt; = &amp;#34;[&amp;#34; (文字列) &amp;#34;]&amp;#34; &amp;lt;body&amp;gt; = (先頭、末尾が&amp;lt;empty lines&amp;gt;でないような文字列) &amp;lt;empty lines&amp;gt; = (0個以上の&amp;lt;empty line&amp;gt;) &amp;lt;empty line&amp;gt; = (0個以上のスペース) &amp;#34;\n&amp;#34; 例えば、以下のファイルがあったとする。&#xA;[Title1] line1 line2 line3 line4 [Title2] line1 line2 [Title3] line1 line2 line3 これは次のようにパースされる。</description>
    </item>
    <item>
      <title>PureScriptでパーサーコンビネータを触る (1) 四則演算のパース</title>
      <link>https://bombrary.github.io/blog/posts/purescript-parser-combinator01/</link>
      <pubDate>Thu, 30 Dec 2021 09:40:00 +0900</pubDate>
      <guid>https://bombrary.github.io/blog/posts/purescript-parser-combinator01/</guid>
      <description>PureScriptのパーサーコンビネータにpurescript-parsingがある。これはHaskellのParsecが基になっているので、使い方はParsecとほとんど同じだと思われる(とはいえ、Parsecを使ったことはあまりない)。これを用いて四則演算のパーサーを実装してみたが、うまく動かず詰まる点がいくつかあった。その備忘録。&#xA;パーサーコンビネータの準備 % spago install parsing 後々使うので以下のパッケージもインストール。&#xA;% spago install either integers maybe strings arrays lists src/Main.pursに以下の記述を追加。&#xA;import Text.Parsing.Parser (Parser) parser :: Parser String String parser = pure &amp;#34;Hello&amp;#34; REPLを起動して、動くか確認する。どんな文字列を食わせても&amp;quot;Hello&amp;quot;としか結果を返さないパーサーの完成。&#xA;&gt; import Main &gt; import Text.Parsing.Parser (runParser) &gt; runParser &#34;hoge&#34; parser (Right &#34;Hello&#34;) REPLでMain.pursをリロードする場合は:rをREPLで実行する。&#xA;数字のパース 1文字取得 1文字の数字を読み取りたいなら、Text.Parsing.Parser.Tokenにdigitがあるのでそれを使う。&#xA;import Text.Parsing.Parser.Token (digit) parser :: Parser String Char parser = digit &gt; runParser &#34;12345&#34; parser (Right &#39;1&#39;) 1文字以上取得 1文字以上を取得したいなら、Data.Array.Someを使う。&#xA;import Data.Array as Array parser :: Parser String (Array Char) parser = Array.</description>
    </item>
    <item>
      <title>Elmメモ - 文字列をIPアドレスに変換(2) Parserを用いる方法</title>
      <link>https://bombrary.github.io/blog/posts/elm-ipaddr-parse/</link>
      <pubDate>Sun, 05 Jan 2020 14:29:15 +0900</pubDate>
      <guid>https://bombrary.github.io/blog/posts/elm-ipaddr-parse/</guid>
      <description>準備 前回のsrc/IPAddr.elmを全て消し、内容を以下の通りにする。&#xA;module IPAddr exposing (..) import Parser type IPAddr = IPAddr Int Int Int Int $ elm repl &gt; import Parser exposing (..) &gt; import IPAddr exposing (..) Parserの基本 以下の2つのステップに分かれる。&#xA;Parserを作る Parserを実行する - Parser.runを用いる ライブラリでは、標準で用意されているParserと、それらを組み合わせて新たなParserを作るための関数が用意されている。&#xA;&gt; run int &#34;123&#34; Ok 123 : Result (List Parser.DeadEnd) Int &gt; run int &#34;123abc&#34; Ok 123 : Result (List Parser.DeadEnd) Int &gt; run int &#34;abc123abc&#34; Err [{ col = 1, problem = ExpectingInt, row = 1 }] : Result (List Parser.</description>
    </item>
  </channel>
</rss>
